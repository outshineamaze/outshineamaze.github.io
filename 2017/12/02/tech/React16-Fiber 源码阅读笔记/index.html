<!DOCTYPE html>




<html class="theme-next pisces" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<link rel="manifest" href="/manifest.json">








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="react," />










<meta name="description" content="前言提起React,可能脑海里第一印象就是Virtual Dom, 性能好, 渲染快, 之前也看过很多现成的原理分析文章, 但是别人的东西始终是建立在别人的理解之上,既然现在平时的工作已经大规模使用React及其生态，那么React 源码分析一方面可以加深对React理解，另外一方面学习其内核原理，更好的在工作业务中寻找一个最佳实践。本次源码阅读的版本是 从2017年11.28的发布的 React">
<meta name="keywords" content="react">
<meta property="og:type" content="article">
<meta property="og:title" content="React16-Fiber 源码阅读笔记">
<meta property="og:url" content="https://outshineamaze.github.io/2017/12/02/tech/React16-Fiber 源码阅读笔记/index.html">
<meta property="og:site_name" content="Outshine Amaze">
<meta property="og:description" content="前言提起React,可能脑海里第一印象就是Virtual Dom, 性能好, 渲染快, 之前也看过很多现成的原理分析文章, 但是别人的东西始终是建立在别人的理解之上,既然现在平时的工作已经大规模使用React及其生态，那么React 源码分析一方面可以加深对React理解，另外一方面学习其内核原理，更好的在工作业务中寻找一个最佳实践。本次源码阅读的版本是 从2017年11.28的发布的 React">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://yuml.me/a3c07b49.png">
<meta property="og:updated_time" content="2020-05-06T16:31:55.693Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="React16-Fiber 源码阅读笔记">
<meta name="twitter:description" content="前言提起React,可能脑海里第一印象就是Virtual Dom, 性能好, 渲染快, 之前也看过很多现成的原理分析文章, 但是别人的东西始终是建立在别人的理解之上,既然现在平时的工作已经大规模使用React及其生态，那么React 源码分析一方面可以加深对React理解，另外一方面学习其内核原理，更好的在工作业务中寻找一个最佳实践。本次源码阅读的版本是 从2017年11.28的发布的 React">
<meta name="twitter:image" content="https://yuml.me/a3c07b49.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://outshineamaze.github.io/2017/12/02/tech/React16-Fiber 源码阅读笔记/"/>





  <title>React16-Fiber 源码阅读笔记 | Outshine Amaze</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Outshine Amaze</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">专注技术， 热爱生活</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-主页">
          <a href="/" rel="section">
            
            主页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-simulay">
          <a href="https://outshineamaze.github.io/simulay/" rel="section">
            
            Simulay
          </a>
        </li>
      
        
        <li class="menu-item menu-item-iotshine">
          <a href="https://outshineamaze.github.io/iotshine/" rel="section">
            
            Iotshine
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://outshineamaze.github.io/2017/12/02/tech/React16-Fiber 源码阅读笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="laynezhou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatars.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Outshine Amaze">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">React16-Fiber 源码阅读笔记</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-02T00:00:00+08:00">
                2017-12-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/02/tech/React16-Fiber 源码阅读笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2017/12/02/tech/React16-Fiber 源码阅读笔记/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>提起React,可能脑海里第一印象就是Virtual Dom, 性能好, 渲染快, 之前也看过很多现成的原理分析文章, 但是别人的东西始终是建立在别人的理解之上,<br>既然现在平时的工作已经大规模使用React及其生态，那么React 源码分析一方面可以加深对React理解，另外一方面学习其内核原理，更好的在工作业务中寻找一个最佳实践。<br>本次源码阅读的版本是 从2017年11.28的发布的 React 16.2版本<br><a id="more"></a></p>
<h1 id="React16-的新特性"><a href="#React16-的新特性" class="headerlink" title="React16 的新特性"></a>React16 的新特性</h1><p>下面先了解一下React16的新特性</p>
<p><a href="查看React16的changelog">https://reactjs.org/blog/2017/09/08/dom-attributes-in-react-16.html#changes-in-detail</a></p>
<h2 id="支持在html元素中传入-自定义属性"><a href="#支持在html元素中传入-自定义属性" class="headerlink" title="支持在html元素中传入 自定义属性"></a>支持在html元素中传入 自定义属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div tabIndex=&quot;-1&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h2 id="允许在render函数中返回节点数组-字符串"><a href="#允许在render函数中返回节点数组-字符串" class="headerlink" title="允许在render函数中返回节点数组,字符串"></a>允许在render函数中返回节点数组,字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//  React 16.0 允许在render函数中返回节点数组</span><br><span class="line">render() &#123;</span><br><span class="line"> return [</span><br><span class="line">  &quot;Some text.&quot;, // Strings must be wrapped in quotes.</span><br><span class="line">  &lt;h2 key=&quot;heading-1&quot;&gt;A heading&lt;/h2&gt;, // Don&apos;t forget the keys :)</span><br><span class="line">  &quot;More text.&quot;,</span><br><span class="line">  &lt;h2 key=&quot;heading-2&quot;&gt;Another heading&lt;/h2&gt;,</span><br><span class="line">  &quot;Even more text.&quot;</span><br><span class="line"> ];</span><br><span class="line">&#125;</span><br><span class="line">// 支持字符串</span><br><span class="line">render() &#123;</span><br><span class="line">  return &apos;Look ma, no spans!&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="支持了-Fragment-标签"><a href="#支持了-Fragment-标签" class="headerlink" title="支持了 Fragment 标签"></a>支持了 Fragment 标签</h2><p>2017年11月28日最新发布的 React v16.2.0, 主要的更新点如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 通常我们一个节点列表需要一个 div 或者spn 标签来包裹</span><br><span class="line">render() &#123;</span><br><span class="line">  return (</span><br><span class="line">    // Extraneous div element :(</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Some text.</span><br><span class="line">      &lt;h2&gt;A heading&lt;/h2&gt;</span><br><span class="line">      More text.</span><br><span class="line">      &lt;h2&gt;Another heading&lt;/h2&gt;</span><br><span class="line">      Even more text.</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用 Fragment 特性</span><br><span class="line">render() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      Some text.</span><br><span class="line">      &lt;h2&gt;A heading&lt;/h2&gt;</span><br><span class="line">      More text.</span><br><span class="line">      &lt;h2&gt;Another heading&lt;/h2&gt;</span><br><span class="line">      Even more text.</span><br><span class="line">    &lt;/Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Fragment也能够被省略, 直接写个&lt;&gt;代替</span><br><span class="line">render() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Some text.</span><br><span class="line">      &lt;h2&gt;A heading&lt;/h2&gt;</span><br><span class="line">      More text.</span><br><span class="line">      &lt;h2&gt;Another heading&lt;/h2&gt;</span><br><span class="line">      Even more text.</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">// 还支持 传入 key值,  后期可能会 支持更多的attributes传入, 类似 event 事件绑定</span><br><span class="line">render() &#123;</span><br><span class="line">  return (</span><br><span class="line">        &lt;Fragment key=&#123;item.id&#125;&gt;</span><br><span class="line">          &lt;dt&gt;&#123;item.term&#125;&lt;/dt&gt;</span><br><span class="line">          &lt;dd&gt;&#123;item.description&#125;&lt;/dd&gt;</span><br><span class="line">        &lt;/Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Portals"><a href="#Portals" class="headerlink" title="Portals"></a>Portals</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  // 第一个参数是一个react的组件, 第二个参数是一个dom节点</span><br><span class="line">  return ReactDOM.createPortal(</span><br><span class="line">    this.props.children,</span><br><span class="line">    domNode,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要的作用就是把组件插入到现有的dom节点中,这个特性对于jq的页面迁移到 react简直是福音.<br>比如当前有一个页面某个模块是jquery写的, 现在需要把其中某个模块迁移到react,<br>使用这个特性就非常方便, 就不用特地使用 ReactDom.render()方法单独挂载组件到 dom节点上</p>
<h2 id="采用新的底层架构-Fiber"><a href="#采用新的底层架构-Fiber" class="headerlink" title="采用新的底层架构 Fiber"></a>采用新的底层架构 <a href="#React-Reconciler">Fiber</a></h2><p>可以参考一下demo对比两个架构之间的差距:</p>
<ol>
<li>老架构 stack  <a href="https://claudiopro.github.io/react-fiber-vs-stack-demo/stack.html" target="_blank" rel="noopener">https://claudiopro.github.io/react-fiber-vs-stack-demo/stack.html</a></li>
<li>新架构 fiber  <a href="https://claudiopro.github.io/react-fiber-vs-stack-demo/fiber.html" target="_blank" rel="noopener">https://claudiopro.github.io/react-fiber-vs-stack-demo/fiber.html</a></li>
</ol>
<p>更多细节可以参考官方的博客 <a href="https://reactjs.org" target="_blank" rel="noopener">https://reactjs.org</a></p>
<h1 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h1><p>React的代码好几万行, 盲目的阅读有点大海捞针的感觉, 这里先思考几个问题, 我们总源码中找答案.</p>
<ol>
<li><a href="#React-Reconciler">Fiber</a>引擎是什么, 它的原理是怎么样的</li>
<li>functionComponent的实现</li>
<li>新特性中的 render 中return array是怎么实现的</li>
<li>Fragment 实现</li>
<li>virtual dom在 react中具体是以一个什么样的方式存在</li>
</ol>
<p>现在要做的是:</p>
<ul>
<li>去github下载一份源码 <a href="react v16.2.0">https://github.com/facebook/react/releases/tag/v16.2.0</a></li>
<li>下载一个好用的编辑器, 支持快速定位到当前function的引用</li>
</ul>
<p>注意:</p>
<ul>
<li>由于后续react升级, 本文所引用的部分代码可能会过期</li>
<li>为了优化阅读体验, 会删除部分非核心代码:)</li>
</ul>
<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><p><a href="#Fiber">Fiber</a>架构的调用关系链, 方便我们快速浏览整个react-fiber引擎的执行流程<br>帮助在阅读的过程中,可以快速定位到当前阅读模块在框架中的位置</p>
<p>看到下面一大堆函数 还有一张那么大的图,感觉无从下手?<br>那就直接进入主题:   <a href="#React-Reconciler">进入主题</a></p>
<h3 id="源码快速导航"><a href="#源码快速导航" class="headerlink" title="源码快速导航"></a>源码快速导航</h3><h4 id="Component"><a href="#Component" class="headerlink" title="Component:"></a>Component:</h4><p><a href="#ReactDOM.render">ReactDOM.render</a>,<br><a href="#Component">Component</a>,<br><a href="#React.createElement">React.createElement</a></p>
<p><a href="#legacyRenderSubtreeIntoContainer">legacyRenderSubtreeIntoContainer</a></p>
<p><a href="#Component">enqueueSetState</a>,<br><a href="#Component">enqueueReplaceState</a>,<br><a href="#Component">enqueueForceUpdate</a></p>
<p><a href="#unbatchedUpdates">unbatchedUpdates</a>,<br><a href="#batchedUpdates">batchedUpdates</a></p>
<p><a href="#updateContainerAtExpirationTime">updateContainerAtExpirationTime</a></p>
<p><a href="#scheduleRootUpdate">scheduleRootUpdate</a>,<br><a href="#insertUpdateIntoFiber">insertUpdateIntoFiber</a></p>
<h4 id="performWork"><a href="#performWork" class="headerlink" title="performWork:"></a>performWork:</h4><p><a href="#performWork">performWork</a>,<br><a href="#scheduleWorkImpl">scheduleWorkImpl</a>,<br><a href="#requestWork">requestWork</a></p>
<p><a href="#findHighestPriorityRoot">findHighestPriorityRoot</a>,<br><a href="#performWorkOnRoot">performWorkOnRoot</a></p>
<p><a href="#renderRoot">renderRoot</a>,<br><a href="#completeRoot">completeRoot</a></p>
<p><a href="#insertUpdateIntoFiber">insertUpdateIntoFiber</a>,<br><a href="#scheduleWorkImpl">scheduleWorkImpl</a></p>
<h4 id="Commit"><a href="#Commit" class="headerlink" title="Commit:"></a>Commit:</h4><p><a href="#commitRoot">commitRoot</a></p>
<p><a href="#prepareForCommit">prepareForCommit</a></p>
<p><a href="#commitAllHostEffects">commitAllHostEffects</a>,<br><a href="#commitAllLifeCycles">commitAllLifeCycles</a></p>
<p><a href="#commitWork">commitWork</a>,<br><a href="#commitLifeCycles">commitLifeCycles</a></p>
<h4 id="LifeCycles"><a href="#LifeCycles" class="headerlink" title="LifeCycles:"></a>LifeCycles:</h4><p><a href="#commitLifeCycles">componentDidMount</a>,<br><a href="#commitLifeCycles">componentDidUpdate</a>,<br><a href="#updateClassInstance">shouldComponentUpdate</a><br><a href="#updateClassInstance">componentWillUpdate</a><br><a href="#updateClassInstance">componentWillReceiveProps</a></p>
<h4 id="workLoop"><a href="#workLoop" class="headerlink" title="workLoop:"></a>workLoop:</h4><p><a href="#workLoop">workLoop</a>,<br><a href="#performUnitOfWork">performUnitOfWork</a>,<br><a href="#beginWork">beginWork</a></p>
<p><a href="#updateHostRoot">updateHostRoot</a>,<br><a href="#updateClassComponent">updateClassComponent</a></p>
<p><a href="#reconcileChildren">reconcileChildren</a>,<br><a href="#reconcileChildFibers">reconcileChildFibers</a>,<br><a href="#reconcileChildrenArray">reconcileChildrenArray</a></p>
<p><a href="#updateClassInstance">updateClassInstance</a>,<br><a href="#constructClassInstance">constructClassInstance</a>,<br><a href="#updateFunctionalComponent">updateFunctionalComponent</a></p>
<p><a href="#completeWork">completeWork</a>,<br><a href="#finishClassComponent">finishClassComponent</a></p>
<p><img src="https://yuml.me/a3c07b49.png" alt="Fiber架构图"></p>
<h3 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h3><p>下面是架构图的DSL代码, 可以复制代码到 <a href="https://yuml.me/" target="_blank" rel="noopener">https://yuml.me/</a> 生成 UML 图片, 也可以直接打开该页面 <a href="https://yuml.me/a3c07b49" target="_blank" rel="noopener">https://yuml.me/a3c07b49</a> 编辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">[ReactDOM.render&#123;bg:wheat&#125;] -Recursive Call&gt; [render],</span><br><span class="line"></span><br><span class="line">[legacyRenderSubtreeIntoContainer] -&gt; [unbatchedUpdates],</span><br><span class="line"></span><br><span class="line">[unbatchedUpdates] -&gt; [updateContainer|updateContainerAtExpirationTime],</span><br><span class="line"></span><br><span class="line">[updateContainer|updateContainerAtExpirationTime]-&gt; [scheduleRootUpdate],</span><br><span class="line"></span><br><span class="line">[scheduleRootUpdate] -&gt; [insertUpdateIntoFiber],</span><br><span class="line"></span><br><span class="line">[batchedUpdates] -&gt; [performWork] ,</span><br><span class="line"></span><br><span class="line">[scheduleWorkImpl]-&gt; [requestWork],</span><br><span class="line"></span><br><span class="line">[performWork] -&gt; [findHighestPriorityRoot],</span><br><span class="line"></span><br><span class="line">[requestWork] -&gt; [performWorkOnRoot],</span><br><span class="line">[findHighestPriorityRoot] -&gt; [performWorkOnRoot],</span><br><span class="line"></span><br><span class="line">[performWorkOnRoot] -1&gt; [renderRoot],</span><br><span class="line">[performWorkOnRoot] -2&gt; [completeRoot],</span><br><span class="line"></span><br><span class="line">[completeRoot&#123;bg:wheat&#125;] -&gt; [commitRoot],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[commitRoot] -&gt; [prepareForCommit],</span><br><span class="line">[prepareForCommit] -1&gt; [commitAllHostEffects],</span><br><span class="line">[prepareForCommit] -2&gt; [commitAllLifeCycles],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[commitAllHostEffects] -While&gt; [commitWork],</span><br><span class="line">[commitWork] -&gt; [HostConfig.commitUpdate],</span><br><span class="line">[commitAllLifeCycles] -Whild&gt;[commitLifeCycles],</span><br><span class="line"></span><br><span class="line">[commitLifeCycles] -instance_null&gt; [componentDidMount&#123;bg:springgreen&#125;],</span><br><span class="line">[commitLifeCycles] -instance\!null&gt; [componentDidUpdate&#123;bg:springgreen&#125;],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[renderRoot&#123;bg:turquoise&#125;]-&gt; [workLoop],</span><br><span class="line">[workLoop] -While&gt; [performUnitOfWork],</span><br><span class="line">[performUnitOfWork] -&gt; [beginWork],</span><br><span class="line"></span><br><span class="line">[performUnitOfWork] -&gt; [completeWork&#123;bg:thistle&#125;],</span><br><span class="line"></span><br><span class="line">[completeWork&#123;bg:thistle&#125;] -&gt; [prepareUpdate|updateHostComponent],</span><br><span class="line"></span><br><span class="line">[prepareUpdate|updateHostComponent]-&gt; [markUpdate|appendAllChildren],</span><br><span class="line"></span><br><span class="line">[markUpdate|appendAllChildren] -&gt; [HostConfig.appendInitialChild],</span><br><span class="line"></span><br><span class="line">[Component&#123;bg:turquoise&#125;]-&gt; [render],</span><br><span class="line">[render] -&gt; [React.createElement],</span><br><span class="line"></span><br><span class="line">[React.createElement] -&gt; [legacyRenderSubtreeIntoContainer],</span><br><span class="line"></span><br><span class="line">[Component]-&gt; [Component.prototype.setState],</span><br><span class="line"></span><br><span class="line">[Component.prototype.setState]  -&gt; [enqueueSetState],</span><br><span class="line">[Component.prototype.setState]  -&gt; [enqueueReplaceState],</span><br><span class="line">[Component.prototype.setState]  -&gt; [enqueueForceUpdate],</span><br><span class="line">[enqueueSetState]-&gt; [insertUpdateIntoFiber],</span><br><span class="line">[enqueueReplaceState]-&gt; [insertUpdateIntoFiber],</span><br><span class="line">[enqueueForceUpdate]-&gt; [insertUpdateIntoFiber],</span><br><span class="line"></span><br><span class="line">[insertUpdateIntoFiber]-&gt;[scheduleWorkImpl],</span><br><span class="line"></span><br><span class="line">[beginWork&#123;bg:turquoise&#125;] -type_HostRoot=&gt; [updateHostRoot],</span><br><span class="line">[beginWork&#123;bg:turquoise&#125;] -type_ClassComponent=&gt; [updateClassComponent],</span><br><span class="line">[beginWork&#123;bg:turquoise&#125;] -type_other...=&gt; [FunctionalComponent|HostText|CallComponent|HostPortal|Fragment|More],</span><br><span class="line">[updateHostRoot] -&gt; [reconcileChildren],</span><br><span class="line">[reconcileChildren]-&gt; [reconcileChildFibers],</span><br><span class="line">[reconcileChildFibers] -&gt; [reconcileChildrenArray&#123;bg:yellowgreen&#125;],</span><br><span class="line"></span><br><span class="line">[updateClassComponent] -&gt; [constructClassInstance|mountClassInstance],</span><br><span class="line">[updateClassComponent] -&gt; [updateClassInstance],</span><br><span class="line"></span><br><span class="line">[constructClassInstance|mountClassInstance] -&gt; [finishClassComponent],</span><br><span class="line">[updateClassInstance] -1l&gt; [componentWillReceiveProps&#123;bg:springgreen&#125;],</span><br><span class="line">[componentWillReceiveProps&#123;bg:springgreen&#125;] -&gt;  [finishClassComponent],</span><br><span class="line">[updateClassInstance] -2&gt; [shouldComponentUpdate&#123;bg:springgreen&#125;],</span><br><span class="line">[shouldComponentUpdate&#123;bg:springgreen&#125;] -&gt; [componentWillUpdate&#123;bg:springgreen&#125;],</span><br><span class="line"></span><br><span class="line">[componentWillUpdate&#123;bg:springgreen&#125;] -&gt; [finishClassComponent],</span><br></pre></td></tr></table></figure>
<h1 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h1><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>首先来看一下react这个对象里面有啥<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// packages/react/src/React.js</span><br><span class="line">import &#123;Component, PureComponent, AsyncComponent&#125; from &apos;./ReactBaseClasses&apos;;</span><br><span class="line">import &#123;forEach, map, count, toArray, only&#125; from &apos;./ReactChildren&apos;;</span><br><span class="line">import ReactCurrentOwner from &apos;./ReactCurrentOwner&apos;;</span><br><span class="line">import &#123;</span><br><span class="line">  createElement,</span><br><span class="line">  createFactory,</span><br><span class="line">  cloneElement,</span><br><span class="line">  isValidElement,</span><br><span class="line">&#125; from &apos;./ReactElement&apos;;</span><br><span class="line"></span><br><span class="line">var React = &#123;</span><br><span class="line">  Children: &#123;</span><br><span class="line">    map,</span><br><span class="line">    forEach,</span><br><span class="line">    count,</span><br><span class="line">    toArray,</span><br><span class="line">    only,</span><br><span class="line">  &#125;,</span><br><span class="line">  Component,</span><br><span class="line">  PureComponent,</span><br><span class="line">  unstable_AsyncComponent: AsyncComponent,</span><br><span class="line"></span><br><span class="line">  Fragment: REACT_FRAGMENT_TYPE,</span><br><span class="line"></span><br><span class="line">  createElement: __DEV__ ? createElementWithValidation : createElement,</span><br><span class="line">  cloneElement: __DEV__ ? cloneElementWithValidation : cloneElement,</span><br><span class="line">  createFactory: __DEV__ ? createFactoryWithValidation : createFactory,</span><br><span class="line">  isValidElement: isValidElement,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们如果看babel编译过的react项目JSX代码,  通常我们一个下面是一个react的起点, 可以理解为 这个ReactDOM.render做的是吧react的对象和真实的浏览器dom节点关联<br>, JSX经过babel编译后，实际是调用createElement()创建实例对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(React.createElement(&lt;Component/&gt;, null), document.getElementById(&apos;portraits_root&apos;));</span><br></pre></td></tr></table></figure>
<h3 id="React-createElement-对象创建"><a href="#React-createElement-对象创建" class="headerlink" title="React.createElement 对象创建"></a>React.createElement 对象创建</h3><p>我们先来分析一下 创建组件的入口 createElement</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Create and return a new ReactElement of the given type.</span><br><span class="line"> * See https://reactjs.org/docs/react-api.html#createelement</span><br><span class="line"> */</span><br><span class="line">export function createElement(type, config, children) &#123;</span><br><span class="line">  var propName;</span><br><span class="line">  // Reserved names are extracted</span><br><span class="line">  var props = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  var key = null;</span><br><span class="line">  var ref = null;</span><br><span class="line">  var self = null;</span><br><span class="line">  var source = null;</span><br><span class="line"></span><br><span class="line">  if (config != null) &#123;</span><br><span class="line">    if (hasValidRef(config)) &#123;</span><br><span class="line">      ref = config.ref;</span><br><span class="line">    &#125;</span><br><span class="line">    if (hasValidKey(config)) &#123;</span><br><span class="line">      key = &apos;&apos; + config.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self = config.__self === undefined ? null : config.__self;</span><br><span class="line">    source = config.__source === undefined ? null : config.__source;</span><br><span class="line">    // Remaining properties are added to a new props object</span><br><span class="line">    for (propName in config) &#123;</span><br><span class="line">      if (</span><br><span class="line">        hasOwnProperty.call(config, propName) &amp;&amp;</span><br><span class="line">        !RESERVED_PROPS.hasOwnProperty(propName)</span><br><span class="line">      ) &#123;</span><br><span class="line">        props[propName] = config[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Children can be more than one argument, and those are transferred onto</span><br><span class="line">  // the newly allocated props object.</span><br><span class="line">  var childrenLength = arguments.length - 2;</span><br><span class="line">  if (childrenLength === 1) &#123;</span><br><span class="line">    props.children = children;</span><br><span class="line">  &#125; else if (childrenLength &gt; 1) &#123;</span><br><span class="line">    var childArray = Array(childrenLength);</span><br><span class="line">    for (var i = 0; i &lt; childrenLength; i++) &#123;</span><br><span class="line">      childArray[i] = arguments[i + 2];</span><br><span class="line">    &#125;</span><br><span class="line">    props.children = childArray;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Resolve default props</span><br><span class="line">  if (type &amp;&amp; type.defaultProps) &#123;</span><br><span class="line">    var defaultProps = type.defaultProps;</span><br><span class="line">    for (propName in defaultProps) &#123;</span><br><span class="line">      if (props[propName] === undefined) &#123;</span><br><span class="line">        props[propName] = defaultProps[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return ReactElement(</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    ref,</span><br><span class="line">    self,</span><br><span class="line">    source,</span><br><span class="line">    ReactCurrentOwner.current,</span><br><span class="line">    props,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var ReactElement = function(type, key, ref, self, source, owner, props) &#123;</span><br><span class="line">  var element = &#123;</span><br><span class="line">    // This tag allow us to uniquely identify this as a React Element</span><br><span class="line">    $$typeof: REACT_ELEMENT_TYPE,</span><br><span class="line"></span><br><span class="line">    // Built-in properties that belong on the element</span><br><span class="line">    type: type,</span><br><span class="line">    key: key,</span><br><span class="line">    ref: ref,</span><br><span class="line">    props: props,</span><br><span class="line"></span><br><span class="line">    // Record the component responsible for creating this element.</span><br><span class="line">    _owner: owner,</span><br><span class="line">  &#125;;</span><br><span class="line">  return element;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的源码主要做三个工作 , </p>
<ol>
<li>把参数config 的挂到props变量里面</li>
<li>把 children传入到 props.children属性下</li>
<li>取出组件类中的静态变量defaultProps，并给未在JSX中设置值的属性设置默认值</li>
<li>返回一个 ReactElement</li>
<li>再看看 ReactElement的代码, 其实就是把把参数包装一下再加个 $$typeof标识返回</li>
<li>截止到这里, 可以看到createElement仅仅是返回一个 element对象</li>
</ol>
<h3 id="React-Children"><a href="#React-Children" class="headerlink" title="React.Children"></a>React.Children</h3><p>React.Children提供了对this.props.children的操作的函数。<br>react/src/ReactChildren文件export的函数如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export &#123;</span><br><span class="line">  forEachChildren as forEach,</span><br><span class="line">  mapChildren as map,</span><br><span class="line">  countChildren as count,</span><br><span class="line">  onlyChild as only,</span><br><span class="line">  toArray,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="Component-1"><a href="#Component-1" class="headerlink" title="Component"></a>Component</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">function Component(props, context, updater) &#123;</span><br><span class="line">  this.props = props;</span><br><span class="line">  this.context = context;</span><br><span class="line">  this.refs = emptyObject;</span><br><span class="line">  // We initialize the default updater but the real one gets injected by the</span><br><span class="line">  // renderer.</span><br><span class="line">  this.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Component.prototype.isReactComponent = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Component.prototype.setState = function(partialState, callback) &#123;</span><br><span class="line">  invariant(</span><br><span class="line">    typeof partialState === &apos;object&apos; ||</span><br><span class="line">      typeof partialState === &apos;function&apos; ||</span><br><span class="line">      partialState == null,</span><br><span class="line">    &apos;setState(...): takes an object of state variables to update or a &apos; +</span><br><span class="line">      &apos;function which returns an object of state variables.&apos;,</span><br><span class="line">  );</span><br><span class="line">  this.updater.enqueueSetState(this, partialState, callback, &apos;setState&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Component.prototype.forceUpdate = function(callback) &#123;</span><br><span class="line">  this.updater.enqueueForceUpdate(this, callback, &apos;forceUpdate&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Base class helpers for the updating state of a component.</span><br><span class="line"> */</span><br><span class="line">function PureComponent(props, context, updater) &#123;</span><br><span class="line">  // Duplicated from Component.</span><br><span class="line">  this.props = props;</span><br><span class="line">  this.context = context;</span><br><span class="line">  this.refs = emptyObject;</span><br><span class="line">  // We initialize the default updater but the real one gets injected by the</span><br><span class="line">  // renderer.</span><br><span class="line">  this.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ComponentDummy() &#123;&#125;</span><br><span class="line">ComponentDummy.prototype = Component.prototype;</span><br><span class="line">var pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());</span><br><span class="line">pureComponentPrototype.constructor = PureComponent;</span><br><span class="line">// Avoid an extra prototype jump for these methods.</span><br><span class="line">Object.assign(pureComponentPrototype, Component.prototype);</span><br><span class="line">pureComponentPrototype.isPureReactComponent = true;</span><br><span class="line"></span><br><span class="line">function AsyncComponent(props, context, updater) &#123;</span><br><span class="line">  // Duplicated from Component.</span><br><span class="line">  this.props = props;</span><br><span class="line">  this.context = context;</span><br><span class="line">  this.refs = emptyObject;</span><br><span class="line">  // We initialize the default updater but the real one gets injected by the</span><br><span class="line">  // renderer.</span><br><span class="line">  this.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var asyncComponentPrototype = (AsyncComponent.prototype = new ComponentDummy());</span><br><span class="line">asyncComponentPrototype.constructor = AsyncComponent;</span><br><span class="line">// Avoid an extra prototype jump for these methods.</span><br><span class="line">Object.assign(asyncComponentPrototype, Component.prototype);</span><br><span class="line">asyncComponentPrototype.unstable_isAsyncReactComponent = true;</span><br><span class="line">asyncComponentPrototype.render = function() &#123;</span><br><span class="line">  return this.props.children;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export &#123;Component, PureComponent, AsyncComponent&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码是输出三个类Component, PureComponent, AsyncComponent</p>
<ol>
<li>setState 实际上就是调用<br>this.updater.enqueueSetState(this, partialState, callback, ‘setState’);</li>
<li>forceUpdate实际上是调用<br>this.updater.enqueueForceUpdate(this, callback, ‘forceUpdate’);<br>这一块后面分析Fiber架构会详细深入了解 this.updater.enqueueSetState 和 this.updater.enqueueForceUpdate</li>
<li>PureComponent 和 asyncComponentPrototype 其实就是在Component的基础上分别设置<br>isPureReactComponent 和 unstable_isAsyncReactComponent  为true的熟悉, 这个标准在底层的架构中会判断这写标记做特殊判断, 比如 isPureReactComponent= true之后，组件在shoudComponentUpdate中会浅比较渲染前后的props和state，如果没有变化，组件不会进入接下来的生命周期，可以节省不必要的diff操作。</li>
</ol>
<p>到此我们已经把React的对象分析的差不多了, 但是是不是有还是觉得不知道React是如何运行的? 下面进入React16新一代的架构Fiber 来进行探索</p>
<h2 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h2><p>分析前面的 React代码, 发现主要就是构造element对象, 那现在如何让整个react 引擎跑起来?<br>还记得前面的 ReactDOM.render(React.createElement(<component>, null), document.getElementById(‘portraits_root’));</component></p>
<h4 id="ReactDOM-render"><a href="#ReactDOM-render" class="headerlink" title="ReactDOM.render"></a>ReactDOM.render</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">// react/packages/react-dom/src/client/ReactDOM.js</span><br><span class="line">// 先找到 render方法, 发现其实是调用 legacyRenderSubtreeIntoContainer</span><br><span class="line">render(</span><br><span class="line">    element: React$Element&lt;any&gt;,</span><br><span class="line">    container: DOMContainer,</span><br><span class="line">    callback: ?Function,</span><br><span class="line">  ) &#123;</span><br><span class="line">    return legacyRenderSubtreeIntoContainer(</span><br><span class="line">      null,</span><br><span class="line">      element,</span><br><span class="line">      container,</span><br><span class="line">      false,</span><br><span class="line">      callback,</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">//  这个方法的工作就是 是把子组件树挂在到 dom 容器中</span><br><span class="line">function legacyRenderSubtreeIntoContainer(</span><br><span class="line">  parentComponent: ?React$Component&lt;any, any&gt;,</span><br><span class="line">  children: ReactNodeList,</span><br><span class="line">  container: DOMContainer,</span><br><span class="line">  forceHydrate: boolean,</span><br><span class="line">  callback: ?Function,</span><br><span class="line">) &#123;</span><br><span class="line">  // 如果没有root容器就创建一个</span><br><span class="line">  if (!root) &#123;</span><br><span class="line">    // Initial mount</span><br><span class="line">    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(</span><br><span class="line">      container,</span><br><span class="line">      forceHydrate,</span><br><span class="line">    );</span><br><span class="line">    if (typeof callback === &apos;function&apos;) &#123;</span><br><span class="line">      const originalCallback = callback;</span><br><span class="line">      callback = function() &#123;</span><br><span class="line">        const instance = DOMRenderer.getPublicRootInstance(root._internalRoot);</span><br><span class="line">        originalCallback.call(instance);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    // Initial mount should not be batched.</span><br><span class="line">    // 初始化挂载组件 不需要 bathced 的去update</span><br><span class="line">    DOMRenderer.unbatchedUpdates(() =&gt; &#123;</span><br><span class="line">      // 如果有父组件, 就去挂载这个父组件, 如果没有父组件, 就直接调用DOMRenderer的render方法 渲染组件</span><br><span class="line">      if (parentComponent != null) &#123;</span><br><span class="line">        root.legacy_renderSubtreeIntoContainer(</span><br><span class="line">          parentComponent,</span><br><span class="line">          children,</span><br><span class="line">          callback,</span><br><span class="line">        );</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        root.render(children, callback);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (typeof callback === &apos;function&apos;) &#123;</span><br><span class="line">      const originalCallback = callback;</span><br><span class="line">      callback = function() &#123;</span><br><span class="line">        const instance = DOMRenderer.getPublicRootInstance(root._internalRoot);</span><br><span class="line">        originalCallback.call(instance);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    // Update</span><br><span class="line">    if (parentComponent != null) &#123;</span><br><span class="line">      root.legacy_renderSubtreeIntoContainer(</span><br><span class="line">        parentComponent,</span><br><span class="line">        children,</span><br><span class="line">        callback,</span><br><span class="line">      );</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      root.render(children, callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return DOMRenderer.getPublicRootInstance(root._internalRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的render中 ,多次使用到 DOMRenderer 这个对象 ,<br>下面的我精简了很多function的细节, 只保留了名称, 从这些名称中可以看出来, 下面这些是 浏览器dom操作与react 核心的引擎的桥梁<br>同样的,DOM、Canvas、Native、VR、WebGL等等平台都有自己的renderer, 也就是说 fiber引擎可以对接不同平台的渲染接口</p>
<h4 id="DOMRenderer"><a href="#DOMRenderer" class="headerlink" title="DOMRenderer"></a>DOMRenderer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">const DOMRenderer = ReactFiberReconciler(&#123;</span><br><span class="line">  getRootHostContext</span><br><span class="line">  getChildHostContext</span><br><span class="line">  getPublicInstance</span><br><span class="line">  prepareForCommit</span><br><span class="line">  resetAfterCommit</span><br><span class="line">  createInstance</span><br><span class="line">  appendInitialChild</span><br><span class="line">  finalizeInitialChildren</span><br><span class="line">  prepareUpdate</span><br><span class="line">  shouldSetTextContent</span><br><span class="line">  shouldDeprioritizeSubtree</span><br><span class="line">  createTextInstance</span><br><span class="line">  now: ReactDOMFrameScheduling.now,</span><br><span class="line">  mutation</span><br><span class="line">    commitUpdate</span><br><span class="line">    commitTextUpdate</span><br><span class="line">    appendChild</span><br><span class="line">    appendChildToContainer</span><br><span class="line">    insertBefore</span><br><span class="line">    insertInContainerBefore</span><br><span class="line">    removeChild</span><br><span class="line">    hydration</span><br><span class="line">    canHydrateTextInstance</span><br><span class="line">    getNextHydratableSibling</span><br><span class="line">    getFirstHydratableChild</span><br><span class="line">    hydrateInstance</span><br><span class="line">    hydrateTextInstance</span><br><span class="line">    didNotMatchHydratedContainerTextInstance</span><br><span class="line">    didNotMatchHydratedTextInstance</span><br><span class="line">    didNotHydrateContainerInstance</span><br><span class="line">    didNotHydrateInstance</span><br><span class="line">    didNotFindHydratableContainerInstance</span><br><span class="line">    didNotFindHydratableContainerTextInstance</span><br><span class="line">    didNotFindHydratableInstance</span><br><span class="line">    didNotFindHydratableTextInstance</span><br><span class="line">  scheduleDeferredCallback: ReactDOMFrameScheduling.rIC,</span><br><span class="line">  cancelDeferredCallback: ReactDOMFrameScheduling.cIC,</span><br><span class="line">  useSyncScheduling: !enableAsyncSchedulingByDefaultInReactDOM,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>从上面看到其实DOMRenderer 对象是由ReactFiberReconciler返回的, 下面就真的进入到fiber的代码了</p>
<h3 id="React-Reconciler"><a href="#React-Reconciler" class="headerlink" title="React-Reconciler"></a>React-Reconciler</h3><p>生看代码很苦涩, 还得结合理论描述来看</p>
<h4 id="基础的概念"><a href="#基础的概念" class="headerlink" title="基础的概念:"></a>基础的概念:</h4><ol>
<li><a href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html" target="_blank" rel="noopener">React Components, Elements, and Instances</a></li>
<li><a href="https://reactjs.org/docs/reconciliation.html" target="_blank" rel="noopener">协调算法（Diff算法）</a></li>
<li><a href="https://github.com/reactjs/react-basic" target="_blank" rel="noopener">React基本理论概念</a></li>
<li><a href="https://facebook.github.io/react/contributing/design-principles.html" target="_blank" rel="noopener">React设计原则</a></li>
</ol>
<h4 id="协调算法-reconciliation"><a href="#协调算法-reconciliation" class="headerlink" title="协调算法(reconciliation)"></a>协调算法(reconciliation)</h4><p>协调: React用以比较两棵树的算法，其决定哪些部分需要更改。<br>更新(update): 即渲染React app的数据发生的一个改变。通常是setState的结果。最终会导致重新渲染。</p>
<h4 id="调度-scheduling"><a href="#调度-scheduling" class="headerlink" title="调度(scheduling)"></a>调度(scheduling)</h4><p>调度(scheduling): 决定事务什么时候执行的过程。<br>事务(work): 必须执行的计算。事务一般是由update引起的（比如setState）。</p>
<p>Fiber的主要目标是使React能够充分利用调度, 具体的需要实现:</p>
<ul>
<li>暂停事务，在一段时间后再接着执行。</li>
<li>分配不同类型事务的优先级。</li>
<li>复用之前已完成的事务。</li>
<li>当事务不再需要时，终止该事务。</li>
</ul>
<p>Fiber为了实现这些功能, 需要保存堆栈结构在内存里，然后在适当的时机去执行它。这点对于实现我们要的调度功能非常重要。<br>重要特性是增量渲染：将渲染事务分块并分布到多个帧去完成的能力,<br>关键特性包括有新的更新时,暂停、终止或重用事务的功能,为不同类型的更新设置优先级的功能.</p>
<p>以上几点概念理论引用自: <a href="https://swenyang.gitbooks.io/translation/content/react/fiber.html" target="_blank" rel="noopener">React Fiber架构</a></p>
<p>下面可以详细看看 Fiber 引擎的代码,主要是指 React-Reconciler下面的代码, Reconciler(协调器) 就是所谓的 Virtul DOM</p>
<p>React组件更新渲染分为两个阶段:</p>
<ol>
<li>reconciliation 和 commit, Reconciler主要用于生成需要更新dom操作的列表,这个过程是 一个纯函数的过程, effectList = f(newProps, newState), 这个过程不会受到状态的变化而影响.</li>
<li>生成 effect list之后,  commit effect list才会把变化应用到dom中, 这里需要调用render提供的dom操作接口方法, React-Dom React-Native 等都有提供接口给我Fiber</li>
</ol>
<h4 id="ReactFiberReconciler"><a href="#ReactFiberReconciler" class="headerlink" title="ReactFiberReconciler"></a>ReactFiberReconciler</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// react/packages/react-reconciler/src/ReactFiberReconciler.js</span><br><span class="line">// ReactFiberReconciler对象</span><br><span class="line"></span><br><span class="line">export default function&lt;T, P, I, TI, HI, PI, C, CC, CX, PL&gt;(</span><br><span class="line">  config: HostConfig&lt;T, P, I, TI, HI, PI, C, CC, CX, PL&gt;,</span><br><span class="line">): Reconciler&lt;C, I, TI&gt; &#123;</span><br><span class="line">  var &#123;getPublicInstance&#125; = config;</span><br><span class="line"></span><br><span class="line">  var &#123;</span><br><span class="line">    computeAsyncExpiration,</span><br><span class="line">    computeUniqueAsyncExpiration,</span><br><span class="line">    computeExpirationForFiber,</span><br><span class="line">    scheduleWork,</span><br><span class="line">    requestWork,</span><br><span class="line">    flushRoot,</span><br><span class="line">    batchedUpdates,</span><br><span class="line">    unbatchedUpdates,</span><br><span class="line">    flushSync,</span><br><span class="line">    deferredUpdates,</span><br><span class="line">  &#125; = ReactFiberScheduler(config);</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    createContainer</span><br><span class="line"></span><br><span class="line">    updateContainer</span><br><span class="line"></span><br><span class="line">    updateContainerAtExpirationTime,</span><br><span class="line"></span><br><span class="line">    flushRoot,</span><br><span class="line"></span><br><span class="line">    requestWork,</span><br><span class="line"></span><br><span class="line">    computeUniqueAsyncExpiration,</span><br><span class="line"></span><br><span class="line">    batchedUpdates,</span><br><span class="line"></span><br><span class="line">    unbatchedUpdates,</span><br><span class="line"></span><br><span class="line">    deferredUpdates,</span><br><span class="line"></span><br><span class="line">    flushSync,</span><br><span class="line"></span><br><span class="line">    getPublicRootInstance</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReactFiberReconciler 对外抛出的方法,<br>可以看到主要的几个方法都是ReactFiberScheduler返回的, 进一步证明了fiber架构在任务的调度上做了很大的改变<br>这些api主要是给 React-dom等 rendener的使用的</p>
<h4 id="updateContainerAtExpirationTime"><a href="#updateContainerAtExpirationTime" class="headerlink" title="updateContainerAtExpirationTime"></a>updateContainerAtExpirationTime</h4><p>这个方法主要就是调用 scheduleRootUpdate</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function updateContainerAtExpirationTime(</span><br><span class="line">  element: ReactNodeList,</span><br><span class="line">  container: OpaqueRoot,</span><br><span class="line">  parentComponent: ?React$Component&lt;any, any&gt;,</span><br><span class="line">  expirationTime: ExpirationTime,</span><br><span class="line">  callback: ?Function,</span><br><span class="line">) &#123;</span><br><span class="line">  // TODO: If this is a nested container, this won&apos;t be the root.</span><br><span class="line">  const current = container.current;</span><br><span class="line"></span><br><span class="line">  const context = getContextForSubtree(parentComponent);</span><br><span class="line">  if (container.context === null) &#123;</span><br><span class="line">    container.context = context;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    container.pendingContext = context;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return scheduleRootUpdate(current, element, expirationTime, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="scheduleRootUpdate"><a href="#scheduleRootUpdate" class="headerlink" title="scheduleRootUpdate"></a>scheduleRootUpdate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function scheduleRootUpdate(</span><br><span class="line">    current: Fiber,</span><br><span class="line">    element: ReactNodeList,</span><br><span class="line">    expirationTime: ExpirationTime,</span><br><span class="line">    callback: ?Function,</span><br><span class="line">  ) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    callback = callback === undefined ? null : callback;</span><br><span class="line"></span><br><span class="line">    const update = &#123;</span><br><span class="line">      expirationTime,</span><br><span class="line">      partialState: &#123;element&#125;,</span><br><span class="line">      callback,</span><br><span class="line">      isReplace: false,</span><br><span class="line">      isForced: false,</span><br><span class="line">      next: null,</span><br><span class="line">    &#125;;</span><br><span class="line">    insertUpdateIntoFiber(current, update);</span><br><span class="line">    scheduleWork(current, expirationTime);</span><br><span class="line"></span><br><span class="line">    return expirationTime;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法有顾名思义是开始调度根节点的update操作<br>主要分为三个操作:</p>
<ol>
<li>生成一个update对象</li>
<li>把这个update 插入到 Fiber中</li>
<li>开始调度工作</li>
</ol>
<p>看到这里开始接触到 Fiber对象了, 下面来了解一下 Fiber对象到底为何物</p>
<h4 id="typeFiber"><a href="#typeFiber" class="headerlink" title="typeFiber"></a>typeFiber</h4><p>下面可以看看一个fiber的对象是怎么样了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">function FiberNode(</span><br><span class="line">  tag: TypeOfWork,</span><br><span class="line">  pendingProps: mixed,</span><br><span class="line">  key: null | string,</span><br><span class="line">  internalContextTag: TypeOfInternalContext,</span><br><span class="line">) &#123;</span><br><span class="line">  // Instance</span><br><span class="line">  this.tag = tag; // fiber的类型</span><br><span class="line">  this.key = key; // key是在协调算法中用来决定fiber是否可以重用的字段</span><br><span class="line">  this.type = null; // type描述了它对应的组件。对于复合组件，type就是复合函数或组件的class。对于宿主组件（div, span等），type是一个字符串。</span><br><span class="line">  this.stateNode = null;</span><br><span class="line"></span><br><span class="line">  // Fiber</span><br><span class="line">  this.return = null; // 指向fiber树中的父Fiber</span><br><span class="line">  this.child = null; // 子fiber(child fiber)指的是组件的render方法返回来的值。</span><br><span class="line">  this.sibling = null; // 兄弟fiber(sibling fiber)指代的是render方法返回多个子节点的情况（Fiber中的新特性！）, 兄弟fiber形成一个单链表</span><br><span class="line">  this.index = 0;</span><br><span class="line"></span><br><span class="line">  this.ref = null;</span><br><span class="line"></span><br><span class="line">  //  一个fiber的pendingProps会在它开始执行处设置，memoizedProps则会在执行结尾处设置。</span><br><span class="line">  //  当到来的pendingProps和上一个memoizedProps相等时，它意味着fiber的上一次输出可以重用，避免不必要的事务。</span><br><span class="line">  this.pendingProps = pendingProps;</span><br><span class="line">  this.memoizedProps = null;</span><br><span class="line">  this.updateQueue = null;  // 待更新update队列</span><br><span class="line">  this.memoizedState = null;</span><br><span class="line"></span><br><span class="line">  this.internalContextTag = internalContextTag;</span><br><span class="line"></span><br><span class="line">  // Effects</span><br><span class="line">  this.effectTag = NoEffect;  // side effect类型</span><br><span class="line">  this.nextEffect = null; // 单链表结构，方便遍历fiber树上有副作用的节点</span><br><span class="line">  this.firstEffect = null;</span><br><span class="line">  this.lastEffect = null;</span><br><span class="line"></span><br><span class="line">  this.expirationTime = NoWork;</span><br><span class="line"></span><br><span class="line">  this.alternate = null;  // 在fiber更新时克隆出的镜像fiber，对fiber的修改会标记在这个fiber上, 这个就是 源码中经常出现的working-in-progres</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="insertUpdateIntoFiber"><a href="#insertUpdateIntoFiber" class="headerlink" title="insertUpdateIntoFiber"></a>insertUpdateIntoFiber</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">export function insertUpdateIntoFiber&lt;State&gt;(</span><br><span class="line">  fiber: Fiber,</span><br><span class="line">  update: Update&lt;State&gt;,</span><br><span class="line">): void &#123;</span><br><span class="line">  // We&apos;ll have at least one and at most two distinct update queues.</span><br><span class="line">  const alternateFiber = fiber.alternate;</span><br><span class="line">  let queue1 = fiber.updateQueue;</span><br><span class="line">  if (queue1 === null) &#123;</span><br><span class="line"></span><br><span class="line">    queue1 = fiber.updateQueue = createUpdateQueue((null: any));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let queue2;</span><br><span class="line">  if (alternateFiber !== null) &#123;</span><br><span class="line">    queue2 = alternateFiber.updateQueue;</span><br><span class="line">    if (queue2 === null) &#123;</span><br><span class="line">      queue2 = alternateFiber.updateQueue = createUpdateQueue((null: any));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    queue2 = null;</span><br><span class="line">  &#125;</span><br><span class="line">  queue2 = queue2 !== queue1 ? queue2 : null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // If there&apos;s only one queue, add the update to that queue and exit.</span><br><span class="line">  if (queue2 === null) &#123;</span><br><span class="line">    insertUpdateIntoQueue(queue1, update);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // If either queue is empty, we need to add to both queues.</span><br><span class="line">  if (queue1.last === null || queue2.last === null) &#123;</span><br><span class="line">    insertUpdateIntoQueue(queue1, update);</span><br><span class="line">    insertUpdateIntoQueue(queue2, update);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // If both lists are not empty, the last update is the same for both lists</span><br><span class="line">  // because of structural sharing. So, we should only append to one of</span><br><span class="line">  // the lists.</span><br><span class="line">  insertUpdateIntoQueue(queue1, update);</span><br><span class="line">  // But we still need to update the `last` pointer of queue2.</span><br><span class="line">  queue2.last = update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fiber.updateQueue是一个单向链表，有first和last指针指向链表的头部和尾部。</p>
<p>一个React element会有一个current fiber和一个alternate fiber。alternate fiber又叫working in progress fiber。<br>这两个fiber都有一个Update Queue。<br>这两个Queue里面的item的引用是相同的. 区别在于，working in progress fiber会在更新完一个队列项之后将其从队列中移除。<br>所以working in progress update queue永远是current queue的一个子集。<br>在更新完成之后，working in progress fiber取代current fiber成为新的current fiber。如果更新中断（有更高优先级的更新插入），<br>current fiber的update queue就可以作为备份，使得之前中断的更新可以重新开始。</p>
<p>总之, insertUpdateIntoFiber，这个函数处理了将一个update插入到fiber.updateQueue和fiber.alternateFiber.updateQueue两个队列中操作</p>
<h4 id="scheduleWorkImpl"><a href="#scheduleWorkImpl" class="headerlink" title="scheduleWorkImpl"></a>scheduleWorkImpl</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">function scheduleWorkImpl(</span><br><span class="line">  fiber: Fiber,</span><br><span class="line">  expirationTime: ExpirationTime,</span><br><span class="line">  isErrorRecovery: boolean,</span><br><span class="line">) &#123;</span><br><span class="line">  recordScheduleUpdate();</span><br><span class="line"></span><br><span class="line">  let node = fiber;</span><br><span class="line">  while (node !== null) &#123;</span><br><span class="line">    // Walk the parent path to the root and update each node&apos;s</span><br><span class="line">    // expiration time.</span><br><span class="line">    // 遍历父节点,一直到root节点, 更新每个节点的 expiration time 截止时间(优先级)</span><br><span class="line">    if (</span><br><span class="line">      node.expirationTime === NoWork ||</span><br><span class="line">      node.expirationTime &gt; expirationTime</span><br><span class="line">    ) &#123;</span><br><span class="line">      node.expirationTime = expirationTime;</span><br><span class="line">    &#125;</span><br><span class="line">    if (node.alternate !== null) &#123;</span><br><span class="line">      if (</span><br><span class="line">        node.alternate.expirationTime === NoWork ||</span><br><span class="line">        node.alternate.expirationTime &gt; expirationTime</span><br><span class="line">      ) &#123;</span><br><span class="line">        node.alternate.expirationTime = expirationTime;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (node.return === null) &#123;</span><br><span class="line">      if (node.tag === HostRoot) &#123;</span><br><span class="line">        const root: FiberRoot = (node.stateNode: any);</span><br><span class="line"></span><br><span class="line">        checkRootNeedsClearing(root, fiber, expirationTime);</span><br><span class="line"></span><br><span class="line">        // 当root收到update时, 调用requestWork, 请求更新</span><br><span class="line">        requestWork(root, expirationTime);</span><br><span class="line"></span><br><span class="line">        checkRootNeedsClearing(root, fiber, expirationTime);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node = node.return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="requestWork"><a href="#requestWork" class="headerlink" title="requestWork"></a>requestWork</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">function requestWork(root: FiberRoot, expirationTime: ExpirationTime) &#123;</span><br><span class="line"></span><br><span class="line">  // Add the root to the schedule.</span><br><span class="line">  // Check if this root is already part of the schedule.</span><br><span class="line">  if (root.nextScheduledRoot === null) &#123;</span><br><span class="line">    // This root is not already scheduled. Add it.</span><br><span class="line">    root.remainingExpirationTime = expirationTime;</span><br><span class="line">    if (lastScheduledRoot === null) &#123;</span><br><span class="line">      firstScheduledRoot = lastScheduledRoot = root;</span><br><span class="line">      root.nextScheduledRoot = root;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      lastScheduledRoot.nextScheduledRoot = root;</span><br><span class="line">      lastScheduledRoot = root;</span><br><span class="line">      lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // This root is already scheduled, but its priority may have increased.</span><br><span class="line">    const remainingExpirationTime = root.remainingExpirationTime;</span><br><span class="line">    if (</span><br><span class="line">      remainingExpirationTime === NoWork ||</span><br><span class="line">      expirationTime &lt; remainingExpirationTime</span><br><span class="line">    ) &#123;</span><br><span class="line">      // Update the priority.</span><br><span class="line">      root.remainingExpirationTime = expirationTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (isRendering) &#123;</span><br><span class="line">    // Prevent reentrancy. Remaining work will be scheduled at the end of</span><br><span class="line">    // the currently rendering batch.</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (isBatchingUpdates) &#123;</span><br><span class="line">    // Flush work at the end of the batch.</span><br><span class="line">    if (isUnbatchingUpdates) &#123;</span><br><span class="line">      // ...unless we&apos;re inside unbatchedUpdates, in which case we should</span><br><span class="line">      // flush it now.</span><br><span class="line">      nextFlushedRoot = root;</span><br><span class="line">      nextFlushedExpirationTime = Sync;</span><br><span class="line">      performWorkOnRoot(root, Sync, recalculateCurrentTime());</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (expirationTime === Sync) &#123;</span><br><span class="line">    performWork(Sync, null);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    scheduleCallbackWithExpiration(expirationTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>requestWork主要做3件事:</p>
<ol>
<li>把 root 节点添加到已调度的队列中去</li>
<li>如果已经在调度的队列中, 则设置 expirationTime (这里的截止时间就是任务执行的优先级)</li>
<li>调用performWorkOnRoot 或者 performWork来执行更新队列</li>
</ol>
<h4 id="performWorkOnRoot"><a href="#performWorkOnRoot" class="headerlink" title="performWorkOnRoot"></a>performWorkOnRoot</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">function performWorkOnRoot(</span><br><span class="line">  root: FiberRoot,</span><br><span class="line">  expirationTime: ExpirationTime,</span><br><span class="line">  currentTime: ExpirationTime,</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">  //  设置 isRendering 状态</span><br><span class="line">  isRendering = true;</span><br><span class="line"></span><br><span class="line">  // Check if this is async work or sync/expired work.</span><br><span class="line">  // 检测 当前是同步的还是异步的任务</span><br><span class="line">  if (expirationTime &lt;= currentTime) &#123;</span><br><span class="line">    // Flush sync work.</span><br><span class="line">    //执行同步的任务</span><br><span class="line">    let finishedWork = root.finishedWork;</span><br><span class="line">    if (finishedWork !== null) &#123;</span><br><span class="line">      // This root is already complete. We can commit it.</span><br><span class="line">      completeRoot(root, finishedWork, expirationTime);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      root.finishedWork = null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      finishedWork = renderRoot(root, expirationTime);</span><br><span class="line">      if (finishedWork !== null) &#123;</span><br><span class="line">        // We&apos;ve completed the root. Commit it.</span><br><span class="line">        completeRoot(root, finishedWork, expirationTime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // Flush async work.</span><br><span class="line">    // 执行异步的任务</span><br><span class="line">    let finishedWork = root.finishedWork;</span><br><span class="line">    if (finishedWork !== null) &#123;</span><br><span class="line">      // This root is already complete. We can commit it.</span><br><span class="line">      completeRoot(root, finishedWork, expirationTime);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      root.finishedWork = null;</span><br><span class="line"></span><br><span class="line">      // 渲染 root节点</span><br><span class="line">      finishedWork = renderRoot(root, expirationTime);</span><br><span class="line">      if (finishedWork !== null) &#123;</span><br><span class="line">        // We&apos;ve completed the root. Check the deadline one more time</span><br><span class="line">        // before committing.</span><br><span class="line">        // 结束渲染之后,生成effect list, 检测一下 当前周期是否还有多余的时间, 如果有多余时间, 先不执行 commiting</span><br><span class="line">        if (!shouldYield()) &#123;</span><br><span class="line">          // Still time left. Commit the root.</span><br><span class="line">          completeRoot(root, finishedWork, expirationTime);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          // There&apos;s no time left. Mark this root as complete. We&apos;ll come</span><br><span class="line">          // back and commit it later.</span><br><span class="line">          root.finishedWork = finishedWork;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isRendering = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>performWorkOnRoot 主要区分 同步渲染和异步渲染, 调用 renderRoot , completeRoot来执行任务<br>异步渲染会先判断一下 shouldYield()为false才 执行completeRoot, 也就是说异步渲染会先计算effect list, 但是不 commit effect,<br>然后根据当前周期剩余的时间来决定是否执行commiting操作</p>
<h4 id="renderRoot"><a href="#renderRoot" class="headerlink" title="renderRoot"></a>renderRoot</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function renderRoot(</span><br><span class="line">    root: FiberRoot,</span><br><span class="line">    expirationTime: ExpirationTime,</span><br><span class="line">  ): Fiber | null &#123;</span><br><span class="line">    isWorking = true;</span><br><span class="line"></span><br><span class="line">    // We&apos;re about to mutate the work-in-progress tree. If the root was pending</span><br><span class="line">    // commit, it no longer is: we&apos;ll need to complete it again.</span><br><span class="line">    root.isReadyForCommit = false;</span><br><span class="line"></span><br><span class="line">    // Check if we&apos;re starting from a fresh stack, or if we&apos;re resuming from</span><br><span class="line">    // previously yielded work.</span><br><span class="line">    if (</span><br><span class="line">      root !== nextRoot ||</span><br><span class="line">      expirationTime !== nextRenderExpirationTime ||</span><br><span class="line">      nextUnitOfWork === null</span><br><span class="line">    ) &#123;</span><br><span class="line">      // Reset the stack and start working from the root.</span><br><span class="line">      resetContextStack();</span><br><span class="line">      nextRoot = root;</span><br><span class="line">      nextRenderExpirationTime = expirationTime;</span><br><span class="line">      nextUnitOfWork = createWorkInProgress(</span><br><span class="line">        nextRoot.current,</span><br><span class="line">        null,</span><br><span class="line">        expirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">        workLoop(expirationTime);</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        didError = true;</span><br><span class="line">        error = e;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>执行的步骤:</p>
<ol>
<li>检测是否有上一次未完成的任务, 如果有, 就回复上个堆栈继续执行</li>
<li>执行 workLoop</li>
</ol>
<h4 id="workLoop-1"><a href="#workLoop-1" class="headerlink" title="workLoop"></a>workLoop</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function workLoop(expirationTime: ExpirationTime) &#123;</span><br><span class="line">  if (</span><br><span class="line">    nextRenderExpirationTime === NoWork ||</span><br><span class="line">    nextRenderExpirationTime &gt; expirationTime</span><br><span class="line">  ) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (nextRenderExpirationTime &lt;= mostRecentCurrentTime) &#123;</span><br><span class="line">    // Flush all expired work.</span><br><span class="line">    // 执行所有过期的工作</span><br><span class="line">    while (nextUnitOfWork !== null) &#123;</span><br><span class="line">      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // Flush asynchronous work until the deadline runs out of time.</span><br><span class="line">    // 当前帧还有剩余的时间, 执行异步操作直到截止的时间</span><br><span class="line">    while (nextUnitOfWork !== null &amp;&amp; !shouldYield()) &#123;</span><br><span class="line">      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="performUnitOfWork"><a href="#performUnitOfWork" class="headerlink" title="performUnitOfWork"></a>performUnitOfWork</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function performUnitOfWork(workInProgress: Fiber): Fiber | null &#123;</span><br><span class="line">  // The current, flushed, state of this fiber is the alternate.</span><br><span class="line">  // Ideally nothing should rely on this, but relying on it here</span><br><span class="line">  // means that we don&apos;t need an additional field on the work in</span><br><span class="line">  // progress.</span><br><span class="line">  const current = workInProgress.alternate;</span><br><span class="line"></span><br><span class="line">  let next = beginWork(current, workInProgress, nextRenderExpirationTime);</span><br><span class="line"></span><br><span class="line">  if (next === null) &#123;</span><br><span class="line">    // If this doesn&apos;t spawn new work, complete the current work.</span><br><span class="line">    next = completeUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ReactCurrentOwner.current = null;</span><br><span class="line"></span><br><span class="line">  return next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>beginWork, 异步情况会返回一个workLoop里面whild循环中的 nextUnitOfWork,</li>
<li>如果返回null, 就 completeUnitOfWork ()</li>
</ol>
<p>一般情况一个react中的事务分为 begin 和 complete 两步, 下面先看 beginWork 的部分</p>
<h4 id="beginWork"><a href="#beginWork" class="headerlink" title="beginWork"></a>beginWork</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">  function beginWork(</span><br><span class="line">  current: Fiber | null,</span><br><span class="line">  workInProgress: Fiber,</span><br><span class="line">  renderExpirationTime: ExpirationTime,</span><br><span class="line">): Fiber | null &#123;</span><br><span class="line">  if (</span><br><span class="line">    workInProgress.expirationTime === NoWork ||</span><br><span class="line">    workInProgress.expirationTime &gt; renderExpirationTime</span><br><span class="line">  ) &#123;</span><br><span class="line">    return bailoutOnLowPriority(current, workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  switch (workInProgress.tag) &#123;</span><br><span class="line">    case IndeterminateComponent:</span><br><span class="line">      return mountIndeterminateComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    case FunctionalComponent:</span><br><span class="line">      return updateFunctionalComponent(current, workInProgress);</span><br><span class="line">    case ClassComponent:</span><br><span class="line">      return updateClassComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    case HostRoot:</span><br><span class="line">      return updateHostRoot(current, workInProgress, renderExpirationTime);</span><br><span class="line">    case HostComponent:</span><br><span class="line">      return updateHostComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    case HostText:</span><br><span class="line">      return updateHostText(current, workInProgress);</span><br><span class="line">    case CallHandlerPhase:</span><br><span class="line">      // This is a restart. Reset the tag to the initial phase.</span><br><span class="line">      workInProgress.tag = CallComponent;</span><br><span class="line">    // Intentionally fall through since this is now the same.</span><br><span class="line">    case CallComponent:</span><br><span class="line">      return updateCallComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    case ReturnComponent:</span><br><span class="line">      // A return component is just a placeholder, we can just run through the</span><br><span class="line">      // next one immediately.</span><br><span class="line">      return null;</span><br><span class="line">    case HostPortal:</span><br><span class="line">      return updatePortalComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    case Fragment:</span><br><span class="line">      return updateFragment(current, workInProgress);</span><br><span class="line">    default:</span><br><span class="line">      invariant(</span><br><span class="line">        false,</span><br><span class="line">        &apos;Unknown unit of work tag. This error is likely caused by a bug in &apos; +</span><br><span class="line">          &apos;React. Please file an issue.&apos;,</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>beginWork函数是一个入口, 根据fiber节点不同的tag，调用对应的update方法。<br>比如下面可以里先看看 updateClassComponent 这个方法</p>
<h4 id="updateClassComponent"><a href="#updateClassComponent" class="headerlink" title="updateClassComponent"></a>updateClassComponent</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">function updateClassComponent(</span><br><span class="line">  current: Fiber | null,</span><br><span class="line">  workInProgress: Fiber,</span><br><span class="line">  renderExpirationTime: ExpirationTime,</span><br><span class="line">) &#123;</span><br><span class="line">  // Push context providers early to prevent context stack mismatches.</span><br><span class="line">  // During mounting we don&apos;t know the child context yet as the instance doesn&apos;t exist.</span><br><span class="line">  // We will invalidate the child context in finishClassComponent() right after rendering.</span><br><span class="line">  const hasContext = pushContextProvider(workInProgress);</span><br><span class="line"></span><br><span class="line">  let shouldUpdate;</span><br><span class="line">  // 如果当前Class实例为null,就构造一个class实例, 否则就更新 class 实例</span><br><span class="line">  if (current === null) &#123;</span><br><span class="line">    if (!workInProgress.stateNode) &#123;</span><br><span class="line">      // In the initial pass we might need to construct the instance.</span><br><span class="line">      constructClassInstance(workInProgress, workInProgress.pendingProps);</span><br><span class="line">      mountClassInstance(workInProgress, renderExpirationTime);</span><br><span class="line">      shouldUpdate = true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      invariant(false, &apos;Resuming work not yet implemented.&apos;);</span><br><span class="line">      // In a resume, we&apos;ll already have an instance we can reuse.</span><br><span class="line">      // shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    shouldUpdate = updateClassInstance(</span><br><span class="line">      current,</span><br><span class="line">      workInProgress,</span><br><span class="line">      renderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  return finishClassComponent(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    shouldUpdate,</span><br><span class="line">    hasContext,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>updateClassComponent 主要判断是否初始化了ClassComponent, 如果没有就constructClassInstance一个实例, mountClassInstance然后挂载实例<br>如果有实例,  有就执行updateClassInstance, 主要返回 shouldUpdate<br>最后返回 finishClassComponent() 的结果</p>
<h4 id="updateClassInstance"><a href="#updateClassInstance" class="headerlink" title="updateClassInstance"></a>updateClassInstance</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">function updateClassInstance(</span><br><span class="line">  current: Fiber,</span><br><span class="line">  workInProgress: Fiber,</span><br><span class="line">  renderExpirationTime: ExpirationTime,</span><br><span class="line">): boolean &#123;</span><br><span class="line">  const instance = workInProgress.stateNode;</span><br><span class="line">  resetInputPointers(workInProgress, instance);</span><br><span class="line"></span><br><span class="line">  const oldProps = workInProgress.memoizedProps;</span><br><span class="line">  const newProps = workInProgress.pendingProps;</span><br><span class="line">  const oldContext = instance.context;</span><br><span class="line">  const newUnmaskedContext = getUnmaskedContext(workInProgress);</span><br><span class="line">  const newContext = getMaskedContext(workInProgress, newUnmaskedContext);</span><br><span class="line"></span><br><span class="line">  // Note: During these life-cycles, instance.props/instance.state are what</span><br><span class="line">  // ever the previously attempted to render - not the &quot;current&quot;. However,</span><br><span class="line">  // during componentDidUpdate we pass the &quot;current&quot; props.</span><br><span class="line"></span><br><span class="line">  if (</span><br><span class="line">    typeof instance.componentWillReceiveProps === &apos;function&apos; &amp;&amp;</span><br><span class="line">    (oldProps !== newProps || oldContext !== newContext)</span><br><span class="line">  ) &#123;</span><br><span class="line">    callComponentWillReceiveProps(</span><br><span class="line">      workInProgress,</span><br><span class="line">      instance,</span><br><span class="line">      newProps,</span><br><span class="line">      newContext,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Compute the next state using the memoized state and the update queue.</span><br><span class="line">  const oldState = workInProgress.memoizedState;</span><br><span class="line">  // TODO: Previous state can be null.</span><br><span class="line">  let newState;</span><br><span class="line">  if (workInProgress.updateQueue !== null) &#123;</span><br><span class="line">    newState = processUpdateQueue(</span><br><span class="line">      current,</span><br><span class="line">      workInProgress,</span><br><span class="line">      workInProgress.updateQueue,</span><br><span class="line">      instance,</span><br><span class="line">      newProps,</span><br><span class="line">      renderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    newState = oldState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (</span><br><span class="line">    oldProps === newProps &amp;&amp;</span><br><span class="line">    oldState === newState &amp;&amp;</span><br><span class="line">    !hasContextChanged() &amp;&amp;</span><br><span class="line">    !(</span><br><span class="line">      workInProgress.updateQueue !== null &amp;&amp;</span><br><span class="line">      workInProgress.updateQueue.hasForceUpdate</span><br><span class="line">    )</span><br><span class="line">  ) &#123;</span><br><span class="line">    // If an update was already in progress, we should schedule an Update</span><br><span class="line">    // effect even though we&apos;re bailing out, so that cWU/cDU are called.</span><br><span class="line">    if (typeof instance.componentDidUpdate === &apos;function&apos;) &#123;</span><br><span class="line">      if (</span><br><span class="line">        oldProps !== current.memoizedProps ||</span><br><span class="line">        oldState !== current.memoizedState</span><br><span class="line">      ) &#123;</span><br><span class="line">        workInProgress.effectTag |= Update;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const shouldUpdate = checkShouldComponentUpdate(</span><br><span class="line">    workInProgress,</span><br><span class="line">    oldProps,</span><br><span class="line">    newProps,</span><br><span class="line">    oldState,</span><br><span class="line">    newState,</span><br><span class="line">    newContext,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  if (shouldUpdate) &#123;</span><br><span class="line">    if (typeof instance.componentWillUpdate === &apos;function&apos;) &#123;</span><br><span class="line">      startPhaseTimer(workInProgress, &apos;componentWillUpdate&apos;);</span><br><span class="line">      instance.componentWillUpdate(newProps, newState, newContext);</span><br><span class="line">      stopPhaseTimer();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof instance.componentDidUpdate === &apos;function&apos;) &#123;</span><br><span class="line">      workInProgress.effectTag |= Update;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // If an update was already in progress, we should schedule an Update</span><br><span class="line">    // effect even though we&apos;re bailing out, so that cWU/cDU are called.</span><br><span class="line">    if (typeof instance.componentDidUpdate === &apos;function&apos;) &#123;</span><br><span class="line">      if (</span><br><span class="line">        oldProps !== current.memoizedProps ||</span><br><span class="line">        oldState !== current.memoizedState</span><br><span class="line">      ) &#123;</span><br><span class="line">        workInProgress.effectTag |= Update;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If shouldComponentUpdate returned false, we should still update the</span><br><span class="line">    // memoized props/state to indicate that this work can be reused.</span><br><span class="line">    memoizeProps(workInProgress, newProps);</span><br><span class="line">    memoizeState(workInProgress, newState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Update the existing instance&apos;s state, props, and context pointers even</span><br><span class="line">  // if shouldComponentUpdate returns false.</span><br><span class="line">  instance.props = newProps;</span><br><span class="line">  instance.state = newState;</span><br><span class="line">  instance.context = newContext;</span><br><span class="line"></span><br><span class="line">  return shouldUpdate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个updateClassInstance主要的工作:</p>
<ol>
<li>当前 instance 的 props, state, context备份为老的版本, 比如 oldProps = workInProgress.memoizedProps; newProps = workInProgress.pendingProps;</li>
<li>调用 callComponentWillReceiveProps</li>
<li>遍历workInProgress.updateQueue, 执行update, 生成newState</li>
<li>checkShouldComponentUpdate, 这个地方会调用 ShouldComponentUpdate这个钩子函数</li>
<li>如果shouldUpdate 为true, 调用componentWillUpdate钩子函数</li>
<li>不管shouldUpdate是什么, 都更新当前 instance 的 props, state, context,  这样子这个work的相当于可以被复用了, 就算没有rerender, 至少更新了instance内部的状态</li>
</ol>
<h5 id="updateFunctionalComponent"><a href="#updateFunctionalComponent" class="headerlink" title="updateFunctionalComponent"></a>updateFunctionalComponent</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function updateFunctionalComponent(current, workInProgress) &#123;</span><br><span class="line">  const fn = workInProgress.type;</span><br><span class="line">  const nextProps = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line">  if (hasContextChanged()) &#123;</span><br><span class="line">    // Normally we can bail out on props equality but if context has changed</span><br><span class="line">    // we don&apos;t do the bailout and we have to reuse existing props instead.</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (workInProgress.memoizedProps === nextProps) &#123;</span><br><span class="line">      return bailoutOnAlreadyFinishedWork(current, workInProgress);</span><br><span class="line">    &#125;</span><br><span class="line">    // TODO: consider bringing fn.shouldComponentUpdate() back.</span><br><span class="line">    // It used to be here.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var unmaskedContext = getUnmaskedContext(workInProgress);</span><br><span class="line">  var context = getMaskedContext(workInProgress, unmaskedContext);</span><br><span class="line"></span><br><span class="line">  var nextChildren;</span><br><span class="line"></span><br><span class="line">  nextChildren = fn(nextProps, context);</span><br><span class="line"></span><br><span class="line">  // 直接调用 reconcileChildren 进行 diff, 生成 effect list</span><br><span class="line">  // 与updateClassInstance对比就可以发现少了生命周期的功能</span><br><span class="line">  reconcileChildren(current, workInProgress, nextChildren);</span><br><span class="line"></span><br><span class="line">  memoizeProps(workInProgress, nextProps);</span><br><span class="line">  return workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="finishClassComponent"><a href="#finishClassComponent" class="headerlink" title="finishClassComponent"></a>finishClassComponent</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">function finishClassComponent(</span><br><span class="line">    current: Fiber | null,</span><br><span class="line">    workInProgress: Fiber,</span><br><span class="line">    shouldUpdate: boolean,</span><br><span class="line">    hasContext: boolean,</span><br><span class="line">  ) &#123;</span><br><span class="line">    // Refs should update even if shouldComponentUpdate returns false</span><br><span class="line">    markRef(current, workInProgress);</span><br><span class="line"></span><br><span class="line">    if (!shouldUpdate) &#123;</span><br><span class="line">      // Context providers should defer to sCU for rendering</span><br><span class="line">      if (hasContext) &#123;</span><br><span class="line">        invalidateContextProvider(workInProgress, false);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return bailoutOnAlreadyFinishedWork(current, workInProgress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const instance = workInProgress.stateNode;</span><br><span class="line"></span><br><span class="line">    // Rerender</span><br><span class="line">    ReactCurrentOwner.current = workInProgress;</span><br><span class="line">    let nextChildren;</span><br><span class="line"></span><br><span class="line">    // 这个地方调用我们业务代码中的 render方法</span><br><span class="line">    nextChildren = instance.render();</span><br><span class="line"></span><br><span class="line">    // 这个是非常关键的一个方法, 要开始diff virtual dom的变更了</span><br><span class="line">    reconcileChildren(current, workInProgress, nextChildren);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Memoize props and state using the values we just used to render.</span><br><span class="line">    // TODO: Restructure so we never read values from the instance.</span><br><span class="line">    memoizeState(workInProgress, instance.state);</span><br><span class="line">    memoizeProps(workInProgress, instance.props);</span><br><span class="line"></span><br><span class="line">    // The context might have changed so we need to recalculate it.</span><br><span class="line">    if (hasContext) &#123;</span><br><span class="line">      invalidateContextProvider(workInProgress, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return workInProgress.child;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="reconcileChildrenAtExpirationTime"><a href="#reconcileChildrenAtExpirationTime" class="headerlink" title="reconcileChildrenAtExpirationTime"></a>reconcileChildrenAtExpirationTime</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  function reconcileChildrenAtExpirationTime(</span><br><span class="line">  current,</span><br><span class="line">  workInProgress,</span><br><span class="line">  nextChildren,</span><br><span class="line">  renderExpirationTime,</span><br><span class="line">) &#123;</span><br><span class="line">  if (current === null) &#123;</span><br><span class="line">    // If this is a fresh new component that hasn&apos;t been rendered yet, we</span><br><span class="line">    // won&apos;t update its child set by applying minimal side-effects. Instead,</span><br><span class="line">    // we will add them all to the child before it gets rendered. That means</span><br><span class="line">    // we can optimize this reconciliation pass by not tracking side-effects.</span><br><span class="line">    workInProgress.child = mountChildFibers(</span><br><span class="line">      workInProgress,</span><br><span class="line">      null,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // If the current child is the same as the work in progress, it means that</span><br><span class="line">    // we haven&apos;t yet started any work on these children. Therefore, we use</span><br><span class="line">    // the clone algorithm to create a copy of all the current children.</span><br><span class="line"></span><br><span class="line">    // If we had any progressed work already, that is invalid at this point so</span><br><span class="line">    // let&apos;s throw it out.</span><br><span class="line">    workInProgress.child = reconcileChildFibers(</span><br><span class="line">      workInProgress,</span><br><span class="line">      current.child,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要判断当前的节点是否已经挂载并且render过了,<br>没有挂载: 执行mountChildFibers, 不会做side-effect 的优化, 会直接render这个节点<br>已经挂载: 执行reconcileChildFibers, 会在virtual-dom中 使用算法优化, 生成最小的 side-effects, 用最小的dom变更去优化渲染性能</p>
<h4 id="reconcileChildFibers"><a href="#reconcileChildFibers" class="headerlink" title="reconcileChildFibers"></a>reconcileChildFibers</h4><p>下面也能揭晓最开始 说的react新特性 支持 reder中return数组和字符串<br>总的来说，这个函数根据newChild的类型调用不同的方法。<br>newChild可能是一个元素，也可能是一个数组（React16新特性）<br>如果是reconcile单个元素，以reconcileSingleElement为例比较key和type，如果相同，复用fiber，删除多余的元素（currentFirstChild的sibling），<br>如果不同，调用createFiberFromElement，返回新创建的。<br>如果是string，reconcileSingleTextNode<br>如果是array，reconcileChildrenArray<br>如果是空，deleteRemainingChildren删除老的子元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">  // This API will tag the children with the side-effect of the reconciliation</span><br><span class="line">  // itself. They will be added to the side-effect list as we pass through the</span><br><span class="line">  // children and the parent.</span><br><span class="line">  function reconcileChildFibers(</span><br><span class="line">    returnFiber: Fiber,</span><br><span class="line">    currentFirstChild: Fiber | null,</span><br><span class="line">    newChild: any,</span><br><span class="line">    expirationTime: ExpirationTime,</span><br><span class="line">  ): Fiber | null &#123;</span><br><span class="line">    // This function is not recursive.</span><br><span class="line">    // If the top level item is an array, we treat it as a set of children,</span><br><span class="line">    // not as a fragment. Nested arrays on the other hand will be treated as</span><br><span class="line">    // fragment nodes. Recursion happens at the normal flow.</span><br><span class="line"></span><br><span class="line">    // 支持新的 fragments 标签</span><br><span class="line">    // Handle top level unkeyed fragments as if they were arrays.</span><br><span class="line">    // This leads to an ambiguity between &lt;&gt;&#123;[...]&#125;&lt;/&gt; and &lt;&gt;...&lt;/&gt;.</span><br><span class="line">    // We treat the ambiguous cases above the same.</span><br><span class="line">    if (</span><br><span class="line">      typeof newChild === &apos;object&apos; &amp;&amp;</span><br><span class="line">      newChild !== null &amp;&amp;</span><br><span class="line">      newChild.type === REACT_FRAGMENT_TYPE &amp;&amp;</span><br><span class="line">      newChild.key === null</span><br><span class="line">    ) &#123;</span><br><span class="line">      newChild = newChild.props.children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Handle object types</span><br><span class="line">    const isObject = typeof newChild === &apos;object&apos; &amp;&amp; newChild !== null;</span><br><span class="line"></span><br><span class="line">    if (isObject) &#123;</span><br><span class="line">      switch (newChild.$$typeof) &#123;</span><br><span class="line">        case REACT_ELEMENT_TYPE:</span><br><span class="line">          return placeSingleChild(</span><br><span class="line">            reconcileSingleElement(</span><br><span class="line">              returnFiber,</span><br><span class="line">              currentFirstChild,</span><br><span class="line">              newChild,</span><br><span class="line">              expirationTime,</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line">        case REACT_CALL_TYPE:</span><br><span class="line">          return placeSingleChild(</span><br><span class="line">            reconcileSingleCall(</span><br><span class="line">              returnFiber,</span><br><span class="line">              currentFirstChild,</span><br><span class="line">              newChild,</span><br><span class="line">              expirationTime,</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">        case REACT_RETURN_TYPE:</span><br><span class="line">          return placeSingleChild(</span><br><span class="line">            reconcileSingleReturn(</span><br><span class="line">              returnFiber,</span><br><span class="line">              currentFirstChild,</span><br><span class="line">              newChild,</span><br><span class="line">              expirationTime,</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">        case REACT_PORTAL_TYPE:</span><br><span class="line">          return placeSingleChild(</span><br><span class="line">            reconcileSinglePortal(</span><br><span class="line">              returnFiber,</span><br><span class="line">              currentFirstChild,</span><br><span class="line">              newChild,</span><br><span class="line">              expirationTime,</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (typeof newChild === &apos;string&apos; || typeof newChild === &apos;number&apos;) &#123;</span><br><span class="line">      return placeSingleChild(</span><br><span class="line">        reconcileSingleTextNode(</span><br><span class="line">          returnFiber,</span><br><span class="line">          currentFirstChild,</span><br><span class="line">          &apos;&apos; + newChild,</span><br><span class="line">          expirationTime,</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (isArray(newChild)) &#123;</span><br><span class="line">      return reconcileChildrenArray(</span><br><span class="line">        returnFiber,</span><br><span class="line">        currentFirstChild,</span><br><span class="line">        newChild,</span><br><span class="line">        expirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (getIteratorFn(newChild)) &#123;</span><br><span class="line">      return reconcileChildrenIterator(</span><br><span class="line">        returnFiber,</span><br><span class="line">        currentFirstChild,</span><br><span class="line">        newChild,</span><br><span class="line">        expirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (isObject) &#123;</span><br><span class="line">      throwOnInvalidObjectType(returnFiber, newChild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Remaining cases are all treated as empty.</span><br><span class="line">    return deleteRemainingChildren(returnFiber, currentFirstChild);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return reconcileChildFibers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="reconcileChildrenArray"><a href="#reconcileChildrenArray" class="headerlink" title="reconcileChildrenArray"></a>reconcileChildrenArray</h4><p>react最有名的virtual-dom 的diff过程可以用下面的这个方法来表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">function reconcileChildrenArray(</span><br><span class="line">  returnFiber: Fiber,</span><br><span class="line">  currentFirstChild: Fiber | null,</span><br><span class="line">  newChildren: Array&lt;*&gt;,</span><br><span class="line">  expirationTime: ExpirationTime,</span><br><span class="line">): Fiber | null &#123;</span><br><span class="line">  // This algorithm can&apos;t optimize by searching from boths ends since we</span><br><span class="line">  // don&apos;t have backpointers on fibers. I&apos;m trying to see how far we can get</span><br><span class="line">  // with that model. If it ends up not being worth the tradeoffs, we can</span><br><span class="line">  // add it later.</span><br><span class="line"></span><br><span class="line">  // Even with a two ended optimization, we&apos;d want to optimize for the case</span><br><span class="line">  // where there are few changes and brute force the comparison instead of</span><br><span class="line">  // going for the Map. It&apos;d like to explore hitting that path first in</span><br><span class="line">  // forward-only mode and only go for the Map once we notice that we need</span><br><span class="line">  // lots of look ahead. This doesn&apos;t handle reversal as well as two ended</span><br><span class="line">  // search but that&apos;s unusual. Besides, for the two ended optimization to</span><br><span class="line">  // work on Iterables, we&apos;d need to copy the whole set.</span><br><span class="line"></span><br><span class="line">  // In this first iteration, we&apos;ll just live with hitting the bad case</span><br><span class="line">  // (adding everything to a Map) in for every insert/move.</span><br><span class="line"></span><br><span class="line">  // If you change this code, also update reconcileChildrenIterator() which</span><br><span class="line">  // uses the same algorithm.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  let resultingFirstChild: Fiber | null = null;</span><br><span class="line">  let previousNewFiber: Fiber | null = null;</span><br><span class="line"></span><br><span class="line">  let oldFiber = currentFirstChild;</span><br><span class="line">  let lastPlacedIndex = 0;</span><br><span class="line">  let newIdx = 0;</span><br><span class="line">  let nextOldFiber = null;</span><br><span class="line"></span><br><span class="line">  // 遍历一遍 新的newChildren数组, 通过 updateSlot来对比 新老数组的元素, 如果是相同元素, 就更新 fiber链表</span><br><span class="line">  for (; oldFiber !== null &amp;&amp; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">    if (oldFiber.index &gt; newIdx) &#123;</span><br><span class="line">      nextOldFiber = oldFiber;</span><br><span class="line">      oldFiber = null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      nextOldFiber = oldFiber.sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    const newFiber = updateSlot(</span><br><span class="line">      returnFiber,</span><br><span class="line">      oldFiber,</span><br><span class="line">      newChildren[newIdx],</span><br><span class="line">      expirationTime,</span><br><span class="line">    );</span><br><span class="line">    if (newFiber === null) &#123;</span><br><span class="line">      // TODO: This breaks on empty slots like null children. That&apos;s</span><br><span class="line">      // unfortunate because it triggers the slow path all the time. We need</span><br><span class="line">      // a better way to communicate whether this was a miss or null,</span><br><span class="line">      // boolean, undefined, etc.</span><br><span class="line">      if (oldFiber === null) &#123;</span><br><span class="line">        oldFiber = nextOldFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (shouldTrackSideEffects) &#123;</span><br><span class="line">      if (oldFiber &amp;&amp; newFiber.alternate === null) &#123;</span><br><span class="line">        // We matched the slot, but we didn&apos;t reuse the existing fiber, so we</span><br><span class="line">        // need to delete the existing child.</span><br><span class="line">        deleteChild(returnFiber, oldFiber);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // fiber是一个链表的数据结构, 这一步操作就是把 newFiber 放到链表的正确的位置, 构建 fiber 链表</span><br><span class="line">    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">    if (previousNewFiber === null) &#123;</span><br><span class="line">      // TODO: Move out of the loop. This only happens for the first run.</span><br><span class="line">      resultingFirstChild = newFiber;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // TODO: Defer siblings if we&apos;re not at the right index for this slot.</span><br><span class="line">      // I.e. if we had null values before, then we want to defer this</span><br><span class="line">      // for each null value. However, we also don&apos;t want to call updateSlot</span><br><span class="line">      // with the previous one.</span><br><span class="line">      previousNewFiber.sibling = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    previousNewFiber = newFiber;</span><br><span class="line">    oldFiber = nextOldFiber;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 如果遍历完新数组, 把老数组剩下的元素都删除了</span><br><span class="line">  if (newIdx === newChildren.length) &#123;</span><br><span class="line">    // We&apos;ve reached the end of the new children. We can delete the rest.</span><br><span class="line">    deleteRemainingChildren(returnFiber, oldFiber);</span><br><span class="line">    return resultingFirstChild;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 如果老的数组已经遍历结束了, 但是新的数组没有结束, 遍历一下新数组剩下元素然后插入</span><br><span class="line">  if (oldFiber === null) &#123;</span><br><span class="line">    // If we don&apos;t have any more existing children we can choose a fast path</span><br><span class="line">    // since the rest will all be insertions.</span><br><span class="line">    for (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">      const newFiber = createChild(</span><br><span class="line">        returnFiber,</span><br><span class="line">        newChildren[newIdx],</span><br><span class="line">        expirationTime,</span><br><span class="line">      );</span><br><span class="line">      if (!newFiber) &#123;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">      if (previousNewFiber === null) &#123;</span><br><span class="line">        // TODO: Move out of the loop. This only happens for the first run.</span><br><span class="line">        resultingFirstChild = newFiber;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        previousNewFiber.sibling = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      previousNewFiber = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    return resultingFirstChild;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Add all children to a key map for quick lookups.</span><br><span class="line">  // 如果没有命中上面两中情况: 那就是发生了移动或者删除的操作, 就把所有老数组元素按key放map里</span><br><span class="line">  const existingChildren = mapRemainingChildren(returnFiber, oldFiber);</span><br><span class="line"></span><br><span class="line">  // Keep scanning and use the map to restore deleted items as moves.</span><br><span class="line">  // 继续遍历新的数组, 把老数组中有用的元素的插入到新的数组中, </span><br><span class="line">  for (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">    const newFiber = updateFromMap(</span><br><span class="line">      existingChildren,</span><br><span class="line">      returnFiber,</span><br><span class="line">      newIdx,</span><br><span class="line">      newChildren[newIdx],</span><br><span class="line">      expirationTime,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 如果老数组这里面这个元素在新数组中有, 就插入,到新数组中, 并且在existingChildren 把这个元素删除,  因为最后existingChildren 中的元素都会被删除</span><br><span class="line">    if (newFiber) &#123;</span><br><span class="line">      if (shouldTrackSideEffects) &#123;</span><br><span class="line">        if (newFiber.alternate !== null) &#123;</span><br><span class="line">          // The new fiber is a work in progress, but if there exists a</span><br><span class="line">          // current, that means that we reused the fiber. We need to delete</span><br><span class="line">          // it from the child list so that we don&apos;t add it to the deletion</span><br><span class="line">          // list.</span><br><span class="line">          existingChildren.delete(</span><br><span class="line">            newFiber.key === null ? newIdx : newFiber.key,</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">      if (previousNewFiber === null) &#123;</span><br><span class="line">        resultingFirstChild = newFiber;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        previousNewFiber.sibling = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      previousNewFiber = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 删除没有命中上面情况的元素, 就是删除老的数组中  非(老数组 交集 新数组)的元素</span><br><span class="line">  if (shouldTrackSideEffects) &#123;</span><br><span class="line">    // Any existing children that weren&apos;t consumed above were deleted. We need</span><br><span class="line">    // to add them to the deletion list.</span><br><span class="line">    existingChildren.forEach(child =&gt; deleteChild(returnFiber, child));</span><br><span class="line">  &#125;</span><br><span class="line">  最后返回的是一个fiber链表的第一个元素</span><br><span class="line">  return resultingFirstChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>diff完成之后, 一直return,  workInProgress.child = resultingFirstChild,<br>后面回到 performUnitOfWork函数中, 执行 completeUnitOfWork</p>
<h4 id="completeUnitOfWork"><a href="#completeUnitOfWork" class="headerlink" title="completeUnitOfWork"></a>completeUnitOfWork</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">function completeUnitOfWork(workInProgress: Fiber): Fiber | null &#123;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    // The current, flushed, state of this fiber is the alternate.</span><br><span class="line">    // Ideally nothing should rely on this, but relying on it here</span><br><span class="line">    // means that we don&apos;t need an additional field on the work in</span><br><span class="line">    // progress.</span><br><span class="line">    const current = workInProgress.alternate;</span><br><span class="line">    </span><br><span class="line">    const next = completeWork(</span><br><span class="line">      current,</span><br><span class="line">      workInProgress,</span><br><span class="line">      nextRenderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    const returnFiber = workInProgress.return;</span><br><span class="line">    const siblingFiber = workInProgress.sibling;</span><br><span class="line"></span><br><span class="line">    resetExpirationTime(workInProgress, nextRenderExpirationTime);</span><br><span class="line"></span><br><span class="line">    if (next !== null) &#123;</span><br><span class="line">      stopWorkTimer(workInProgress);</span><br><span class="line">      if (__DEV__ &amp;&amp; ReactFiberInstrumentation.debugTool) &#123;</span><br><span class="line">        ReactFiberInstrumentation.debugTool.onCompleteWork(workInProgress);</span><br><span class="line">      &#125;</span><br><span class="line">      // If completing this work spawned new work, do that next. We&apos;ll come</span><br><span class="line">      // back here again.</span><br><span class="line">      return next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (returnFiber !== null) &#123;</span><br><span class="line"></span><br><span class="line">      // 把 子树的 effect list 插入到 effect list of the parent.</span><br><span class="line">      // Append all the effects of the subtree and this fiber onto the effect</span><br><span class="line">      // list of the parent. The completion order of the children affects the</span><br><span class="line">      // side-effect order.</span><br><span class="line">      if (returnFiber.firstEffect === null) &#123;</span><br><span class="line">        returnFiber.firstEffect = workInProgress.firstEffect;</span><br><span class="line">      &#125;</span><br><span class="line">      if (workInProgress.lastEffect !== null) &#123;</span><br><span class="line">        if (returnFiber.lastEffect !== null) &#123;</span><br><span class="line">          returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;</span><br><span class="line">        &#125;</span><br><span class="line">        returnFiber.lastEffect = workInProgress.lastEffect;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 把当前fiber节点的effect list 也插入到 effect list of the parent.</span><br><span class="line">      // If this fiber had side-effects, we append it AFTER the children&apos;s</span><br><span class="line">      // side-effects. We can perform certain side-effects earlier if</span><br><span class="line">      // needed, by doing multiple passes over the effect list. We don&apos;t want</span><br><span class="line">      // to schedule our own side-effect on our own list because if end up</span><br><span class="line">      // reusing children we&apos;ll schedule this effect onto itself since we&apos;re</span><br><span class="line">      // at the end.</span><br><span class="line">      const effectTag = workInProgress.effectTag;</span><br><span class="line">      // Skip both NoWork and PerformedWork tags when creating the effect list.</span><br><span class="line">      // PerformedWork effect is read by React DevTools but shouldn&apos;t be committed.</span><br><span class="line">      if (effectTag &gt; PerformedWork) &#123;</span><br><span class="line">        if (returnFiber.lastEffect !== null) &#123;</span><br><span class="line">          returnFiber.lastEffect.nextEffect = workInProgress;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          returnFiber.firstEffect = workInProgress;</span><br><span class="line">        &#125;</span><br><span class="line">        returnFiber.lastEffect = workInProgress;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stopWorkTimer(workInProgress);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    if (siblingFiber !== null) &#123;</span><br><span class="line">      // If there is more work to do in this returnFiber, do that next.</span><br><span class="line">      return siblingFiber;</span><br><span class="line">    &#125; else if (returnFiber !== null) &#123;</span><br><span class="line">      // If there&apos;s no more work in this returnFiber. Complete the returnFiber.</span><br><span class="line">      workInProgress = returnFiber;</span><br><span class="line">      continue;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // We&apos;ve reached the root.</span><br><span class="line">      const root: FiberRoot = workInProgress.stateNode;</span><br><span class="line">      root.isReadyForCommit = true;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 函数主主体是一个循环, 主要的功能就是调用 completeWork,  同时也执行 把 子树的 effect list 插入到 effect list of the parent.</p>
<h4 id="completeWork"><a href="#completeWork" class="headerlink" title="completeWork"></a>completeWork</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line">function completeWork(</span><br><span class="line">  current: Fiber | null,</span><br><span class="line">  workInProgress: Fiber,</span><br><span class="line">  renderExpirationTime: ExpirationTime,</span><br><span class="line">): Fiber | null &#123;</span><br><span class="line"></span><br><span class="line">  // 获取组件的的 newProps</span><br><span class="line">  const newProps = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line">  // 根据fiber的 tag 来做处理</span><br><span class="line">  switch (workInProgress.tag) &#123;</span><br><span class="line">    case FunctionalComponent:</span><br><span class="line">      return null;</span><br><span class="line">    case ClassComponent: &#123;</span><br><span class="line">      // We are leaving this subtree, so pop context if any.</span><br><span class="line">      popContextProvider(workInProgress);</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    case HostRoot: &#123;</span><br><span class="line">      popHostContainer(workInProgress);</span><br><span class="line">      popTopLevelContextObject(workInProgress);</span><br><span class="line">      const fiberRoot = (workInProgress.stateNode: FiberRoot);</span><br><span class="line">      if (fiberRoot.pendingContext) &#123;</span><br><span class="line">        fiberRoot.context = fiberRoot.pendingContext;</span><br><span class="line">        fiberRoot.pendingContext = null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (current === null || current.child === null) &#123;</span><br><span class="line">        // If we hydrated, pop so that we can delete any remaining children</span><br><span class="line">        // that weren&apos;t hydrated.</span><br><span class="line">        popHydrationState(workInProgress);</span><br><span class="line">        // This resets the hacky state to fix isMounted before committing.</span><br><span class="line">        // TODO: Delete this when we delete isMounted and findDOMNode.</span><br><span class="line">        workInProgress.effectTag &amp;= ~Placement;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 最后是调用 updateHostContainer 来更新, 传入包含 effect list 的 workInProgress</span><br><span class="line">      updateHostContainer(workInProgress);</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    case HostComponent: &#123;</span><br><span class="line">      popHostContext(workInProgress);</span><br><span class="line">      const rootContainerInstance = getRootHostContainer();</span><br><span class="line">      const type = workInProgress.type;</span><br><span class="line">      if (current !== null &amp;&amp; workInProgress.stateNode != null) &#123;</span><br><span class="line">        // If we have an alternate, that means this is an update and we need to</span><br><span class="line">        // schedule a side-effect to do the updates.</span><br><span class="line">        const oldProps = current.memoizedProps;</span><br><span class="line">        // If we get updated because one of our children updated, we don&apos;t</span><br><span class="line">        // have newProps so we&apos;ll have to reuse them.</span><br><span class="line">        // TODO: Split the update API as separate for the props vs. children.</span><br><span class="line">        // Even better would be if children weren&apos;t special cased at all tho.</span><br><span class="line">        const instance: I = workInProgress.stateNode;</span><br><span class="line">        const currentHostContext = getHostContext();</span><br><span class="line"></span><br><span class="line">        // 调用 host 传入的 prepareUpdate 方法, 生成需要更新的dom属性</span><br><span class="line">        const updatePayload = prepareUpdate(</span><br><span class="line">          instance,</span><br><span class="line">          type,</span><br><span class="line">          oldProps,</span><br><span class="line">          newProps,</span><br><span class="line">          rootContainerInstance,</span><br><span class="line">          currentHostContext,</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // 最终是调用这个方法来更新dom的</span><br><span class="line">        updateHostComponent(</span><br><span class="line">          current,</span><br><span class="line">          workInProgress,</span><br><span class="line">          updatePayload,</span><br><span class="line">          type,</span><br><span class="line">          oldProps,</span><br><span class="line">          newProps,</span><br><span class="line">          rootContainerInstance,</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // 如果 ref 有修改就标记一下ref更新</span><br><span class="line">        if (current.ref !== workInProgress.ref) &#123;</span><br><span class="line">          markRef(workInProgress);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (!newProps) &#123;</span><br><span class="line">          invariant(</span><br><span class="line">            workInProgress.stateNode !== null,</span><br><span class="line">            &apos;We must have new props for new mounts. This error is likely &apos; +</span><br><span class="line">              &apos;caused by a bug in React. Please file an issue.&apos;,</span><br><span class="line">          );</span><br><span class="line">          // This can happen when we abort work.</span><br><span class="line">          return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const currentHostContext = getHostContext();</span><br><span class="line">        // TODO: Move createInstance to beginWork and keep it on a context</span><br><span class="line">        // &quot;stack&quot; as the parent. Then append children as we go in beginWork</span><br><span class="line">        // or completeWork depending on we want to add then top-&gt;down or</span><br><span class="line">        // bottom-&gt;up. Top-&gt;down is faster in IE11.</span><br><span class="line">        let wasHydrated = popHydrationState(workInProgress);</span><br><span class="line">        if (wasHydrated) &#123;</span><br><span class="line">          // TODO: Move this and createInstance step into the beginPhase</span><br><span class="line">          // to consolidate.</span><br><span class="line">          if (</span><br><span class="line">            prepareToHydrateHostInstance(</span><br><span class="line">              workInProgress,</span><br><span class="line">              rootContainerInstance,</span><br><span class="line">              currentHostContext,</span><br><span class="line">            )</span><br><span class="line">          ) &#123;</span><br><span class="line">            // If changes to the hydrated node needs to be applied at the</span><br><span class="line">            // commit-phase we mark this as such.</span><br><span class="line">            markUpdate(workInProgress);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          let instance = createInstance(</span><br><span class="line">            type,</span><br><span class="line">            newProps,</span><br><span class="line">            rootContainerInstance,</span><br><span class="line">            currentHostContext,</span><br><span class="line">            workInProgress,</span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line">          appendAllChildren(instance, workInProgress);</span><br><span class="line"></span><br><span class="line">          // Certain renderers require commit-time effects for initial mount.</span><br><span class="line">          // (eg DOM renderer supports auto-focus for certain elements).</span><br><span class="line">          // Make sure such renderers get scheduled for later work.</span><br><span class="line">          if (</span><br><span class="line">            finalizeInitialChildren(</span><br><span class="line">              instance,</span><br><span class="line">              type,</span><br><span class="line">              newProps,</span><br><span class="line">              rootContainerInstance,</span><br><span class="line">            )</span><br><span class="line">          ) &#123;</span><br><span class="line">            markUpdate(workInProgress);</span><br><span class="line">          &#125;</span><br><span class="line">          workInProgress.stateNode = instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (workInProgress.ref !== null) &#123;</span><br><span class="line">          // If there is a ref on a host node we need to schedule a callback</span><br><span class="line">          markRef(workInProgress);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    case HostText: &#123;</span><br><span class="line">      let newText = newProps;</span><br><span class="line">      if (current &amp;&amp; workInProgress.stateNode != null) &#123;</span><br><span class="line">        const oldText = current.memoizedProps;</span><br><span class="line">        // If we have an alternate, that means this is an update and we need</span><br><span class="line">        // to schedule a side-effect to do the updates.</span><br><span class="line">        updateHostText(current, workInProgress, oldText, newText);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (typeof newText !== &apos;string&apos;) &#123;</span><br><span class="line">          invariant(</span><br><span class="line">            workInProgress.stateNode !== null,</span><br><span class="line">            &apos;We must have new props for new mounts. This error is likely &apos; +</span><br><span class="line">              &apos;caused by a bug in React. Please file an issue.&apos;,</span><br><span class="line">          );</span><br><span class="line">          // This can happen when we abort work.</span><br><span class="line">          return null;</span><br><span class="line">        &#125;</span><br><span class="line">        const rootContainerInstance = getRootHostContainer();</span><br><span class="line">        const currentHostContext = getHostContext();</span><br><span class="line">        let wasHydrated = popHydrationState(workInProgress);</span><br><span class="line">        if (wasHydrated) &#123;</span><br><span class="line">          if (prepareToHydrateHostTextInstance(workInProgress)) &#123;</span><br><span class="line">            markUpdate(workInProgress);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          workInProgress.stateNode = createTextInstance(</span><br><span class="line">            newText,</span><br><span class="line">            rootContainerInstance,</span><br><span class="line">            currentHostContext,</span><br><span class="line">            workInProgress,</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    case CallComponent:</span><br><span class="line">      return moveCallToHandlerPhase(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    case CallHandlerPhase:</span><br><span class="line">      // Reset the tag to now be a first phase call.</span><br><span class="line">      workInProgress.tag = CallComponent;</span><br><span class="line">      return null;</span><br><span class="line">    case ReturnComponent:</span><br><span class="line">      // Does nothing.</span><br><span class="line">      return null;</span><br><span class="line">    case Fragment:</span><br><span class="line">      return null;</span><br><span class="line">    case HostPortal:</span><br><span class="line">      popHostContainer(workInProgress);</span><br><span class="line">      updateHostContainer(workInProgress);</span><br><span class="line">      return null;</span><br><span class="line">    // Error cases</span><br><span class="line">    case IndeterminateComponent:</span><br><span class="line">      invariant(</span><br><span class="line">        false,</span><br><span class="line">        &apos;An indeterminate component should have become determinate before &apos; +</span><br><span class="line">          &apos;completing. This error is likely caused by a bug in React. Please &apos; +</span><br><span class="line">          &apos;file an issue.&apos;,</span><br><span class="line">      );</span><br><span class="line">    // eslint-disable-next-line no-fallthrough</span><br><span class="line">    default:</span><br><span class="line">      invariant(</span><br><span class="line">        false,</span><br><span class="line">        &apos;Unknown unit of work tag. This error is likely caused by a bug in &apos; +</span><br><span class="line">          &apos;React. Please file an issue.&apos;,</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要的根据fiber的 tag 来执行不同的 update<br>我们可以分析其中的常见的 tag 为 HostComponent的情况,可以看到 调用 host 传入的 prepareUpdate 方法, 生成需要更新的dom属性, 然后执行updateHostComponent方法<br>prepareUpdate 和 updateHostComponent 都是react-dom里面传入的方法, 同样 在react-native, canvas等其他平台也有同样的定义, 相当于是一个规范的接口来兼容不同的硬件层</p>
<h4 id="updateHostComponent"><a href="#updateHostComponent" class="headerlink" title="updateHostComponent"></a>updateHostComponent</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">updateHostComponent = function(</span><br><span class="line">  current: Fiber,</span><br><span class="line">  workInProgress: Fiber,</span><br><span class="line">  updatePayload: null | PL,</span><br><span class="line">  type: T,</span><br><span class="line">  oldProps: P,</span><br><span class="line">  newProps: P,</span><br><span class="line">  rootContainerInstance: C,</span><br><span class="line">) &#123;</span><br><span class="line">  // If there are no effects associated with this node, then none of our children had any updates.</span><br><span class="line">  // This guarantees that we can reuse all of them.</span><br><span class="line">  const childrenUnchanged = workInProgress.firstEffect === null;</span><br><span class="line">  const currentInstance = current.stateNode;</span><br><span class="line">  if (childrenUnchanged &amp;&amp; updatePayload === null) &#123;</span><br><span class="line">    // No changes, just reuse the existing instance.</span><br><span class="line">    // Note that this might release a previous clone.</span><br><span class="line">    workInProgress.stateNode = currentInstance;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    let recyclableInstance = workInProgress.stateNode;</span><br><span class="line">    let newInstance = cloneInstance(</span><br><span class="line">      currentInstance,</span><br><span class="line">      updatePayload,</span><br><span class="line">      type,</span><br><span class="line">      oldProps,</span><br><span class="line">      newProps,</span><br><span class="line">      workInProgress,</span><br><span class="line">      childrenUnchanged,</span><br><span class="line">      recyclableInstance,</span><br><span class="line">    );</span><br><span class="line">    if (</span><br><span class="line">      finalizeInitialChildren(</span><br><span class="line">        newInstance,</span><br><span class="line">        type,</span><br><span class="line">        newProps,</span><br><span class="line">        rootContainerInstance,</span><br><span class="line">      )</span><br><span class="line">    ) &#123;</span><br><span class="line">      markUpdate(workInProgress);</span><br><span class="line">    &#125;</span><br><span class="line">    workInProgress.stateNode = newInstance;</span><br><span class="line">    if (childrenUnchanged) &#123;</span><br><span class="line">      // If there are no other effects in this tree, we need to flag this node as having one.</span><br><span class="line">      // Even though we&apos;re not going to use it for anything.</span><br><span class="line">      // Otherwise parents won&apos;t know that there are new children to propagate upwards.</span><br><span class="line">      markUpdate(workInProgress);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      // 下面就是调用 react-dom提供的接口来来添加变更到集合中, 有点类似于git中的 add 暂存操作, 等待commit</span><br><span class="line">      // If children might have changed, we have to add them all to the set.</span><br><span class="line">      appendAllChildren(newInstance, workInProgress);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>截止到这里,  reconcile的操作已经结束,  react的两个阶段(reconciliation , commiting) 已经完成了第一步<br>现在要回到 performWorkOnRoot, 开始执行 completeRoot</p>
<h4 id="completeRoot"><a href="#completeRoot" class="headerlink" title="completeRoot"></a>completeRoot</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function completeRoot(</span><br><span class="line">    root: FiberRoot,</span><br><span class="line">    finishedWork: Fiber,</span><br><span class="line">    expirationTime: ExpirationTime,</span><br><span class="line">  ): void &#123;</span><br><span class="line">    // Check if there&apos;s a batch that matches this expiration time.</span><br><span class="line">    const firstBatch = root.firstBatch;</span><br><span class="line">    if (firstBatch !== null &amp;&amp; firstBatch._expirationTime &lt;= expirationTime) &#123;</span><br><span class="line">      if (completedBatches === null) &#123;</span><br><span class="line">        completedBatches = [firstBatch];</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        completedBatches.push(firstBatch);</span><br><span class="line">      &#125;</span><br><span class="line">      if (firstBatch._defer) &#123;</span><br><span class="line">        // This root is blocked from committing by a batch. Unschedule it until</span><br><span class="line">        // we receive another update.</span><br><span class="line">        root.finishedWork = finishedWork;</span><br><span class="line">        root.remainingExpirationTime = NoWork;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Commit the root.</span><br><span class="line">    root.finishedWork = null;</span><br><span class="line">    root.remainingExpirationTime = commitRoot(finishedWork);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这个代码先判断一下是不是满足批量操作的优先级, 如果是满足, 就继续等下一个update, 最后一起批量地update<br>不然就调用commitRoot来提交更新</p>
<h4 id="commitRoot"><a href="#commitRoot" class="headerlink" title="commitRoot"></a>commitRoot</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">//提交effect list更新到 dom中</span><br><span class="line">function commitRoot(finishedWork: Fiber): ExpirationTime &#123;</span><br><span class="line">  // We keep track of this so that captureError can collect any boundaries</span><br><span class="line">  // that capture an error during the commit phase. The reason these aren&apos;t</span><br><span class="line">  // local to this function is because errors that occur during cWU are</span><br><span class="line">  // captured elsewhere, to prevent the unmount from being interrupted.</span><br><span class="line">  isWorking = true;</span><br><span class="line">  isCommitting = true;</span><br><span class="line">  startCommitTimer();</span><br><span class="line">  const root: FiberRoot = finishedWork.stateNode;</span><br><span class="line">  root.isReadyForCommit = false;</span><br><span class="line"></span><br><span class="line">  // Reset this to null before calling lifecycles</span><br><span class="line">  ReactCurrentOwner.current = null;</span><br><span class="line"></span><br><span class="line">  let firstEffect;</span><br><span class="line">  if (finishedWork.effectTag &gt; PerformedWork) &#123;</span><br><span class="line">    // A fiber&apos;s effect list consists only of its children, not itself. So if</span><br><span class="line">    // the root has an effect, we need to add it to the end of the list. The</span><br><span class="line">    // resulting list is the set that would belong to the root&apos;s parent, if</span><br><span class="line">    // it had one; that is, all the effects in the tree including the root.</span><br><span class="line">    if (finishedWork.lastEffect !== null) &#123;</span><br><span class="line">      finishedWork.lastEffect.nextEffect = finishedWork;</span><br><span class="line">      firstEffect = finishedWork.firstEffect;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      firstEffect = finishedWork;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // There is no effect on the root.</span><br><span class="line">    firstEffect = finishedWork.firstEffect;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 调用HostConfig.prepareForCommit的方法, 生成待提交的dom属性变更</span><br><span class="line">  prepareForCommit();</span><br><span class="line"></span><br><span class="line">  // Commit all the side-effects within a tree. We&apos;ll do this in two passes.</span><br><span class="line">  // The first pass performs all the host insertions, updates, deletions and</span><br><span class="line">  // ref unmounts.</span><br><span class="line">  nextEffect = firstEffect;</span><br><span class="line">  startCommitHostEffectsTimer();</span><br><span class="line">  while (nextEffect !== null) &#123;</span><br><span class="line">    let didError = false;</span><br><span class="line">    let error;</span><br><span class="line">    if (__DEV__) &#123;</span><br><span class="line">      invokeGuardedCallback(null, commitAllHostEffects, null);</span><br><span class="line">      if (hasCaughtError()) &#123;</span><br><span class="line">        didError = true;</span><br><span class="line">        error = clearCaughtError();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">      // 遍历effect list, commit 所有的 effect</span><br><span class="line">        commitAllHostEffects();</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        didError = true;</span><br><span class="line">        error = e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  stopCommitHostEffectsTimer();</span><br><span class="line"></span><br><span class="line">  resetAfterCommit();</span><br><span class="line"></span><br><span class="line">  // The work-in-progress tree is now the current tree. This must come after</span><br><span class="line">  // the first pass of the commit phase, so that the previous tree is still</span><br><span class="line">  // current during componentWillUnmount, but before the second pass, so that</span><br><span class="line">  // the finished work is current during componentDidMount/Update.</span><br><span class="line">  root.current = finishedWork;</span><br><span class="line"></span><br><span class="line">  // In the second pass we&apos;ll perform all life-cycles and ref callbacks.</span><br><span class="line">  // Life-cycles happen as a separate pass so that all placements, updates,</span><br><span class="line">  // and deletions in the entire tree have already been invoked.</span><br><span class="line">  // This pass also triggers any renderer-specific initial effects.</span><br><span class="line">  nextEffect = firstEffect;</span><br><span class="line">  startCommitLifeCyclesTimer();</span><br><span class="line">  while (nextEffect !== null) &#123;</span><br><span class="line">    let didError = false;</span><br><span class="line">    let error;</span><br><span class="line">    if (__DEV__) &#123;</span><br><span class="line">      invokeGuardedCallback(null, commitAllLifeCycles, null);</span><br><span class="line">      if (hasCaughtError()) &#123;</span><br><span class="line">        didError = true;</span><br><span class="line">        error = clearCaughtError();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">      // 遍历 effect list, commit 所有的生命周期, 就是执行 componentDidupdate之类的方法</span><br><span class="line">        commitAllLifeCycles();</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        didError = true;</span><br><span class="line">        error = e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (didError) &#123;</span><br><span class="line">      invariant(</span><br><span class="line">        nextEffect !== null,</span><br><span class="line">        &apos;Should have next effect. This error is likely caused by a bug &apos; +</span><br><span class="line">          &apos;in React. Please file an issue.&apos;,</span><br><span class="line">      );</span><br><span class="line">      captureError(nextEffect, error);</span><br><span class="line">      if (nextEffect !== null) &#123;</span><br><span class="line">        nextEffect = nextEffect.nextEffect;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isCommitting = false;</span><br><span class="line">  isWorking = false;</span><br><span class="line">  stopCommitLifeCyclesTimer();</span><br><span class="line">  stopCommitTimer();</span><br><span class="line">  const remainingTime = root.current.expirationTime;</span><br><span class="line"></span><br><span class="line">  if (remainingTime === NoWork) &#123;</span><br><span class="line">    capturedErrors = null;</span><br><span class="line">    failedBoundaries = null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return remainingTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>commitRoot 主要分为三步</p>
<ol>
<li>prepareForCommit() 调用HostConfig.prepareForCommit的方法, 生成待提交的dom属性变更</li>
<li>遍历effect list执行 commitAllHostEffects(), commit 所有的 effect,</li>
<li>遍历 effect list 执行 commitAllLifeCycles(), commit 所有的生命周期, 就是执行 componentDidupdate之类的方法</li>
</ol>
<h4 id="commitAllHostEffects"><a href="#commitAllHostEffects" class="headerlink" title="commitAllHostEffects"></a>commitAllHostEffects</h4><p>// 这个地方就是把所有的 effect都提交了,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">function commitAllHostEffects() &#123;</span><br><span class="line">  // 把所有的effect 都遍历一遍, 然后</span><br><span class="line">  while (nextEffect !== null) &#123;</span><br><span class="line">    if (__DEV__) &#123;</span><br><span class="line">      ReactDebugCurrentFiber.setCurrentFiber(nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line">    recordEffect();</span><br><span class="line"></span><br><span class="line">    const effectTag = nextEffect.effectTag;</span><br><span class="line">    if (effectTag &amp; ContentReset) &#123;</span><br><span class="line">      commitResetTextContent(nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (effectTag &amp; Ref) &#123;</span><br><span class="line">      const current = nextEffect.alternate;</span><br><span class="line">      if (current !== null) &#123;</span><br><span class="line">        commitDetachRef(current);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The following switch statement is only concerned about placement,</span><br><span class="line">    // updates, and deletions. To avoid needing to add a case for every</span><br><span class="line">    // possible bitmap value, we remove the secondary effects from the</span><br><span class="line">    // effect tag and switch on that value.</span><br><span class="line">    let primaryEffectTag =</span><br><span class="line">      effectTag &amp; ~(Callback | Err | ContentReset | Ref | PerformedWork);</span><br><span class="line">    switch (primaryEffectTag) &#123;</span><br><span class="line">      case Placement: &#123;</span><br><span class="line">        commitPlacement(nextEffect);</span><br><span class="line">        // Clear the &quot;placement&quot; from effect tag so that we know that this is inserted, before</span><br><span class="line">        // any life-cycles like componentDidMount gets called.</span><br><span class="line">        // TODO: findDOMNode doesn&apos;t rely on this any more but isMounted</span><br><span class="line">        // does and isMounted is deprecated anyway so we should be able</span><br><span class="line">        // to kill this.</span><br><span class="line">        nextEffect.effectTag &amp;= ~Placement;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      case PlacementAndUpdate: &#123;</span><br><span class="line">        // Placement</span><br><span class="line">        commitPlacement(nextEffect);</span><br><span class="line">        // Clear the &quot;placement&quot; from effect tag so that we know that this is inserted, before</span><br><span class="line">        // any life-cycles like componentDidMount gets called.</span><br><span class="line">        nextEffect.effectTag &amp;= ~Placement;</span><br><span class="line"></span><br><span class="line">        // Update</span><br><span class="line">        const current = nextEffect.alternate;</span><br><span class="line">        commitWork(current, nextEffect);</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      case Update: &#123;</span><br><span class="line">        const current = nextEffect.alternate;</span><br><span class="line">        commitWork(current, nextEffect);</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      case Deletion: &#123;</span><br><span class="line">        isUnmounting = true;</span><br><span class="line">        commitDeletion(nextEffect);</span><br><span class="line">        isUnmounting = false;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nextEffect = nextEffect.nextEffect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="commitWork"><a href="#commitWork" class="headerlink" title="commitWork"></a>commitWork</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">function commitWork(current: Fiber | null, finishedWork: Fiber): void &#123;</span><br><span class="line">  switch (finishedWork.tag) &#123;</span><br><span class="line">    case ClassComponent: &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    case HostComponent: &#123;</span><br><span class="line">      const instance: I = finishedWork.stateNode;</span><br><span class="line">      if (instance != null) &#123;</span><br><span class="line">        // Commit the work prepared earlier.</span><br><span class="line">        const newProps = finishedWork.memoizedProps;</span><br><span class="line">        // For hydration we reuse the update path but we treat the oldProps</span><br><span class="line">        // as the newProps. The updatePayload will contain the real change in</span><br><span class="line">        // this case.</span><br><span class="line">        const oldProps = current !== null ? current.memoizedProps : newProps;</span><br><span class="line">        const type = finishedWork.type;</span><br><span class="line">        // TODO: Type the updateQueue to be specific to host components.</span><br><span class="line">        const updatePayload: null | PL = (finishedWork.updateQueue: any);</span><br><span class="line">        finishedWork.updateQueue = null;</span><br><span class="line">        if (updatePayload !== null) &#123;</span><br><span class="line">          commitUpdate(</span><br><span class="line">            instance,</span><br><span class="line">            updatePayload,</span><br><span class="line">            type,</span><br><span class="line">            oldProps,</span><br><span class="line">            newProps,</span><br><span class="line">            finishedWork,</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    case HostText: &#123;</span><br><span class="line">      invariant(</span><br><span class="line">        finishedWork.stateNode !== null,</span><br><span class="line">        &apos;This should have a text node initialized. This error is likely &apos; +</span><br><span class="line">          &apos;caused by a bug in React. Please file an issue.&apos;,</span><br><span class="line">      );</span><br><span class="line">      const textInstance: TI = finishedWork.stateNode;</span><br><span class="line">      const newText: string = finishedWork.memoizedProps;</span><br><span class="line">      // For hydration we reuse the update path but we treat the oldProps</span><br><span class="line">      // as the newProps. The updatePayload will contain the real change in</span><br><span class="line">      // this case.</span><br><span class="line">      const oldText: string =</span><br><span class="line">        current !== null ? current.memoizedProps : newText;</span><br><span class="line">      commitTextUpdate(textInstance, oldText, newText);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    case HostRoot: &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    default: &#123;</span><br><span class="line">      invariant(</span><br><span class="line">        false,</span><br><span class="line">        &apos;This unit of work tag should not have side-effects. This error is &apos; +</span><br><span class="line">          &apos;likely caused by a bug in React. Please file an issue.&apos;,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清空当前fiber的 updateQueue<br>根据tag选择HostConfig中的 相关的 commit 方法, 比如当 tag = HostComponent , 调用 commitUpdate方法, 提交dom更新</p>
<h4 id="commitAllLifeCycles"><a href="#commitAllLifeCycles" class="headerlink" title="commitAllLifeCycles"></a>commitAllLifeCycles</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function commitAllLifeCycles() &#123;</span><br><span class="line">  while (nextEffect !== null) &#123;</span><br><span class="line">    const effectTag = nextEffect.effectTag;</span><br><span class="line"></span><br><span class="line">    if (effectTag &amp; (Update | Callback)) &#123;</span><br><span class="line">      recordEffect();</span><br><span class="line">      const current = nextEffect.alternate;</span><br><span class="line">      commitLifeCycles(current, nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (effectTag &amp; Ref) &#123;</span><br><span class="line">      recordEffect();</span><br><span class="line">      commitAttachRef(nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (effectTag &amp; Err) &#123;</span><br><span class="line">      recordEffect();</span><br><span class="line">      commitErrorHandling(nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const next = nextEffect.nextEffect;</span><br><span class="line">    // Ensure that we clean these up so that we don&apos;t accidentally keep them.</span><br><span class="line">    // I&apos;m not actually sure this matters because we can&apos;t reset firstEffect</span><br><span class="line">    // and lastEffect since they&apos;re on every node, not just the effectful</span><br><span class="line">    // ones. So we have to clean everything as we reuse nodes anyway.</span><br><span class="line">    nextEffect.nextEffect = null;</span><br><span class="line">    // Ensure that we reset the effectTag here so that we can rely on effect</span><br><span class="line">    // tags to reason about the current life-cycle.</span><br><span class="line">    nextEffect = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个循环遍历 effect-list, 调用 commitLifeCycles 来触发相关的钩子函数</p>
<h4 id="commitLifeCycles"><a href="#commitLifeCycles" class="headerlink" title="commitLifeCycles"></a>commitLifeCycles</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">function commitLifeCycles(current: Fiber | null, finishedWork: Fiber): void &#123;</span><br><span class="line">  switch (finishedWork.tag) &#123;</span><br><span class="line">    case ClassComponent: &#123;</span><br><span class="line">      const instance = finishedWork.stateNode;</span><br><span class="line">      if (finishedWork.effectTag &amp; Update) &#123;</span><br><span class="line">        if (current === null) &#123;</span><br><span class="line">          startPhaseTimer(finishedWork, &apos;componentDidMount&apos;);</span><br><span class="line">          instance.props = finishedWork.memoizedProps;</span><br><span class="line">          instance.state = finishedWork.memoizedState;</span><br><span class="line">          instance.componentDidMount();</span><br><span class="line">          stopPhaseTimer();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          const prevProps = current.memoizedProps;</span><br><span class="line">          const prevState = current.memoizedState;</span><br><span class="line">          startPhaseTimer(finishedWork, &apos;componentDidUpdate&apos;);</span><br><span class="line">          instance.props = finishedWork.memoizedProps;</span><br><span class="line">          instance.state = finishedWork.memoizedState;</span><br><span class="line">          instance.componentDidUpdate(prevProps, prevState);</span><br><span class="line">          stopPhaseTimer();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      const updateQueue = finishedWork.updateQueue;</span><br><span class="line">      if (updateQueue !== null) &#123;</span><br><span class="line">        commitCallbacks(updateQueue, instance);</span><br><span class="line">      &#125;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    case HostRoot: &#123;</span><br><span class="line">      const updateQueue = finishedWork.updateQueue;</span><br><span class="line">      if (updateQueue !== null) &#123;</span><br><span class="line">        const instance =</span><br><span class="line">          finishedWork.child !== null ? finishedWork.child.stateNode : null;</span><br><span class="line">        commitCallbacks(updateQueue, instance);</span><br><span class="line">      &#125;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    case HostComponent: &#123;</span><br><span class="line">      const instance: I = finishedWork.stateNode;</span><br><span class="line"></span><br><span class="line">      // Renderers may schedule work to be done after host components are mounted</span><br><span class="line">      // (eg DOM renderer may schedule auto-focus for inputs and form controls).</span><br><span class="line">      // These effects should only be committed when components are first mounted,</span><br><span class="line">      // aka when there is no current/alternate.</span><br><span class="line">      if (current === null &amp;&amp; finishedWork.effectTag &amp; Update) &#123;</span><br><span class="line">        const type = finishedWork.type;</span><br><span class="line">        const props = finishedWork.memoizedProps;</span><br><span class="line">        commitMount(instance, type, props, finishedWork);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    case HostText: &#123;</span><br><span class="line">      // We have no life-cycles associated with text.</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    case HostPortal: &#123;</span><br><span class="line">      // We have no life-cycles associated with portals.</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    default: &#123;</span><br><span class="line">      invariant(</span><br><span class="line">        false,</span><br><span class="line">        &apos;This unit of work tag should not have side-effects. This error is &apos; +</span><br><span class="line">          &apos;likely caused by a bug in React. Please file an issue.&apos;,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要就是根据不同的fiber.tag 来处理组件生命周期<br>比如当tag=ClassComponent的时候,  把当前fiber中缓存的 props state赋值给组件实例, 并且调用componentDidUpdate钩子函数来完成一次组件更新</p>
<h1 id="回顾问题"><a href="#回顾问题" class="headerlink" title="回顾问题"></a>回顾问题</h1><p>让我们来看看有没有解决最开始思考的问题</p>
<ol>
<li><a href="#React-Reconciler">Fiber</a>引擎是什么, 它的原理是怎么样的: <a href="#React-Reconciler">Fiber</a></li>
<li>functionComponent的实现:   <a href="#updateFunctionalComponent">updateFunctionalComponent</a></li>
<li>新特性中的 render 中return array是怎么实现的:  <a href="#reconcileChildFibers">reconcileChildFibers</a></li>
<li>Fragment 实现  <a href="#beginWork">beginWork</a> -&gt; react/packages/react-reconciler/src/ReactFiberBeginWork.js -&gt; updateFragment</li>
<li>virtual dom在 react中具体是以一个什么样的方式存在:  <a href="#reconcileChildrenArray">reconcileChildrenArray</a></li>
</ol>
<p>在阅读的过程中, 也思考了新的问题:</p>
<ol>
<li>调度器怎么样找到下一个要执行的事务单元?</li>
<li>优先级怎么设置的?</li>
<li>调度器怎么样知道什么时候暂停和继续事务?</li>
<li>事务是怎么执行和标记为完成的? (事务分为两个步骤, begin complete,complete操作可以延期执行)</li>
<li>生命周期是怎么样被调用的?</li>
</ol>
<p>返回到 <a href="#导航">导航</a>, 再看一遍框架图, 可能会有不一样的感觉吧!</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>对于React16的Fiber引擎分析到这里的结束了, 手动撒花!!!!</p>
<p>当前文章的代码解读是基于 17年11月28发布的 React 16.2,因为时间和个人经验有限, 难免有理解错误或者不足的地方, 希望多多指正.</p>
<hr>
<p>鉴于当前文章篇幅过长, 后续还将继续分析React-Dom相关的, 这一块主要就是 renderer的的工作</p>
<ul>
<li>React-Dom/events</li>
<li>React-Dom/client</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/react/" rel="tag"># react</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/08/13/tech/一个NodeJS多进程共享内存,高性能,文件存储,轻量KV数据库/" rel="next" title="一个NodeJS多进程共享内存,高性能,文件存储,轻量KV数据库">
                <i class="fa fa-chevron-left"></i> 一个NodeJS多进程共享内存,高性能,文件存储,轻量KV数据库
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/07/tech/Node异步解决方案-co与async:await/" rel="prev" title="Node异步解决方案-co与async">
                Node异步解决方案-co与async <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatars.png"
                alt="laynezhou" />
            
              <p class="site-author-name" itemprop="name">laynezhou</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/outshineamaze/" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#React16-的新特性"><span class="nav-number">2.</span> <span class="nav-text">React16 的新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#支持在html元素中传入-自定义属性"><span class="nav-number">2.1.</span> <span class="nav-text">支持在html元素中传入 自定义属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#允许在render函数中返回节点数组-字符串"><span class="nav-number">2.2.</span> <span class="nav-text">允许在render函数中返回节点数组,字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#支持了-Fragment-标签"><span class="nav-number">2.3.</span> <span class="nav-text">支持了 Fragment 标签</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Portals"><span class="nav-number">2.4.</span> <span class="nav-text">Portals</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#采用新的底层架构-Fiber"><span class="nav-number">2.5.</span> <span class="nav-text">采用新的底层架构 Fiber</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#准备阶段"><span class="nav-number">3.</span> <span class="nav-text">准备阶段</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#导航"><span class="nav-number">4.</span> <span class="nav-text">导航</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#源码快速导航"><span class="nav-number">4.0.1.</span> <span class="nav-text">源码快速导航</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Component"><span class="nav-number">4.0.1.1.</span> <span class="nav-text">Component:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#performWork"><span class="nav-number">4.0.1.2.</span> <span class="nav-text">performWork:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Commit"><span class="nav-number">4.0.1.3.</span> <span class="nav-text">Commit:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LifeCycles"><span class="nav-number">4.0.1.4.</span> <span class="nav-text">LifeCycles:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#workLoop"><span class="nav-number">4.0.1.5.</span> <span class="nav-text">workLoop:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DSL"><span class="nav-number">4.0.2.</span> <span class="nav-text">DSL</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#源码阅读"><span class="nav-number">5.</span> <span class="nav-text">源码阅读</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#React"><span class="nav-number">5.1.</span> <span class="nav-text">React</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#React-createElement-对象创建"><span class="nav-number">5.1.1.</span> <span class="nav-text">React.createElement 对象创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React-Children"><span class="nav-number">5.1.2.</span> <span class="nav-text">React.Children</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Component-1"><span class="nav-number">5.1.3.</span> <span class="nav-text">Component</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fiber"><span class="nav-number">5.2.</span> <span class="nav-text">Fiber</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ReactDOM-render"><span class="nav-number">5.2.0.1.</span> <span class="nav-text">ReactDOM.render</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DOMRenderer"><span class="nav-number">5.2.0.2.</span> <span class="nav-text">DOMRenderer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React-Reconciler"><span class="nav-number">5.2.1.</span> <span class="nav-text">React-Reconciler</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础的概念"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">基础的概念:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#协调算法-reconciliation"><span class="nav-number">5.2.1.2.</span> <span class="nav-text">协调算法(reconciliation)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调度-scheduling"><span class="nav-number">5.2.1.3.</span> <span class="nav-text">调度(scheduling)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReactFiberReconciler"><span class="nav-number">5.2.1.4.</span> <span class="nav-text">ReactFiberReconciler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#updateContainerAtExpirationTime"><span class="nav-number">5.2.1.5.</span> <span class="nav-text">updateContainerAtExpirationTime</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#scheduleRootUpdate"><span class="nav-number">5.2.1.6.</span> <span class="nav-text">scheduleRootUpdate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#typeFiber"><span class="nav-number">5.2.1.7.</span> <span class="nav-text">typeFiber</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#insertUpdateIntoFiber"><span class="nav-number">5.2.1.8.</span> <span class="nav-text">insertUpdateIntoFiber</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#scheduleWorkImpl"><span class="nav-number">5.2.1.9.</span> <span class="nav-text">scheduleWorkImpl</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#requestWork"><span class="nav-number">5.2.1.10.</span> <span class="nav-text">requestWork</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#performWorkOnRoot"><span class="nav-number">5.2.1.11.</span> <span class="nav-text">performWorkOnRoot</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#renderRoot"><span class="nav-number">5.2.1.12.</span> <span class="nav-text">renderRoot</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#workLoop-1"><span class="nav-number">5.2.1.13.</span> <span class="nav-text">workLoop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#performUnitOfWork"><span class="nav-number">5.2.1.14.</span> <span class="nav-text">performUnitOfWork</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#beginWork"><span class="nav-number">5.2.1.15.</span> <span class="nav-text">beginWork</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#updateClassComponent"><span class="nav-number">5.2.1.16.</span> <span class="nav-text">updateClassComponent</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#updateClassInstance"><span class="nav-number">5.2.1.17.</span> <span class="nav-text">updateClassInstance</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#updateFunctionalComponent"><span class="nav-number">5.2.1.17.1.</span> <span class="nav-text">updateFunctionalComponent</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#finishClassComponent"><span class="nav-number">5.2.1.18.</span> <span class="nav-text">finishClassComponent</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reconcileChildrenAtExpirationTime"><span class="nav-number">5.2.1.19.</span> <span class="nav-text">reconcileChildrenAtExpirationTime</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reconcileChildFibers"><span class="nav-number">5.2.1.20.</span> <span class="nav-text">reconcileChildFibers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reconcileChildrenArray"><span class="nav-number">5.2.1.21.</span> <span class="nav-text">reconcileChildrenArray</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#completeUnitOfWork"><span class="nav-number">5.2.1.22.</span> <span class="nav-text">completeUnitOfWork</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#completeWork"><span class="nav-number">5.2.1.23.</span> <span class="nav-text">completeWork</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#updateHostComponent"><span class="nav-number">5.2.1.24.</span> <span class="nav-text">updateHostComponent</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#completeRoot"><span class="nav-number">5.2.1.25.</span> <span class="nav-text">completeRoot</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#commitRoot"><span class="nav-number">5.2.1.26.</span> <span class="nav-text">commitRoot</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#commitAllHostEffects"><span class="nav-number">5.2.1.27.</span> <span class="nav-text">commitAllHostEffects</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#commitWork"><span class="nav-number">5.2.1.28.</span> <span class="nav-text">commitWork</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#commitAllLifeCycles"><span class="nav-number">5.2.1.29.</span> <span class="nav-text">commitAllLifeCycles</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#commitLifeCycles"><span class="nav-number">5.2.1.30.</span> <span class="nav-text">commitLifeCycles</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#回顾问题"><span class="nav-number">6.</span> <span class="nav-text">回顾问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#结束"><span class="nav-number">7.</span> <span class="nav-text">结束</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">laynezhou</span>

  
</div>









        


<script>
  	var _mtac = {};
  	(function() {
  		var mta = document.createElement("script");
  		mta.src = "https://pingjs.qq.com/h5/stats.js?v2.0.4";
  		mta.setAttribute("name", "MTAH5");
  		mta.setAttribute("sid", "500669000");

  		var s = document.getElementsByTagName("script")[0];
  		s.parentNode.insertBefore(mta, s);
  	})();
</script>






        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: '0F7x1H9pH7A0VAKal3LN5idj-gzGzoHsz',
        appKey: 'Czers2Dz1pcKcHPko0BT2mcj',
        placeholder: '写的不对的地方请多多指教',
        avatar:'identicon',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.json";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
