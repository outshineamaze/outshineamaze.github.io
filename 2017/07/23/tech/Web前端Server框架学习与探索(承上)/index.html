<!DOCTYPE html>




<html class="theme-next pisces" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<link rel="manifest" href="/manifest.json">








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="nodejs," />










<meta name="description" content="前言最近开始接触到公司内部的一个 nodejs 的框架 TSW, 也看了很多内部论坛是上关于 tsw 文章 , 在学习开发使用的过程中, 也对部分技术框架的设计存有疑惑.但是, 就目前 tsw 在公司内部大范围的使用的情况来说, 接入完善的公司内部业务模块以及与走织云发布流程, 在使用上很好的承担了许多业务. 由于个人的兴趣爱好,在业余的时间也打算研究一下如何去实现一个类似的框架以及开发流程, 本">
<meta name="keywords" content="nodejs">
<meta property="og:type" content="article">
<meta property="og:title" content="Web前端Server框架学习与探索">
<meta property="og:url" content="https://outshineamaze.github.io/2017/07/23/tech/Web前端Server框架学习与探索(承上)/index.html">
<meta property="og:site_name" content="Outshine Amaze">
<meta property="og:description" content="前言最近开始接触到公司内部的一个 nodejs 的框架 TSW, 也看了很多内部论坛是上关于 tsw 文章 , 在学习开发使用的过程中, 也对部分技术框架的设计存有疑惑.但是, 就目前 tsw 在公司内部大范围的使用的情况来说, 接入完善的公司内部业务模块以及与走织云发布流程, 在使用上很好的承担了许多业务. 由于个人的兴趣爱好,在业余的时间也打算研究一下如何去实现一个类似的框架以及开发流程, 本">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-05-06T16:31:55.698Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Web前端Server框架学习与探索">
<meta name="twitter:description" content="前言最近开始接触到公司内部的一个 nodejs 的框架 TSW, 也看了很多内部论坛是上关于 tsw 文章 , 在学习开发使用的过程中, 也对部分技术框架的设计存有疑惑.但是, 就目前 tsw 在公司内部大范围的使用的情况来说, 接入完善的公司内部业务模块以及与走织云发布流程, 在使用上很好的承担了许多业务. 由于个人的兴趣爱好,在业余的时间也打算研究一下如何去实现一个类似的框架以及开发流程, 本">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://outshineamaze.github.io/2017/07/23/tech/Web前端Server框架学习与探索(承上)/"/>





  <title>Web前端Server框架学习与探索 | Outshine Amaze</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Outshine Amaze</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">专注技术， 热爱生活</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-主页">
          <a href="/" rel="section">
            
            主页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-simulay">
          <a href="https://outshineamaze.github.io/simulay/" rel="section">
            
            Simulay
          </a>
        </li>
      
        
        <li class="menu-item menu-item-iotshine">
          <a href="https://outshineamaze.github.io/iotshine/" rel="section">
            
            Iotshine
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://outshineamaze.github.io/2017/07/23/tech/Web前端Server框架学习与探索(承上)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="laynezhou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatars.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Outshine Amaze">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Web前端Server框架学习与探索</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-23T00:00:00+08:00">
                2017-07-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Nodejs/" itemprop="url" rel="index">
                    <span itemprop="name">Nodejs</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/23/tech/Web前端Server框架学习与探索(承上)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2017/07/23/tech/Web前端Server框架学习与探索(承上)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近开始接触到公司内部的一个 nodejs 的框架 TSW, 也看了很多内部论坛是上关于 tsw 文章 , 在学习开发使用的过程中, 也对部分技术框架的设计存有疑惑.<br>但是, 就目前 tsw 在公司内部大范围的使用的情况来说, 接入完善的公司内部业务模块以及与走织云发布流程, 在使用上很好的承担了许多业务.</p>
<p>由于个人的兴趣爱好,在业余的时间也打算研究一下如何去实现一个类似的框架以及开发流程, 本系列文章也算是自我学习的一个记录,加深理解.</p>
<p>此次文章打算分上下两篇:</p>
<p>上篇: 主要介绍如何去实现一个类似 tsw 的集合开发运维一条龙服务的框架.<br>下篇: 尝试一下开发运维模式–node与服务容器化</p>
<p>友情链接:   tswjs.org, tsw 的官网的文档还是写的挺幽默风趣的,就是内容比较少, 需要大家边用边摸索<br><a id="more"></a></p>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理:"></a>进程管理:</h2><p>大部分的 node 程序都是通过 forever 或者 pm2之类的 Node应用的进程管理器来启动并且服务维护,<br>使用这类工具可以使node服务在后台运行（类似于linux的nohup），另外它们可以在服务因异常或其他原因被杀掉后进行自动重启。 由于Node的单线程特征，自动重启能很大程度上的提高它的健壮性。<br>NodeJS是单线程的工作方式，如何利用好 cpu 的多核也是开发者刚刚入门会遇到的问题之一。其实，NodeJS很早就支持了Cluster模式，这个就是同时开启多个进程来监听同一个端口，分发http请求处理，这里大家也许有疑问，如何合理的分发请求到给个子进程， 后面会提到…</p>
<p>###最原始的 cgi</p>
<p>每个请求，都需要经过启动进程、处理请求、结束进程三个步骤，对服务器的资源占用较大, 容易导致性能下降系统不稳定</p>
<h3 id="FastCGI-协议"><a href="#FastCGI-协议" class="headerlink" title="FastCGI 协议"></a>FastCGI 协议</h3><p> FastCGI 协议让解释程序常驻在内存中, 不需要为每个请求都 fork 一个进程, 极大的提高了系统稳定性和资源的合理利用, 在这个基础上, FastCGI 也被设计为多进程调度的模式</p>
<p>这个过程同样可以描述为三个步骤：</p>
<ol>
<li>初始化 FastCGI 进程管理器，并启动多个 CGI 解释器子进程；</li>
<li>当请求到达 Web 服务器时，进程管理器选择并连接一个子进程，将环境变量和标准输入发送给它</li>
<li>处理完成后将标准输出和错误信息返还给 Web 服务器</li>
<li>子进程关闭连接，继续等待下一个请求的到来</li>
</ol>
<p>关于 cgi 和 fastcgi 之间的技术细节对比可以参考该文章: <a href="http://www.awaimai.com/371.html" target="_blank" rel="noopener">http://www.awaimai.com/371.html</a> , 不在这里过多的阐述  </p>
<h2 id="nodeJs-的child-process-和-cluster"><a href="#nodeJs-的child-process-和-cluster" class="headerlink" title="nodeJs 的child_process 和 cluster"></a>nodeJs 的child_process 和 cluster</h2><p>nodeJS 的单线程的模型决定了 node 原生只能利用单核的 cpu , 如果线程崩溃之后, 整个 web 程序都会崩溃, 和传统的原始 cgi 一样面临 稳定性差的问题, 不适合大规模的生产环境的使用<br>为了解决整个问题, nodejs 自带 child_process 模块和 cluster 模块, 后者是对前者的一个更好的封装</p>
<p>child_process.fork()或者  cluster.fork() ,  衍生一个新的 Node.js 进程，并通过建立一个 IPC 通讯通道来调用一个指定的模块，该通道允许父进程与子进程之间相互发送信息。通过 fork 方法可以衍生任意多个同样的的 node.js 进程, 可以充分的利用好 cpu 的多核性能.看到这里, 我们是不是就会想如果通过 fork 功能, 是不是就实现一个类似 FastCGI 的协议了, master 进程负责监听端口, 接收到新的请求之后负责分发给多个工作进程,<br>这里有两种连接分发的模式:</p>
<p>模式一: 主进程创建监听socket后发送给感兴趣的工作进程，由工作进程负责直接接收连接:</p>
<p>master 进程出创建socket, 绑定到 ip 和端口之后,  本身并不会调用 listen 和 accept 方法去建立连接, 而是将 socket 的 fd(文件描述符)传递到 fork 出来的work子进程中, work 进程负责监听新的连接, 然后执行业务代码. </p>
<p>然而这种模式主要有两个问题,<br>多个进程之间会 竞争 accept 一个连接,  容易导致 “惊群现象”(linux 内核2.6以上已经不会出现这个情况了) 惊群现象:  <a href="http://blog.csdn.net/russell_tao/article/details/7204260" target="_blank" rel="noopener">http://blog.csdn.net/russell_tao/article/details/7204260</a><br>不能够确定哪个进程来处理新的连接, 完全是由系统自动分配, 对于开发者来说是不可控的, 容易导致各个 work 进程负载不均衡.</p>
<p>模式二: 循环法。由主进程负责监听端口，接收新连接后再将连接循环分发给工作进程<br>有一种基于round-robin 算法的模型,<br>master 进程创建socket,  绑定地址端口, 同时负责监听<br>当获取到新的连接之后(调用 accept 方法与客户端建立 tcp 连接), 再将这个连接分发到指定的 worker 进程, 这里如何分发到指定的 worker 进程是可控的, 这里使用了 round-robin 算法, 当然还有其他的算法也可以用于请求的分发.</p>
<p>所以我们在一般的生产环境中都是使用模式二来出处理连接的分发</p>
<p>demo1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 以下的例子使用 socket 举例是为让大家更好的了解 连接 是如何分发的</span><br><span class="line">const cluster = require(&apos;cluster&apos;);</span><br><span class="line">const net = require(&apos;net&apos;);</span><br><span class="line">const numCPUs = require(&apos;os&apos;).cpus().length;</span><br><span class="line"></span><br><span class="line">if (cluster.isMaster) &#123;</span><br><span class="line">  console.log(`主进程 $&#123;process.pid&#125; 正在运行`);</span><br><span class="line"></span><br><span class="line">  // 衍生工作进程。</span><br><span class="line">  for (let i = 0; i &lt; numCPUs; i++) &#123;</span><br><span class="line">    cluster.fork();</span><br><span class="line">  &#125;</span><br><span class="line">  cluster.on(&apos;exit&apos;, (worker, code, signal) =&gt; &#123;</span><br><span class="line">    console.log(`工作进程 $&#123;worker.process.pid&#125; 已退出`);</span><br><span class="line">  &#125;);</span><br><span class="line">  let handle = net._createServerHandle(&apos;0.0.0.0&apos;, 3000);</span><br><span class="line">  handle.listen();</span><br><span class="line">  handle.onconnection = function (err,handle) &#123;</span><br><span class="line">    var worker = workers.pop();</span><br><span class="line">    worker.send(&#123;&#125;,handle);</span><br><span class="line">    workers.unshift(worker);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  process.on(&apos;message&apos;, function (m, handle) &#123;</span><br><span class="line">    let buf = &apos;worker process&apos;;</span><br><span class="line">    let res = [&apos;HTTP/1.1 200 OK&apos;,&apos;content-length:&apos;+buf.length].join(&apos;\r\n&apos;)+&apos;\r\n\r\n&apos;+buf;</span><br><span class="line">  console.log(&apos;got a connection on worker, pid = %d&apos;, process.pid);</span><br><span class="line">    let socket = new net.Socket(&#123;</span><br><span class="line">        handle: handle</span><br><span class="line">    &#125;);</span><br><span class="line">    socket.readable = socket.writable = true;</span><br><span class="line">    socket.end(res);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>demo2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const cluster = require(&apos;cluster&apos;);</span><br><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line">const numCPUs = require(&apos;os&apos;).cpus().length;</span><br><span class="line"></span><br><span class="line">if (cluster.isMaster) &#123;</span><br><span class="line">  console.log(`主进程 $&#123;process.pid&#125; 正在运行`);</span><br><span class="line">  // 衍生工作进程。</span><br><span class="line">  for (let i = 0; i &lt; numCPUs; i++) &#123;</span><br><span class="line">    cluster.fork();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 工作进程可以共享任何 TCP 连接。</span><br><span class="line">  // 在本例子中，虽然表面上创建了多个 http 服务, 但是本质上共享的是一个 HTTP 服务器。</span><br><span class="line">  http.createServer((req, res) =&gt; &#123;</span><br><span class="line">    res.writeHead(200);</span><br><span class="line">    res.end(&apos;helloworld\n&apos;);</span><br><span class="line">  &#125;).listen(8000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>跑下 demo2, 可以发现<br>分配给 master 进程和 worker 进程的 device(内核地址)都不一样,  说明各个进程都有自己的 socket, 并且只有一个master 进程在处于 listening 状态, 说明只有 master 进程负责监听8000的端口, worker 进程的 tcp 状态都是 Established, 说明master 把Established状态的连接分配给多个 worker 进程,  worker进程不需关心建立 socket 连接, 只需要处理业务和 连接的 io 操作(比如往连接中写数据),通过上述的分析也验证了cluster 确实是使用模式二来进行连接分发的. 而且从结果来看 round-robin 的调度策略还是可以很好的负载均衡的.</p>
<p>特殊情况: socket.io 可以使用 ip hash, master 进程只把同源 ip 的连接分配给同一个 worker 进程就行了 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">if (cluster.isMaster) &#123;</span><br><span class="line">    // ip hash</span><br><span class="line">    var worker_index = function(ip, len) &#123;</span><br><span class="line">        var s = &apos;&apos;;</span><br><span class="line">        for (var i = 0, _len = ip.length; i &lt; _len; i++) &#123;</span><br><span class="line">            if (!isNaN(ip[i])) &#123;</span><br><span class="line">                s += ip[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return Number(s) % len;</span><br><span class="line">    &#125;;</span><br><span class="line">    var server = net.createServer(&#123; pauseOnConnect: true &#125;, function(connection) &#123;</span><br><span class="line">        var worker = workers[worker_index(connection.remoteAddress, num_processes)];</span><br><span class="line">        worker.send(&apos;sticky-session:connection&apos;, connection);</span><br><span class="line">    &#125;).listen(port);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的实践有多种方式,可以参考该篇文章 <a href="https://segmentfault.com/a/1190000009622158" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009622158</a></p>
<p><a href="http://upload-images.jianshu.io/upload_images/332289-af4940f6779a796c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener">http://upload-images.jianshu.io/upload_images/332289-af4940f6779a796c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240</a></p>
<h3 id="进程守护"><a href="#进程守护" class="headerlink" title="进程守护"></a>进程守护</h3><p>message 事件是 master 与 worker 之间的通信桥梁, 也是进程守护的一个基础, 当工作子进程因为未处理异常而崩溃时,  master 进程监听 exit 和 disconnect 事件 然后重新fork 新的子进程, 同时也可以利用这个机制来进行热重启.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 监控进程退出事件,  看情况决定是否重新 fork 进程</span><br><span class="line">cluster.on(&apos;exit&apos;, function (worker, code, signal) &#123;</span><br><span class="line">    if (worker.exitedAfterDisconnect === true) &#123;</span><br><span class="line">        console.log(&apos;Oh, it was just voluntary – no need to worry&apos;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        clsuter.fork();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// disconnect 事件: worker 进程可以通过调用 process.disconnect() 方法主动断开与 master 的ipc 管道连接,  可以设置 worker.exitedAfterDisconnect 来区分自发退出还是被动退出，主进程可以根据这个值决定是否重新衍生新的工作进程</span><br><span class="line">cluster.on(&apos;disconnect&apos;, function () &#123;</span><br><span class="line">    clsuter.fork();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>在 nodejs 的 child process 模块中, 运行通过 child.send()方法向子进程发送发送消息, 子进程也可以通过 process.send()向父进程发送消息,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 使用进程之间的通信很简单, 比如下面</span><br><span class="line">// 父进程:</span><br><span class="line">if (cluster.isMaster) &#123;</span><br><span class="line">    cluster.on(&apos;message&apos;, (worker, message, handle) =&gt; &#123;</span><br><span class="line">        worker.send(message);</span><br><span class="line">        // ...</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; else if(cluster.isWorker)&#123;</span><br><span class="line">    // 子进程</span><br><span class="line">    process.send(&#123; foo: &apos;bar&apos; &#125;);</span><br><span class="line">    process.on(&apos;message&apos;, (msg) =&gt; &#123;</span><br><span class="line">    process.send(msg);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于 ipc(Inter-Process Communication, 进程间通信) 全双工双向通信的方案:socketpair , 了解更多可以参考如下<br><a href="https://www.ibm.com/developerworks/cn/linux/l-pipebid/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-pipebid/index.html</a><br><a href="http://www.cnblogs.com/keepsimple/archive/2013/05/20/3088248.html" target="_blank" rel="noopener">http://www.cnblogs.com/keepsimple/archive/2013/05/20/3088248.html</a></p>
<p>关于 node 的进程管理可以暂时告一段落, 看到这里,就是可以自己实现一个简单的版本PM2 的 node 进程管理程序,获取更加激进一点去做一个负载均衡的 node 多进程服务器了</p>
<h2 id="应用层接入"><a href="#应用层接入" class="headerlink" title="应用层接入"></a>应用层接入</h2><p>前面一节我们认识到了 node 的进程管理, 也知道怎么样去做一个多进程模型的服务器了, 那么现在tcp 的连接有了, 该上升到 http 的应用层了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let server = http.createServer(app).listen(port);</span><br><span class="line"></span><br><span class="line">// app 就是应用层的入口了, </span><br><span class="line">consot app = (request, response) =&gt; &#123;</span><br><span class="line">    response.writeHead(200, &#123;</span><br><span class="line">        &quot;Content-Type&quot;: &quot;text/plain&quot;    </span><br><span class="line">    &#125;);</span><br><span class="line">    response.end(&quot;Hello world!\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在市面上大部分的框架也所做的工作其实都在扩展这个 app 函数的功能, 主要分为以下几个部分</p>
<h3 id="request-response-增强"><a href="#request-response-增强" class="headerlink" title="request response 增强:"></a>request response 增强:</h3><p>这里需要做两件事:</p>
<pre><code>1. 扩展了Node的http.IncomingMessage对象，提供了一个稳健的对象请求。
2. 扩展了Node的http.ServerReponse对象，提供响应对象。
</code></pre><p>###路由:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 一个很丑陋但是很基础的路由</span><br><span class="line">consot app = (request, response) =&gt; &#123;</span><br><span class="line">    if(request.url == &apos;/&apos;)&#123;</span><br><span class="line">    response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);</span><br><span class="line">    response.end(&quot;Home Page!\n&quot;);</span><br><span class="line">  &#125; else if(request.url == &apos;/about&apos;)&#123;</span><br><span class="line">    response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);</span><br><span class="line">    response.end(&quot;About Page!\n&quot;);</span><br><span class="line">  &#125; else&#123;</span><br><span class="line">    response.writeHead(404, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);</span><br><span class="line">    response.end(&quot;404 Not Found!\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>显然在实际的生产中是不会这样子写路由的,  常规的做法是把路由抽象出来变成路由的配置, 然后调用对应的处理函数, 当然看完下面中间件模块之后, 我们将会有一个思维上面的飞跃…</p>
<p>###中间件:<br>中间件描述 <a href="https://stephensugden.com/middleware_guide/" target="_blank" rel="noopener">https://stephensugden.com/middleware_guide/</a><br>下面以 express 框架为例, 实现一个简化版本的中间件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 中间件本身是一个函数</span><br><span class="line">function middleware(req,res,next)&#123;</span><br><span class="line">    // do something;</span><br><span class="line">    // 做完后调用下一个函数</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line">function express() &#123;</span><br><span class="line">    var funcs = []; // 待执行的函数数组, 这里可以拓展 funcs 为多层级对象,</span><br><span class="line">                    //可以借用中间件来实现路由的功能.</span><br><span class="line">    var app = function (req, res) &#123;</span><br><span class="line">        var i = 0;</span><br><span class="line">        function next() &#123;</span><br><span class="line">            var task = funcs[i++];  // 取出函数数组里的下一个函数</span><br><span class="line">            if (!task) &#123;    // 如果函数不存在,return</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            task(req, res, next);   // 否则,执行下一个函数</span><br><span class="line">        &#125;</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * use方法就是把函数添加到函数数组中</span><br><span class="line">     * @param task</span><br><span class="line">     */</span><br><span class="line">    app.use = function (task) &#123;</span><br><span class="line">        funcs.push(task);</span><br><span class="line">    &#125;</span><br><span class="line">    return app;    // 返回实例</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###视图:<br>关键就在于模板引擎的实现, 接着上个例子-中间件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;); // 引入 fs 文件模块</span><br><span class="line">var filePath = &apos;./views&apos;;</span><br><span class="line">app.use(function (req, res, next) &#123; </span><br><span class="line">        // 定义一个模板引擎</span><br><span class="line">        res.render = (filePath, option) =&gt; &#123;</span><br><span class="line">            fs.readFile(filePath, function (err, content) &#123;</span><br><span class="line">        if (err) return callback(new Error(err));</span><br><span class="line">        // 这是一个最简单的模板引擎了...</span><br><span class="line">        var rendered = content.toString().replace(&apos;#title#&apos;, &apos;&apos;+ options.title +&apos;&apos;).replace(&apos;#message#&apos;, &apos;&apos;+ options.message +&apos;&apos;);</span><br><span class="line">        return callback(null, rendered);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>###orm:<br>对于目前轻量化的框架来说, 加上 orm 的功能貌似有些重, 这里可以考虑使用 MongoDB 的 Mongoose ODM, 作为一个用户可选项</p>
<p>以上的各个应用模块主流的框架都有成熟的可以学习, 相信有时间去阅读一两个框架的源码,估计会功力大增,同时也为以后设计的软件架构打好基础.</p>
<h3 id="兼容其他框架"><a href="#兼容其他框架" class="headerlink" title="兼容其他框架"></a>兼容其他框架</h3><p>以上的 路由, 视图,中间件, orm 等四个模块是一个主流的框架基本所具备的, 所以这里需要我们重复造一个轮子么, 答案是不需要, 一方面主流的框架都有技术社区, 如果是模仿他们的话,完全没有必要, 无非是增加开发者的选择困难. 所以这里兼容其他的框架是必不可少的</p>
<p>切入点: 实现一个简单的路由, 将不同域名的请求转发不同的 app 中去, </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 服务文件所在目录</span><br><span class="line">var serverPath = &apos;/data/release/node_modules&apos;;</span><br><span class="line">var map = &#123;</span><br><span class="line">    &apos;a.qq.com&apos;: &#123;</span><br><span class="line">        &apos;App1&apos;: &apos;/App1/app.js&apos;,</span><br><span class="line">        &apos;App2&apos;: &apos;/App2/app.js&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;b.qq.com&apos;: &#123;</span><br><span class="line">        &apos;App1&apos;: &apos;/App1/app.js&apos;,</span><br><span class="line">        &apos;App2&apos;: &apos;/App2/app.js&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">/**</span><br><span class="line"> * 根据map 加载不同的 app</span><br><span class="line"> */</span><br><span class="line">let findApp = function(req, res) &#123;</span><br><span class="line">    var host = req.REQUEST.host || &apos;&apos;;</span><br><span class="line">    var app = map[host];</span><br><span class="line">    if (!app) &#123;</span><br><span class="line">        res.end(&apos;404&apos;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof app == &apos;object&apos;) &#123;</span><br><span class="line">        var pathname = req.REQUEST.pathname || &apos;&apos;;</span><br><span class="line">        var arr = pathname.split(&apos;/&apos;);</span><br><span class="line">        var firstPath = arr[1] || &apos;&apos;;</span><br><span class="line">        return require(serverPath + app[firstPath]);</span><br><span class="line">    &#125; else if (typeof app == &apos;string&apos;) &#123;</span><br><span class="line">        return require(serverPath + app);</span><br><span class="line">    &#125;</span><br><span class="line">    return require(serverPath + defaultApp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> 就这样子简单我们的框架只需要负责好转发即可,至于其他的, 扔给 koa express 等框架去处理.</p>
<p>##日志上报,监控告警</p>
<p>一个好的系统框架肯定少不了这些<br>日志:  现在有很多开源并且成熟的日志库, 可以直接引入使用, 如果开发者需要上报日志,只需要配置一下当前日志的路径即可, </p>
<p>监控告警与日志上报:  master 进程在启动的时候, 除了在启动 worker 进程之外, 还需要启动一个监控相关的进程, 主要的作用</p>
<ol>
<li>定时查询服务器的运行状态进程详细信息（PID、重启次数、上线时长、内存占用、错误日志）,并且上报</li>
<li>定时获取各个 APP的 log, 上报最新的log</li>
<li>可以把这个进程的作用当做是一个系统运维功能的大杂烩, 减轻主进程的负担, 尽量就让主进程只处理listening 和连接的分发</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p> 上篇的文章大致到这里, 很多技术细节由于时间问题,没有能够深挖, 以后有机会再展开细细的品尝,<br>当然本文只是一个引子, 主要还是为下文做准备…</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/nodejs/" rel="tag"># nodejs</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/11/06/daily_think/20161106-实习周报/" rel="next" title="20161106实习总结">
                <i class="fa fa-chevron-left"></i> 20161106实习总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/07/28/tech/浅谈Web前端中间件两种模型与实现/" rel="prev" title="浅谈 Web 前端中间件两种模型与实现">
                浅谈 Web 前端中间件两种模型与实现 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatars.png"
                alt="laynezhou" />
            
              <p class="site-author-name" itemprop="name">laynezhou</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/outshineamaze/" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程管理"><span class="nav-number">2.</span> <span class="nav-text">进程管理:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FastCGI-协议"><span class="nav-number">2.1.</span> <span class="nav-text">FastCGI 协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nodeJs-的child-process-和-cluster"><span class="nav-number">3.</span> <span class="nav-text">nodeJs 的child_process 和 cluster</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程守护"><span class="nav-number">3.1.</span> <span class="nav-text">进程守护</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程间通信"><span class="nav-number">4.</span> <span class="nav-text">进程间通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用层接入"><span class="nav-number">5.</span> <span class="nav-text">应用层接入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#request-response-增强"><span class="nav-number">5.1.</span> <span class="nav-text">request response 增强:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#兼容其他框架"><span class="nav-number">5.2.</span> <span class="nav-text">兼容其他框架</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">6.</span> <span class="nav-text">小结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">laynezhou</span>

  
</div>









        


<script>
  	var _mtac = {};
  	(function() {
  		var mta = document.createElement("script");
  		mta.src = "https://pingjs.qq.com/h5/stats.js?v2.0.4";
  		mta.setAttribute("name", "MTAH5");
  		mta.setAttribute("sid", "500669000");

  		var s = document.getElementsByTagName("script")[0];
  		s.parentNode.insertBefore(mta, s);
  	})();
</script>






        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: '0F7x1H9pH7A0VAKal3LN5idj-gzGzoHsz',
        appKey: 'Czers2Dz1pcKcHPko0BT2mcj',
        placeholder: '写的不对的地方请多多指教',
        avatar:'identicon',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.json";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
