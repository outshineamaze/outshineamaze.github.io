[{"title":"学会使用纯键盘工作","url":"%2F2020%2F05%2F09%2Fdaily_think%2F%E5%AD%A6%E4%BC%9A%E4%BD%BF%E7%94%A8%E7%BA%AF%E9%94%AE%E7%9B%98%E5%B7%A5%E4%BD%9C%2F","content":"\n## 闲聊\n\n作为一个键盘党， 前前后后大概买过5个机械键盘了， 今天又新入了hhkb hybrid type-s，不得不说手感真的是非常好， 非常安静， 手感和我的红轴键盘比较接近， 按键非常稳定， 按下任意一个按键都是一样的手感， 仿佛在给手指在做马杀鸡。\n好了， 吹了hhkb， 终于退烧了之后， 得聊聊我为什么要买hhkb了， 答案就是使用纯键盘工作\n<!-- more -->\n\n\n\n\n大学我用了3年的windows， 也是一个十足的软粉， 但是, 在实习之后， 开始用mac工作了， 从此就是command按键的忠实粉丝，仿佛后半生都离不开command按键了， 在使用mac的过程中， 也逐步开始意识到快捷键的重要性， 讲真的mac的快捷键其实不咋地， 最初吸引我的是触摸板比较好用， 对现在的我来说， mac最好的一点是提供了一个简单稳定长续航的操作系统与硬件， 用完即走，不用折腾\n\n\n\n在使用mac的过程中， 陆续使用过两个机械键盘， 分别是 青轴的filco 圣手二代  和 ganss 87 红轴， 最开始的青轴因为太吵，被同时吐槽， 所以最终没有在公司使用，带回家吃灰快三年了。 取而代之的是ganss 87， 一个淘宝随便买的87红轴， 虽然也挺吵的，但是相比于filco青轴， 简直不要太安静了， 有时候想想写代码写的最多的居然是淘宝随便买的破键盘， 就跟之前我用耳机一样， 为了防止Imac意外在办公室外放， 我就接了一个EarPods耳机，结果最后用的最多也是这个有线的EarPods， 然后Boss QC35 和 AirPods也是吃灰，很多时候越是简单的东西反而越经常使用，  最好玩的是那个Earpods耳机是我买手机充电线送的山寨版的\n\n## 回到主题\n\n影响我们工作效率的一大问题是啥呢？ 对于我来说 频繁的把手从键盘移动到鼠标， 再放回键盘\n所以想要一个高的工作效率， 核心的关键点是如何让我们的手在整天的工作中不需要离开键盘，即使做到不离开键盘， 还要保证食指要在FJ两个按键上，这样子才能高效稳定的输出大脑指令\n\n\n## 平时工作一般会用到哪些软件\n\n\n![使用时间分布](学会使用纯键盘工作/app时间分布.png)\n\n1. vscode 写代码， 写文档\n2. edge浏览器, 大部分的工作都是云端的， 所以浏览器非常重要\n3. 企业微信、微信\n\n\n可以看到平时我平时主要就是这几个软件占用我大部分的时间\n\n还有一些其他的mac上的软件也支持很多的快捷键, 使用mac的同学可以搜索一下CheatSheet 这个软件， 按住command按键就会跳出当前软件支持的快捷键列表， 非常方便\n\n\n\n\n## 开发\n\n\n最近两年一直都是使用远程开发的模式， 即代码存放在开发服务器中， 通过terminal登录开发服务器使用vim开发或者使用vscode remote-ssh 连接开发服务器开发， 目前已经是一个vscode的重度用户了。最开始用vscode的时候， 还背了一下vscode自带的快捷键， 然后用vim的时候还带切换回vim的快捷键， vscode的那几个快捷键是远远不够用的，虽然提供了强大的keymap的功能， 但是自己去配置也是不够现实的，  最后还是在vscode的开启vim mode， 可以把vscode + vim mode 等同于  一个高级的terminal+vim远程开发， 只不过vscode的GUI对于大部分人更加友好， 而在写代码过程中依旧使用vim的快捷键。 \n\n所以我的开发模式就变成了：\n\n1. 使用iterm2登录开发服务器， tmux创建会话用于持久化窗口， 然后使用vim直接写代码， 这种模式其实用的不多\n2. 启动vscode， 连接上远程开发服务器， 将常用的目前加到工作区中， 保存工作区， 下次打开会自动化连接上， 并恢复工作区的状态\n![](学会使用纯键盘工作/terminal_vscode.png)\n可以发现在两个模式之间， 我都使用vim mode 的快捷键编程, 其实对我来说本地电脑编辑器的快捷键配置就没有那么重要了\n\n写代码的是分两种情况， 一是在快速各个文件中跳转，或者快速查看代码文件； 另外一块是单个文件长时间的coding， \n\n单个文件的编辑， 主要的场景是我们打开一个文件， 现在可能需要花几个小时的时间来写一个模块或者写一篇文档， 这种场景我们主要使用的是单独的代码编辑器的功能，（代码编辑器，IDE还是有些区别的\n\n\n对于代码编辑器常用的几个功能是如何通过键盘操作的， 首先是要启用vim mode， vscode可以在商店中搜索vim，command + shift + p 搜索vim，点击 toggle vim mode\n\nvim的基本操作可以google搜索到很多的教程， 这里不过多阐述\n\n对于文本编辑器的操作， 我们给主要使用的功能进行了一个排序\n\n\n1. 光标移动\n2. 文本处理, 文本选择， 文本复制，文本删除, 文本移动\n3. 搜索\n4. 翻页\n5. 跳转\n\n上面是我进行的一个使用频率的排序， 可以看到光标的移动在写代码中， 是非常频繁的操作， 假如我们习惯用鼠标的话，通常会用鼠标点到下一步的操作位置, 这时候手就离开键盘了，一来一回，就极大的拖慢我们的编程速度\n\n#### 特别讲一下光标的快速移动\n开启vim mode 的 vim-easymotion模式\n\n![](学会使用纯键盘工作/vim_motion.gif)\n\n```\n(\"vim.easymotion\": true)\n```\n\n```\n<leader><leader> t/T <char> 能够向前/向后快速到达可见范围内的某字符(<char>)的位置\n<leader><leader> w/b 向前/向后到达可见范围内任何单词的开头\n<leader><leader> e/ge 向前/向后到达可见范围内任何单词的结尾\n<leader><leader> k/j 向前/向后到达可见范围内任何行的行首\n```\n\n更多操作查看文档 [VSCodeVim/#vim-motion](https://github.com/VSCodeVim/Vim/#vim-easymotion)\n\n\n其他几项文本编辑器的操作，如果用熟练vscode快捷键， 在vscode使用原生的快捷键和vim的快捷键其实操作的效率是差不多的， 大家在编写一个文件的时候观察一下每次手离开键盘都是因为什么， 我的情况是大部分情况就是去移动光标。 为了统一在各大硬件平台的操作习惯， 建议是学习vim的快捷键， 一次学习受用终生，我可不想哪天换了电脑或者换了一个工作环境， 就得重新学一遍快捷键\n\n\n\n#### 关于vscode的常用快捷键\n\n在处理单文件的编辑之外，还有一个会导致我们手频繁离开键盘的操作是展开目录树打开另外一个文件， 这是要赞一下vscode 的 Command + P的快捷打开文件的操作， 模糊匹配路径+近期打开文件的列表， 可以帮助我们快速的打开想要的文件， 而不必去目录树一个个展开肉眼去寻找文件再用鼠标点击打开，所以非常建议在编辑单个文件使用vim mode， 我们还是需要去学习vscode的常用快捷键， 比如多窗口切换， 打开terminal等等\n\n \n\n\n\n## 浏览器\n\n浏览器离不开vimium插件 \n\n![](学会使用纯键盘工作/vimium.gif)\n下面是一些我最常常用到的页面操作：\n\n最基本的操作是可以使用j,k进行上下滚动， u,d进行上下翻页， f可以将页面中可以点击的都标记出来， 然后通过快捷键模拟点击动作\n我的常用操作如下：\n\n```\nshift + jk 进行tab之间的左右切换\n\nshift + hl 进行页面的前进后退\n\nx关闭当前页面， X恢复前面关闭的页面\n\nt打开新的tab\n\nshift + o可以出现搜索框方便直接跳转标签、历史访问的页面（有点类似vscode的command+p)\n```\n\n可以看到上面把我们平时浏览器常用的操作都涵盖了， 基本都不需要使用鼠标操作页面， 双手也不需要离开键盘\n\n更多的快捷键可以参考 ![](https://cdn.sspai.com/attachment/origin/2014/12/16/204008.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n\n\n\n\n\n## 操作系统操作\n\n操作系统层级的我们使用的最多就是打开文件管理器， 打开应用， 打开系统设置等等\n\n那么就是得推荐一个神器了 Alfred， 我配置了opt + space的快捷键快速调起搜索输入框\n\n一般应用都是通过Alfred搜索启动的，搜索网页\n\n![](学会使用纯键盘工作/alfred.gif)\n\n除了使用Alfred快速打开所有的应用和文件， mac系统上我用的最多的就是command+ tab切换应用 和 ctrl + 左右箭头切换多桌面\n\n\n## 关于键盘的键位的配置\n\n对于键位, 我的观点一向是不要大改， 首先要想想自己平时用的最不顺手的按键是哪几个\n对我而言 在使用87按键的键盘时， 还是会不自主的移动右手去按上下左右的方向键， 我的目标是左右两个食指不离开FJ两个按键， 频繁的移动右手去按方向键还是很麻烦的， 所以我引入了 [KaraBiner-Element](https://karabiner-elements.pqrs.org/)改键工具\n\n![](学会使用纯键盘工作/karabinor_elements.png)\n出于克制的习惯， 我只加了一条改动策略，   Left Ctrl + hjkl to Arrow keys vim，  所以在非vim编辑器的地方， 我上下左右基本都是使用 ctrl + hjkl来代替方向键， 实现了方向键这几个高频按键的全系统的统一， 得益于hhkb的 ctrl按键替换了原先面积很大却不常用的Caps Lock按键的位置，即使之前使用其他的键盘，也是配置这条策略的， 只是在hhkb上， 这个ctrl的位置确实是真香，  所以我准备把其他的键盘的CapsLock按键也修改为Ctrl\n\n\n\n## 总结：\n\n学会使用纯键盘工作的标题可能确实有点标题党， 实际上如果你使用GUI的操作系统工作，是很难不用到鼠标或者触摸板的， 毕竟很多时候学习快捷键是有成本的， 很多软件对于快捷键的支持也不是那么好， 我们能做到的就是尽可能的降低在键盘和鼠标之间切换的频率。 在大部分情况下， 我们操作电脑的速度是比不过我们大脑思考的速度的， 所以提升电脑的键盘使用效率是非常重要的， 尽可能的做到流畅的操作不被打断，一旦熟练之后带来的生产力提升是难以想象的。 \n\n我们提升的是我们大脑的io的速度， 人的的大脑一旦有的io中断， 经常就回不来了， 从并行运算上看还是计算机做的比较厉害","tags":["纯键盘工作"],"categories":["日常"]},{"title":"golang源码工程是如何提交代码的","url":"%2F2020%2F05%2F07%2Ftech%2Fgolang%E6%BA%90%E7%A0%81%E5%B7%A5%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E7%9A%84%2F","content":"\n\n## 前言：\n\ngolang是一门非常年轻的语言，背靠工程实践非常强大的google， 在开源的研发流程上也是处处凸显google的工程师文化， 本文简要讲述在golang源码仓库中提交一个commit的过程及其涉及到的持续交付的知识\n<!-- more -->\n\n## 相关链接：\n\n[golang源码](https://sourcegraph.com/github.com/golang/go), 在线快速阅读源码\n\n[golang官方仓库的贡献指南](https://golang.org/doc/contribute.html#contributor)：  非常详细， 是我目前见过最详细的提交指南了\n\n\n[Gerrit](https://go-review.googlesource.com/dashboard/self)：不同于其他的github开源项目， golang有它独立的一套代码评审系统， 基于, 可以把它当做一个纯粹的code-review系统\n\n\n[主干开发](https://trunkbaseddevelopment.com/)： golang的仓库的开发主要是基于主干开发的方式\n\n## 基本步骤：\n\n1. 注册为贡献者，具体[参考](https://golang.org/doc/contribute.html#contrib_overview), 主要的内容是 注册 Gerrit账户，签署开发者协议，下载 git-codereview 客户端\n2. 在写代码之前，首先需要搜索一下已有的issues， 看是否有已有的解决方案或者议题， 如果没有找到，可以为本次要解决的问题打开一个issues， 标记一下， 防止其他人重复劳动\n3. 在开发完代码之后， 下一步就是准备往golang仓库发起代码评审（code review）\n\n##  发起代码评审有两种方式：\n\n1. 基于github开源的玩法， 从自己fork出来的分支往golang仓库发起 Pull Request，例如:[Pull Request](https://github.com/golang/go/pull/38852)\n2. 直接基于Gerrit + git-codereview工具发起代码评审， 例如： [gerrit代码评审](https://go-review.googlesource.com/c/go/+/232037)\n\n\n\n### 基于github发起PR\n\ngolang的代码评审主要还是在gerrit中处理的， 但是为了照顾广大开源开发者的习惯， golang团队很贴心的做了几个github的机器人， 会自动将PR的内容同步到gerrit中， 一个PR中我们可以看到这两个机器人：\n\n   1. googlebot 一般会检查当前的开发者是否签署了开发者协议。 \n   2. gopherbot 自动将当前的PR的内容在gerrit中创建一个代码评审， 并且会同步gerrit评审的消息到PR中。可以看做是两个评审系统的同步工具\n\n下图为googlebot检查是否签署开发者协议\n![golang-clabot](golang-cla.png)\n下图为goherbot同步PR到gerrit\n![golang-goherbot](golang-goherbot.png)\n下图为gerrit代码评审界面\n![golang-cr](gerrit-cr.png)\n\n\n在github中PR的作用其实就是代码评审， 而Gerrit的功能也是类似， 所以这不用过多纠结着两者之间的差别， 简单来说就是Google的工程师觉得Github PR那套评审不好用， 就用Gerrit代替了它。 那么怎么代替呢？  具体的步骤类似如下：\n\n1. 给当前的仓库配置github的钩子，监听PR的发起与更新事件。 \n2. 当发起PR时， 触发对应的钩子， 在钩子中创建 Gerrit代码评审单关联当前的PR\n3. 当Gerrit中有评论时， goherbot会将评论同步到PR中， 开发者可以修改代码并提交， 此时也会触发PR的更新和 gerrit评审的更新\n4. 当评审通过时， 在Gerrit中， maintainers可以通过添加Run-TryBot Label， TryBots会触发pre-submit的检查， golang基于GKE搭建了自己的持续集成系统：[build dashboard](https://build.golang.org/)\n5. 当code-review通过且TryBots的pre-submit检查通过之后，代码会自动被合入master，会在master创建一个合并提交（squash commit），原分支的所有新增的commit会被压缩成一个commit， 并且这个commit会带上当前code-review的链接， 方便追踪代码的改动\n6. 代码的提交统一使用cherry-pick的方式提交到主干。这里就比较强调单个PR之间的原子性了。 \n\n\n### 基于Gerrit + git-codereview发起代码评审\n\n需要从 https://go.googlesource.com/go clone出 github/golang代码库的镜像仓库，并新建分支进行开发\n\n使用基于Gerrit + git-codereview发起的代码评审相当于绕过github提供的Pull Request功能， 直接创建gerrit的评审，  代码评审code review通过+TryBots运行通过， Gerrrit会自动将commit cherry-pick到github golang仓库master分支\n\n\n\n### Commit-提交信息的格式：\n\n一个好的提交格式类似这样：\n```\nmath: improve Sin, Cos and Tan precision for very large arguments\n\nThe existing implementation has poor numerical properties for\nlarge arguments, so use the McGillicutty algorithm to improve\naccuracy above 1e10.\n\nThe algorithm is described at https://wikipedia.org/wiki/McGillicutty_Algorithm\n\nFixes #159\n```\n首行要简要的表达出本次提交的作用\n\n中间主体部分详细描述改动\n\n最后一行是相关issues的引用， 关联issues， 方便回溯改动的背景\n\n## Submitting\n\n一次提交包括如下三次检查：\n\n### 1. 发起代码评审前本地运行检查\n\ngo的仓库提供了一个all.bash的脚步， 方便开发者快速在本地执行代码风格检查和单元测试， 一般会做成增量检查的方式， 降低开发者等待的时间， 这一步主要保证当前的改动代码分支是可以通过检查的\n```\n$ cd go/src\n$ ./all.bash\n```\n\n### 2. pre-submit\n\n在gerrit的评审中， tryBots会触发运行pre-submmit， 这一步一般会模拟合入代码， 并运行相应的增量的检查， 这一步主要保证当前分支的代码与主干最新的提交合并之后应该是可以通过检查的\n\n### 3. post-submmit\n当代码合入master之后， 要执行master的全面的检查，这是三层检查中最后一道，也是代码质量的最重要的一道防线\n\n上述的三个检查其实有个专业的术语叫做“6步提交法”\n![6步提交法](6-step-commit.png)","tags":["六步提交法"],"categories":["持续交付"]},{"title":"浅析组件化时代的前端状态管理(六):React Hook","url":"%2F2019%2F02%2F19%2Ftech%2F%E6%B5%85%E6%9E%90%E7%BB%84%E4%BB%B6%E5%8C%96%E6%97%B6%E4%BB%A3%E7%9A%84%E5%89%8D%E7%AB%AF%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86(%E5%85%AD)%3AReact%20Hook%2F","content":"\n\n[React Hooks](https://react.docschina.org/docs/hooks-intro.html)目前是 React 处于提案阶段的一个特性, 根据其官方的介绍, Hooks被创建出来主要动机如下:\n\n* 跨组件复用stateful logic(包含状态的逻辑)十分困难\n\n* 复杂的组件难以理解\n\n* Hooks让React组件也是更接近于函数\n\n<!-- more -->\n很多时候组件之间的逻辑都是相似的, 如果想复用组件中的逻辑 或者扩展组件的逻辑, 我们可以通过 [render props](https://react.docschina.org/docs/render-props.html) 或者[高阶组件](https://react.docschina.org/docs/higher-order-components.html),  所以我们在使用很多开源的组件时, 可以经常看到组件支持传入一个 函数作为 props.  通过这个方式, 我们甚至可以完全重新定义组件的具体渲染\n\n使用 render props 和 stateless component\n\n```javascript\nimport React, { PureComponent } from \"react\";\n\n//举个例子, 现在要开发一个列表组件应用, 点击某一行, 就会在这行后面添加字符串 \"已选择\"\n\nconst ListItemComponent = (props = {}) => {\n  const { isSelected, onClick, value } = props;\n  console.log(value);\n  return (\n    <li onClick={onClick}>\n      <span>{value}</span>\n      {isSelected ? \"已选择\" : \"\"}\n    </li>\n  );\n};\n\nclass App extends PureComponent {\n  constructor(props) {\n    super(props);\n    this.data = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    this.state = {\n      selectedList: []\n    };\n    this.onClick = this.onClick.bind(this);\n  }\n  onClick(e, value) {\n    const newSelectedList = this.state.selectedList.concat([value]);\n    this.setState({\n      selectedList: newSelectedList\n    });\n  }\n\n  render() {\n    return (\n      <>\n        demo 6_1:\n        <br />\n        {this.data.map(item => {\n          // ListItemComponent 可以作为props的一个属性直接传递进来, 相当于 ListItemComponent的逻辑部分都是可以直接复用的.\n          return (\n            <ListItemComponent\n              value={item}\n              onClick={event => this.onClick(event, item)}\n              isSelected={this.state.selectedList.includes(item)}\n            />\n          );\n        })}\n      </>\n    );\n  }\n}\n\nexport default App;\n\n```\n\n[![Edit front_end_state_manage_demo](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/moqr8pxzqy?codemirror=1&fontsize=14&module=%2Fsrc%2Fdemo_6_1.js&moduleview=1)\n\n\n在真实的项目中, 一个组件的场景会比上述复杂的多, 可能需要拆分成非常多的子组件, 改造成本也比较高. 当项目中比较复杂的组件代码都改造为多个小的 stateless 组件, 并通过 render props 和 高阶组件的方式进行组装, 组件的可扩展性和代码的可复用性将会极大的提高.  \n\n本来只是想复用组件中的代码逻辑, 最后却重构整个组件,  React 团队认为这种现象也指出了一些更深层次的问题：React需要一些更好的底层元素来复用stateful logic.\n\n\n使用 React Hooks实现上述的功能\n```javascript\nimport React, { useState } from \"react\";\n\nconst ListItemComponent = (props = {}) => {\n  const [isSelected, setIsSelected] = useState(false);\n  const { value } = props;\n  return (\n    <li onClick={() => setIsSelected(!isSelected)}>\n      <span>{value}</span>\n      {isSelected ? \"已选择\" : \"\"}\n    </li>\n  );\n};\n\nconst data = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nconst App = () => {\n  return (\n    <>\n      demo 6_2:\n      <br />\n      {data.map(item => (\n        <ListItemComponent value={item} />\n      ))}\n    </>\n  );\n};\n\nexport default App;\n\n\n```\n[![Edit front_end_state_manage_demo](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/moqr8pxzqy?codemirror=1&fontsize=14&module=%2Fsrc%2Fdemo_6_2.js&moduleview=1)\n\n\n从上面使用 React Hooks改造过的代码中, 可以直观的看到, 在ListItemComponent里面可以直接创建一个 值 和 修改值的方法, 就不用像 render props那样子需要把 \"值 和 修改值的方法\" 从父组件 一层层的传递到子组件. 利用useState这个 hooks,  等同于把依赖的状态数据注入组件, 只是这些数据并非是集中管理的, 而是分散且粒度更细的数据, 关于数据共享 和 数据修改,  还有useReducer 和  useContext  等hooks可以提供能力支持\n\n\n#### React hooks 只是逻辑的复用, 并非数据的复用\n\n```javascript\nimport React, { useState } from \"react\";\n\nfunction useIsSelected(friendID) {\n  const [isSelected, setIsSelected] = useState(false);\n\n  function handleStatusChange(e) {\n    setIsSelected(!isSelected);\n  }\n  return [isSelected, handleStatusChange];\n}\n\nfunction List1() {\n  const [selected, actions] = useIsSelected();\n\n  return <span onClick={actions}>list1(点我) {selected ? \"选中\" : \"\"} </span>;\n}\n\nfunction List2() {\n  const [selected, actions] = useIsSelected();\n  return <span onClick={actions}>list2(点我) {selected ? \"选中\" : \"\"}</span>;\n}\n\nfunction App() {\n  return (\n    <>\n      demo 6_3:\n      <br />\n      <List1 />\n      <br />\n      <List2 />\n    </>\n  );\n}\n\nexport default App;\n\n\n```\n[![Edit front_end_state_manage_demo](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/moqr8pxzqy?codemirror=1&fontsize=14&module=%2Fsrc%2Fdemo_6_3.js&moduleview=1)\n\n上述的 List1  List2 都复用  useIsSelected,  但是只是逻辑的复用,  实际上会创建两个独立的值, 互不干扰.\n\n\n#### React hooks 本质上只是数组\n\nReact Hooks 带来两个使用上的约定:\n\n* 不要在循环，条件判断，嵌套函数里面调用 Hooks\n* 只在 React 的函数里面调用 Hooks\n\n其实很好理解, 每次使用 useXXX Hooks的时候, 是通过两个数组来存储对应的 值 和修改值的方法, [原理详细参考](http://react-china.org/t/react-hooks/27122)\n\n\nReact Hooks 这部分就草草的收尾了, 一方面是这块确实没有太多的实践经验, 纯属是在理论上做简单的分析与介绍, 更多的 Hooks 细节介绍由于有 [官方文档](https://react.docschina.org/docs/hooks-reference.html), 就不重复阐述,\nReact Hooks 部分也可以参考:  [精读《React Hooks》](https://juejin.im/post/5be8d3def265da611a476231)\n\n","tags":["React Hook"],"categories":["前端状态管理"]},{"title":"浅析组件化时代的前端状态管理(五):响应式状态管理","url":"%2F2019%2F02%2F19%2Ftech%2F%E6%B5%85%E6%9E%90%E7%BB%84%E4%BB%B6%E5%8C%96%E6%97%B6%E4%BB%A3%E7%9A%84%E5%89%8D%E7%AB%AF%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86(%E4%BA%94)%3A%E5%93%8D%E5%BA%94%E5%BC%8F%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%2F","content":"\n\n当我们踏上 React + Redux这艘大船时, 我们时常会觉得, 我们\b有时候需要遵循太多React的范式, 也要理解太多组件与状态管理的概念, 特别是 Redux的用法, 很多开发者都觉得很难理解, 写一个简单的逻辑要修改很多个文件, 要写很多感觉很冗余的代码.  大部分开发者只是想修个草坪,  然而要让请个工程队?\n<!-- more -->\n每一个React开发者被 \"组件更新 + 状态管理\" 的概念与 \"重复渲染/不渲染\" 问题困扰的时候,  脑子肯定会冒出一个想法,  为什么不能像很多MVVM框架一样, 数据变了, UI自动变, 组件在相关的数据改变了之后, 就会自动更新,  其实这有点是响应式的感觉了\n\n\n这里要推荐两个小众的响应式理念的库, 有兴趣可以了解一下\n> [cycle.js](http://cyclejs.cn/)  一个函数式和响应式的 JavaScript 框架，编写可观测代码\n[rx.js](https://cn.rx.js.org/) 是一个库，它通过使用 observable 序列来编写异步和基于事件的程序\n\n\n#### MobX\n\nMobX 是一个经过战火洗礼的库，它通过透明的函数响应式编程(transparently applying functional reactive programming - TFRP)使得状态管理变得简单和可扩展。MobX背后的哲学很简单:\n\n任何源自应用状态的东西都应该自动地获得。\n\n其中包括UI、数据序列化、服务器通讯，等等。\n\n\n\n最简单的例子:\n\n```javascript\n// 1. 定义状态并使其可观察\nimport {observable, action} from 'mobx';\nvar appState = observable({\n    count: 0\n});\n\nappState.addCount = action(() => {\n    appState.timer = appState.timer + 1;\n});\n\n\n\n// 2. 创建视图以响应状态的变化\nimport {observer} from 'mobx-react';\n@observer\nclass App extends React.Component {\n    render() {\n        return (\n            <button onClick={appState.addCount}>\n                count: {this.props.appState.count}\n            </button>\n        );\n    }\n};\n\n\nReactDOM.render(<App/>, document.body);\n\n```\n\n从上面的demo中可以看到, 在React应用中使用MobX可以说是非常简单\n\n1. 定义状态并使其可观察, 把 Model 数据用 observable包裹起来.\n2. 创建视图以响应状态的变化, 把 View 组件使用 observer 包裹起来.\n3. 当 Model 的数据发生变化时, Mobx会监听到数据的改变, 然后自动更新组件, 这就是所谓的响应式的理念了\n\n\n\n![](https://cn.mobx.js.org/flow.png)\n\nMobX 提供了优化应用状态与 React 组件同步的机制，这种机制就是使用响应式虚拟依赖状态图表，它只有在真正需要的时候才更新并且永远保持是最新的。\n\n\n\nMobX最核心的两个点:\n\n1. observable: 用来包装一个属性为 被观察者\n2. observer: 用来包装一个方法为 观察者\n\n\nobserver包裹后的函数, 最重要的作用就是收集依赖和驱动组件刷新, Mobx中有一个 dependenceManager，这个工具类中管理了一个依赖的 dependencMap\n结构是一个全局唯一的 ID 和 对应的监听的函数的数组。\n\n```javascript\n// a 就是一个  Observable 实例, 并且a有一个唯一的全局id\nconst a = obserable({\n    name: 'nickname'\n})\n\n//  dependencMap 的 key就是 上面的那个 a的唯一全局id\nconst dependencMap = {\n    a.objectID = [\n        ...hanlder // 依赖这个 observable 值的函数 或者 组件\n    ]\n}\n```\n\n当一个被 observable 包装的属性值发生 set 行为的时候，就会触发 dependenceManager.trigger(obID); 从而触发遍历对应的监听函数列表，并且执行，这就是 observer 的基本原理, 我们一般用observer来包裹组件,  那么当组件依赖的数据有变更时, 组件就会执行render函数, 实现组件界面刷新\n\n\n\n这个依赖的 map 如何做生成的呢?\n\nobserver里面有个的 autoRun 方法很关键\n\n```javascript\n// 组件被渲染之前, 会标记一下, 这个组件正在执行依赖收集\ndependenceManager.beginCollect(handler);\n\n// 执行组件的render逻辑\nhandler();\n\n// 结束组件依赖收集\ndependenceManager.endCollect();\n\n```\n\n当一个组件处于依赖收集的状态, 在执行渲染的时候, 如果使用了某个 observable 值,  由于 observable 对象是被\bProxy 包裹过的, 实际上会通过Proxy中的 get 的方法能取到最终的值, 这时候只需要把这个值 和 当前正在收集依赖的 handler 关联起来, 并存储在 dependencMap 中, 就完成依赖收集了.\n\n\nMobX还些其他的特性, 例如 computed, 这里就不一一阐述, 我们能理解大致的设计理念即可  详情可以参考 [MobX](https://cn.mobx.js.org/intro/concepts.html)\n\n>Immer的作者跟Mobx的作者是同一个人,  可以说Mobx 的底层在Proxy的使用上, 理念跟 immer 是如出一辙的\n\n#### Vue\n\n在国内火的一塌糊涂的 VUE其标榜的也是响应式编程的理念\n\n在实现响应式的方式上, 跟Mobx非常类似, 不过 Vue 使用 Object.defineProperty 把对象的属性全部转为 getter/setter, 进而实现 追踪依赖，并在属性被访问和修改时通知变化\n\n\nVue的官方文档已经写的非常详细了, 这里不重复阐述, \b强烈建议点进去看一下 [深入响应式原理](https://cn.vuejs.org/v2/guide/reactivity.html)\n\n","tags":["响应式状态管理"],"categories":["前端状态管理"]},{"title":"浅析组件化时代的前端状态管理(四):Redux与Immutable","url":"%2F2019%2F02%2F19%2Ftech%2F%E6%B5%85%E6%9E%90%E7%BB%84%E4%BB%B6%E5%8C%96%E6%97%B6%E4%BB%A3%E7%9A%84%E5%89%8D%E7%AB%AF%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86(%E5%9B%9B)%3ARedux%E4%B8%8EImmutable%2F","content":"\n## Redux\n\n\nReact + Redux是目前React技术栈下一个比较常见的组合, 其解决的问题就是上一节我们提到的 如何玩转 \"组件化+数据驱动\",\n简单的理解就是 React 负责管理视图, Redux提供一个可预测化的状态管理\n<!-- more -->\n在Redux中, 通过一个全局 Store保存整个页面的所有模型数据,  再通过 dispatch(action) 的方式更新store中的数据, 再通过 connect 的方式, 把 store的数据注入到组件中去. \n也就是说, store每一个数据的改变, 都是通过 action触发的, 即 UI渲染的每一步也是和 action对应的, 假如我们能把这些action记录下来,  \b逆序 dispatch这些action,  甚至可以实现 \"时光倒流的\" 的效果,  \n\n如果没有接触过Redux可以简单的浏览一下 [redux文档](https://www.redux.org.cn/docs/introduction/CoreConcepts.html)\n\n\n#### Redux的简单介绍:\n\n\nAction 是把数据从应用传到 store 的载体。它是 store 数据的唯一来源。一般来说你会通过 store.dispatch() 将 action 传到 store。\n\nReducers 指定了应用状态的变化如何响应 actions 并发送到 store 的，记住 actions 只是描述了有事情发生了这一事实，并没有描述应用如何更新 state。\n\nStore 就是把它们联系到一起的对象。Store 有以下职责：\n    维持应用的 state；\n    提供 getState() 方法获取 state；\n    提供 dispatch(action) 方法更新 state；\n\n\nRedux是如何驱动UI更新的\n```\n\n                 _________               ____________               ___________\n                |         |             |            |             |           |\n                | Action  |------------▶| Dispatcher |------------▶| callbacks |\n                |_________|             |____________|             |___________|\n                     ▲                                                   |\n                     |                                                   |\n                     |                                                   |\n _________       ____|_____                                          ____▼____\n|         |◀----|  Action  |                                        |         |\n| Web API |     | Creators |                                        |  Store  |\n|_________|----▶|__________|                                        |_________|\n                     ▲                                                   |\n                     |                                                   |\n                 ____|________           ____________                ____▼____\n                |   User       |         |   React   |              | Change  |\n                | interactions |◀--------|   Views   |◀-------------| events  |\n                |______________|         |___________|              |_________|\n\n\ncomponent(渲染UI) -> action（定义用户操作动作） -> reducer(处理action动作) -> store（处理reducer绑定state和dispatch） -> component（Provider注入数据, connect连接组件, 驱动UI更新\n```\n[图片来源](https://github.com/happypoulp/redux-tutorial/blob/master/00_introduction.js)\n\n\n看一个简单的 React-redux 的例子:\n\n```javascript\nimport React, { PureComponent, Component } from \"react\";\nimport { createStore } from 'redux'\nimport { connect, Provider } from 'react-redux'\n\n// reducer/index.js\n// reduce里面都是纯函数, 不依赖其他的全局状态. 具有幂等性, 简单的理解就是传入 store 和 action, 函数结束时返回新的 store, 然后触发页面UI的更新\nconst reducer = (state = { str: '✒️write something: ', placeholder: 'here?' }, action) => {\n  switch (action.type) {\n    case 'INPUTCHANGE':\n      return {\n        str: action.value\n      };\n    default:\n      return state;\n  }\n};\n\n\n// actions/index.js\nconst onChangeAction = (e) => (\n  {\n    type: 'INPUTCHANGE',\n    value: e.target.value\n  }\n);\n\n\n\n\n// component/Input.js\n// 纯UI组件, stateless, 不维护组件的状态, 只做纯渲染操作\nconst Input = (props) => (\n  <div>\n    <h2>{props.str}</h2>\n    <input onChange={props.onChange} placeholder={props.placeholder} />\n  </div>\n);\n\n\n\n// container/index.js\nconst mapStateToProps = (state) => {\n  return ({\n    str: state.str,\n    placeholder: state.placeholder\n  });\n};\nconst mapDispatchToProps = (dispatch) => {\n  return ({\n    onChange: (e) => { return dispatch(onChangeAction(e)) }\n  });\n};\n// 在这里把store的数据和 修改数据的dispatch方法注入到组件中\nconst InputWithState = connect(mapStateToProps, mapDispatchToProps)(Input);\n\n\n\n//  app.js 应用入口\nconst store = createStore(reducer);\nconst App = () => (\n  <Provider store={store}>\n    <InputWithState />\n  </Provider>\n);\n\nexport default App\n```\n\n看完例子可以再返回上面重新回顾一下redux的概念, 也许会有不一样的理解\n[![Edit front_end_state_manage_demo](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/moqr8pxzqy?codemirror=1&fontsize=14&module=%2Fsrc%2Fdemo_4_1.js&moduleview=1)\n\n\n## PureComponent 与 Component的使用\n\n看到上面的例子, 可能回想, 如果每次触发一个action, 就从 Provider开始渲染整个页面的, 是否会导致页面所有的组件的重复渲染?\n\n假如页面的组件大量使用 PureComponent, 会自带一个浅对比的功能,  如果传入新的props对象 与旧的props对象第一层数据是一样的, 那么这个组件就不会重新执行render函数.  效果类似于 Component 中 should\bUpdateCompnent 自行实现浅对比是一样的. 对于\b大部分场景都推崇使用PureComponent\n\n浅对比:\n\n```javascript\nconst a = {\n    \"value1\": {\n        \"\bvalue2\": {\n            \"value3\": 12345\n        }\n    }\n}\n\n// 如果是嵌套的结构, 直接修改第一层以下的数据节点,  浅对比的结果是 相等的\nconst b = Object.assign({}, a)\nb.value1.value2.\bvalue3 = 54321\nshallowEual(a, b) // true\n\n// 如果直接修改第一层的数据节点\nconst c = Object.assign({}, a)\nc.value1 = 54321\nshallowEual(a, b) // false\n\n```\n\n\n## Immutable\n\n假如我们大规模使用PureComponent,  就会强依赖于 PureComponent自带的shallowEqual(数据浅对比), 而开发者在更新组件的过程中, 由于各种人为的不可控原因, 会直接修改数据, 这就违背了数据不可变的 原则了, 导致的后果最常见的就是数据变了, UI不更新, 因为直接修改数据, 数据的引用没有改变, 浅对比的时候就认为数据没有改变, 自然就不重新渲染组件\n\nImmutable即数据不可变, 当更新store中的数据后, 不能在原来的指针下更新数据对象,  正确的做法应该是直接用一个新的对象替换掉之前的对象. \nFacebook也提供对应的 [Immutable.js](https://facebook.github.io/immutable-js/) 工具来帮我们解决这个问题. \n\nImmutable.js解决问题的思路是: 既然开发者\b喜欢直接修改源数据,  那我就把这条路堵死, 只能通过我提供的 api 来操作数据对象,  我只要保证开发者每次调用api修改数据的时候, 能返回一个新的对象回去就好了.   Immutable.js底层实现并非使用cloneDeep这么简单粗暴低效的方式,  Immutable 实现的原理是 Persistent Data Structure（持久化数据结构）, 也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。\n\n[](https://user-gold-cdn.xitu.io/2018/4/4/1628e77dc419816b?imageslim)\n\n当然使用 Immutable.js对于开发者还是有挺高的成本的, 对于项目的侵入是非常大的,  所以很多开发者也没有勇气直接把Immutable.js在自己的大型项目中使用起来.\n\n1. 只能通过调用 api 来更新数据\n2. 在jsx渲染的时候, 只能通过 api 获取 Immutable对象中的数据\n3. 不能用es6的结构赋值了\n\n广大开发者肯定都是又想要 Immutable的特性, 又想用js原生的对象操作方法, immer就帮我们实现了这个梦想\n\n\n## [immer](https://github.com/mweststrate/immer)\n\n\n#### immer的简单使用场景:\n\n```javascript\nconst produce = require('immer')\n\nconst state = {\n  done: false,\n}\n\nconst newState = produce(state, (draft) => {\n  draft.done = true\n})\n\nconsole.log(state.done) // false\nconsole.log(newState.done) // true\n```\n\n\n简单的来说就是 immer提供一个 produce 函数, 这个函数接受两个参数:  一个是原始的数据对象,  另外一个是一个纯函数, 在这个函数里面, 用户可以任意修改 draft, 如果用户修改了 draft, 最终 produce 返回的是一个新的对象. 在produce第二个参数的函数中,  可以使用 原生js的\"\b.\" 操作符进行对象的数据修改, 和原生的修改数据对象的写法几乎一致.\n\n```javascript\n// 通过 immer, 可以更加方便地像修改原生对象一样修改state, 同时保证数据的不可变性\nthis.setState(\n    produce(draft => {\n        draft.user.age += 1\n    })\n)\n```\n\n#### immer的实现\n\nimmer的底层实现理念和 mobx 和 vue的一些底层的理念非常相似.\n\n先来思考一下, 假如要让我们自己设计这个 produce函数, 我们会怎么做, 才能保证数据的不可变性, 并保证\b运行效率. (需要更Immutable.js一样 使用了Structural Sharing, 即只有改动了, 才生成新对象)\n\n\n[Object.defineProperty](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)和[Proxy](http://es6.ruanyifeng.com/#docs/proxy)这两个方法很多人可能觉得有点陌生, \n简单的来说就是在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写\n\nimmer官网有个图很直接的展示了 immer的原理:\n\n![immer](immer.png)\n 具体的实现参考下面的简化代码\n\n```javascript\nclass Store {\n  constructor(state) {\n    this.modified = false\n    this.source = state\n    this.copy = null\n  }\n  get(key) {\n    // 如果没有修改, 就直接返回原来的对象\n    if (!this.modified) {\n        return this.source[key]\n    } else {\n        return this.copy[key]\n    }\n  }\n  set(key, value) {\n    // 如果之前未修改过\b数据,  就把modified标识设置为 true, 并\bcopy一份source数据到 this.copy上, 后续的修改都是在 this.copy 上修改,  this.copy 就是 前面demo中的 draft\n    if (!this.modified) {\n        this.modified = true\n        this.copy = Array.isArray(this.source) ? this.source.slice() : { ...this.source }\n    }\n    return this.copy[key] = value\n  }\n}\n\n\n\nexport const produce = (state, producer) => {\n\n    // 第一步: 把 state转换为 store对象\n    const store = new Store(state)\n\n    // 第二步: 添加给 store 添加一个 Proxy,劫持 数据的 get set方法\n    const PROXY_FLAG = '@@SYMBOL_PROXY_FLAG'\n    const handler = {\n        get(target, key) {\n            if (key === PROXY_FLAG) return target\n            return target.get(key)\n        },\n        set(target, key, value) {\n            return target.set(key, value)\n        },\n    }\n    const proxy = new Proxy(store, handler)\n\n    // 第三步: 执行用户修改数据的逻辑\n    producer(proxy)\n\n    // 第四步骤: 判断是否修改了数据, 如果没有, 就返回原数据, 如果有, 返回新的对象.\n    const newState = proxy[PROXY_FLAG]\n    if (newState.modified) return newState.copy\n    return newState.source\n}\n\n\n```\n\n## 函数式编程 与 数据不可变性\n\n从上面的简写版本的immer可以看出来,  对象的劫持是实现 \"数据不可变性\" 的关键的步骤. \n\n\n现在我们反过来再思考一下,  我们为什么需要 \"数据不可变性\"这个概念呢?\n\n这得从函数式编程开始讨论起来,  React核心核心开发\b团队算是函数式编程的优秀布道者, 函数式编程对于很多人来说很陌生,  新手接触的时候, 一大堆系统的概念, 很多人在网上搜索一大堆, 往往看完几篇博文之后, 连Monad的定义还是搞不清楚, 相比于一上来就是各种灌输各种概念,  React团队可谓是不知道高到哪里去了, 在React Redux框架中, 无处不体现函数式的思维, 同时也不会给开发者灌输很多函数概念, 讲究一个循序渐进的方式,  很多开发者都觉得自己离函数式编程非常远,  其实不然, 我们写的每一个 组件, 都是函数式的一个体现.\n\n函数 是函数式编程中的 \"一等公民\", 函数可以与其他数据一样，作为参数传递，或作为返回值返回\n\n```javascript\nconst add = (x, y) => x + y;\nconst multiply= (x, y) = > x * y; \nconst subtract = (x, y) => x  - y;\n\n\nlet result = subtract(multiply(add(a, b), c), d);\n```\n\n上面这段代码 等效于中学数学中的函数:  y = (a + b) * c - d\n同理很多数据公式都可以用函数式编程的方式表达出来,  那这里我们回忆一下, 以前我们上中学的时候, 列的那些数学函数, 里面那些 x, y, a , b, c 等等, 是否跟我们平时定义的变量一样, 会在运行的过程中, 发生改变?\n\n\n从上面的例子我们看到, 数学函数的运算, 就是一个函数计算完再把结果传递到下一个函数, 直到没有后续的运算. 根本是不存在变量这个说法, 只有 函数 + 输入输出.\n\n在编程语言中\b, 我们很难做到不使用变量去完全模拟 数学中的函数运算, 在很多函数中, 还是会写一些变量, 方便编码(计算机的底层就是 寄存器 + 逻辑运算单元),  比如在JS中, 函数的参数是放在一个叫做  arguments的数组中的, 我们在函数内部可以直接通过 arguments[1] 获取第一个参数,  \b设想一下, 假如这里的 arguments[1] 是可以被改变的, a函数在执行的过程中直接修改了 arguments[1], 等b函数用到 arguments[1]时, 已经是改变过的值, arguments[1]在这里是一个引用的值, 类似一个指针.  这个显然就有问题的,  比如 y = (a + b) * c - d这个函数,  在执行的时候,  a变量被其他的函数修改了, 那这里 a + b 就不等于期望的值了, 也就是说 a + b这个函数有副作用了, 它无法实现幂等的特性, 这个现象在函数式编程的世界里必然会造成一篇混乱.\n\n\n在React编程中的具体表现就是 \"浅对比\" 认为数据没有改变, 导致UI没有更新, 可以认为React在设计上, 默认数据不可变的, 利用这个特性, 使用 \"浅对比\" 来减少重复渲染的\b次数\n\n","tags":["Immer"],"categories":["前端状态管理"]},{"title":"浅析组件化时代的前端状态管理(三):数据驱动渲染","url":"%2F2019%2F02%2F19%2Ftech%2F%E6%B5%85%E6%9E%90%E7%BB%84%E4%BB%B6%E5%8C%96%E6%97%B6%E4%BB%A3%E7%9A%84%E5%89%8D%E7%AB%AF%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86(%E4%B8%89)%3A%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E6%B8%B2%E6%9F%93%2F","content":"\n\n## 为什么要把这一节叫做数据驱动渲染?\n\n在组件化时代, 各大框架都是推崇数据驱动UI渲染的, 才会有状态管理的需求场景, 所以数据驱动渲染是状态管理话题的前置条件\n\n何为数据驱动渲染?\n<!-- more -->\n用函数式编程的思维理解就是: view = render(data) 这个公式, 即同样的 data, 通过同样的 render函数, 无论执行多少次, 最终渲染到页面的展示结果\b是一样的, 具有幂等性\n\n> 幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。\n> 在编程中.一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。\n> 幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。\n\n\n## 数据驱动渲染的实现:\n\n\n假如组件都是纯函数,  那么控制最终渲染结果的是 data, 如果想修改页面展示, 只需要修改 data. \n\n那如何实现数据驱动渲染,  目前很多框架都帮我们实现了,  拿当前最热门的 React Vue 框架来举例,\n\nReact的底层会在内存中生成一个 Virtual DOM树, 整个渲染的链路是:  Model -> Virtual DOM -> 浏览器DOM\n如果要更新页面的展示, 得先修改 Model里面的数据.  React里面的 setState方法就是干这事的, 可以参考下面的一个不算太完整的伪代码理解\n\n```javascript\n\n// 渲染启动函数\nconst renderRoot = (rootComponent, rootDomNode) => {\n    // vitual dom 根节点\n    const virtualDomRoot = {\n        root: null,\n        child: null,\n        parents: null\n    }\n    // 递归遍历 rootComponent 下面的所有子节点, 并将节点挂载在 virtualDomRoot 这个树上\n    const newVirtualDomTree = renderChild(rootComponent, virtualDomRoot)\n\n    // 新老 Virtual Dom 对比, 生成一个差异 Dom Node 列表\n    const diffVirtualDomNodes = diff(newVirtualDomTree, oldVirtualDomTree)\n\n    // 将差异 Dom Node 更新到真实的浏览器的 Dom\n    patch(rootDomNode, diffVirtualDomNodes);\n}\n\n\n// 应用组件\nclass App extends Component {\n  constructor() {\n    super()\n\n    // 在这里定义 Model 层\n    this.state = {\n        value: '',\n    }\n  }\n  onChange = (event, value) => {\n    this.setState({\n        value: value\n    })\n  }\n\n  // 通过 render方法把内容更新到 Virtual DOM中, React框架会自动计算哪些 Virtual DOM节点是有改动,  有改动的元素才会被更新到浏览器的DOM中\n  render() {\n      return (\n         <div>{this.props.title}</div>\n      )\n  }\n}\n\n// 渲染入口\nrenderRoot(<App/>, document.querySelector('#root'))\n```\n真实的React的框架比上面的复杂很多, 具体的实现也有点差别, 但是大的方向上确实是这样的\n看完上述的例子大概就能理解 Model, Virtual Dom, 浏览器 Dom之前的关联\n\n\n## MVVM模式\n\nMVVM的核心是 将数据与视图绑定起来, 操作数据等同于操作视图, 数据修改后视图自动更新.\n![MVVM](https://camo.githubusercontent.com/28fc6986137a8ebe3d8b7c3380d7876b2cefd108/687474703a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f382f38372f4d56564d5061747465726e2e706e67)\n\n在React中,  View 是浏览器中的真实的 Dom,  Virtual Dom 就是其中的 ViewModel,  Model 是组件里面的 state\nReact 和 MVVM有个比较大的区别是, React 只实现单向的数据流绑定. 即 Virtual Dom中改变了,会自动更新到 浏览器额\b的Dom上.  而 Model中的数据改变,需要通过JSX中设置UI事件监听回调来修改, 并不会自动修改Model的数据\n\n\n而 Vue则是实现了比较完备的单向绑定和双向绑定的功能, Vue中实现数据驱动UI更新其实是一个更好的例子\n\n```javascript\nVue.component('example', {\n  template: '<span>{{ message }}</span>',\n  data: function () {\n    return {\n      message: '没有更新'\n    }\n  },\n  methods: {\n    updateMessage: function () {\n      this.message = '更新完成1'\n      this.message = '更新完成2'\n      this.message = '更新完成3' // 这里同一个循环中多次赋值, 只有最后一次的才会在下个循环渲染到dom上\n      console.log(this.$el.textContent) // => '没有更新'\n      this.$nextTick(function () {\n        console.log(this.$el.textContent) // => '更新完成3'\n      })\n    }\n  }\n})\n```\n\n从\b上述例子可以看到,  在Vue中, data 里面的 message 跟 template 里面的 message是绑定的, 只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。\n如果同一个 watcher 被多次触发，只会一次推入到队列中。\n这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。\n然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际渲染操作。\n上述的例子只是一个单项数据绑定的例子\n\n#### Vue如何实现数据双向绑定? \n\n当用户更改了VM层表单控件的数据时，通过v-model自动更新到M层（v-model是对表单控件的事件的封装）\n\n```javascript\n\n// Vue 双向绑定例子\n<div id='example'>\n  <input v-model=\"message\" placeholder=\"edit me\">\n  <p>Message is: {{ message }}</p>\n</div>\n\nnew Vue({\n  el: '#example',\n  data: {\n    message: 'hello'\n  }\n})\n\n\n// 使用原生JS等效实现\n<input type=\"text\" id=\"input_0\">\n<p id=\"preview_0\"></p>\n\n<script>\n  var obj = {}\n  var preview = document.querySelector('#preview_0')\n  var inputEle = document.querySelector('#input_0')\n  Object.defineProperty(obj, 'message', {\n    set: function (newVal) {\n      // 模拟 Vue 驱动页面dom更新\n      // 在 Vue 中, 并非如此粗暴的直接更新数据到Dom上, 而是要通过Vue的渲染Virtual Dom 和 异步更新队列, 批量更新到浏览器Dom中\n      inputEle.value = newVal\n      preview.textContent = newVal\n    }\n  })\n\n  \n  inputEle.addEventListener('input', function(e) {\n    // 给obj的message属性赋值，进而触发该属性的set方法, 驱动页面UI更新\n    obj.message = e.target.value  \n  })\n</script>\n```\n\n\b更多具体的实现原理可以\b参考 [深入Vue响应式原理](\nhttps://cn.vuejs.org/v2/guide/reactivity.html#%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97)\n\n## 数据驱动与MVC\n\n通过上述的例子我们可以了解到数据驱动渲染是什么, 在数据驱动的理念下, 假如我们要搭建一个复杂应用,  可以简单的把工作拆分为:  \n\n1. UI组件/容器组件的(view)\n2. 业务逻辑(controller)\n3. 状态管理(model)\n\n咋一看这个模式不就是MVC的模式嘛 , 确实, 大部分架构师在设计项目架构的时候也会遵循MVC理念, 也有很多框架在设计上遵循MVC理念,  MVC核心的理念就是强调职责分离, 各个层只专注做好自己工作\n\n在UI组件上, 有太多的开源组件可以直接复用, 极大的减轻了开发的成本,  那么开发者只需要关注好 业务逻辑 和 模型层就好了\n\n而在 业务逻辑 和 模型层中, 我们要解决的一个最大的问题就是组件间通信,  举个例子:\n\n> 一个常见的业务场景是搜索的场景, 一般我们会把 搜索输入组件 和 搜索结果分为两个组件,\n> 用户在A组件输入 \"xxxx\" 一行字符串, 这时候触发 controller层的业务逻辑, 向后端发起请求, 得到搜索结果, 并将搜索结果渲染到 B组件中\n> 这里 A 和 B是两个不同的组件,  A组件触发的动作如何更新B组件的内容呢? 这里就是隐含着组件间通信的场景了.\n\n\n在前端的页面中, 一个地方的更改, 要触发页面其他的地方的场景是在太多了, 在JQuery时代, 大家可能会觉得这都是没有必要拿出来讨论的,  不就是一个$(\"#id\").html(content) 就能解决的么?\n而这恰恰是 \"组件化 + 数据驱动\" 的理念与之前直接操作Dom的模式最大的区别, 后面的章节会详细介绍 Redux Mobx Vue 等框架, 是如何玩转 \"组件化+数据驱动\"\n","tags":["数据驱动渲染"],"categories":["前端状态管理"]},{"title":"浅析组件化时代的前端状态管理(二):原生的方式","url":"%2F2019%2F02%2F19%2Ftech%2F%E6%B5%85%E6%9E%90%E7%BB%84%E4%BB%B6%E5%8C%96%E6%97%B6%E4%BB%A3%E7%9A%84%E5%89%8D%E7%AB%AF%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86(%E4%BA%8C)%3A%E5%8E%9F%E7%94%9F%E7%9A%84%E6%96%B9%E5%BC%8F%2F","content":"\n## \b使用原生的方式管理状态\n第一类所提到的几种方式是最基础的组件通信的方式, 可以通过如下的\b一个最简单的例子, \n\n\n<!-- more -->\n\n\n#### 数据存放在父组件:\n\n```javascript\nimport React, { PureComponent, Component } from \"react\";\nimport ReactDOM from \"react-dom\";\n\n// 需求: 写一个表单信息预览卡片, 需要实现 左侧展示表单, 右侧实时展示表单的填写数据预览\n// 实现: 把 App拆成两个组件, 分别为表单组件和 表单预览组件, 组件的状态数据全部存放在App组件中,  通过 props 传递给 子组件, 子组件通过this.props.onChange 修改父组件的 state数据\n\n// 表单 输入框组件\nclass FormInput extends PureComponent {\n  render() {\n    return (\n      <>\n        输入:\n        <input onChange={this.props.onChange} value={this.props.value} />\n      </>\n      // 更多其他的输入框\n    );\n  }\n}\n\n// 表单预览组件\nclass FormPreview extends PureComponent {\n  render() {\n    return (\n      <label>预览: {this.props.value}</label>\n      //  更多其他的渲染逻辑\n    );\n  }\n}\n\nclass App extends Component {\n  constructor() {\n    super();\n    this.state = {\n      value: \"\"\n    };\n    this.onChange = this.onChange.bind(this);\n  }\n  onChange = event => {\n    this.setState({\n      value: event.target.value\n    });\n  };\n\n  render() {\n    return (\n      <div>\n        demo_2_1:\n        <FormInput value={this.state.value} onChange={this.onChange} />\n        <hr />\n        <FormPreview value={this.state.value} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n\n```\n[![Edit front_end_state_manage_demo](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/moqr8pxzqy?codemirror=1&fontsize=14&module=%2Fsrc%2Fdemo_2_1.js&moduleview=1)\n\n\n\n\n#### 使用ContextAPI实现:\n```javascript\n\nimport React, { PureComponent, Component } from \"react\";\n\n// 使用ContextAPI的方式.  如何了理解 contextAPI? 可以理解contexAPI就是一个桥梁, 可以实现props的夸组件层级传递, 比如可以把props从跟节点传递到底层的节点\n// 关于ContextAPI详情可以参考 https://reactjs.org/docs/context.html#reactcreatecontext\n\nconst FormDataContext = React.createContext({});\n\n// 输入框组件\nconst Input = () => {\n  return (\n    <FormDataContext.Consumer>\n      {props => {\n        return (\n          <>\n            输入:\n            <input onChange={props.onChange} value={props.value} />\n          </>\n        );\n      }}\n    </FormDataContext.Consumer>\n  );\n};\n\n// 表单容器\nconst FormContainer = () => {\n  return (\n    <Input />\n    // ... 其他表单字段\n  );\n};\n\n// 预览组件\nconst PreviewDetail = (props = {}) => {\n  return (\n    <FormDataContext.Consumer>\n      {props => {\n        return <label>预览:{props.value}</label>;\n      }}\n    </FormDataContext.Consumer>\n  );\n};\n\n// 预览容器\nconst PreviewContainer = () => {\n  return (\n    <PreviewDetail />\n    // ...其他预览详情内容\n  );\n};\n\nclass App extends Component {\n  constructor() {\n    super();\n    this.onChange = this.onChange.bind(this);\n    this.state = {\n      value: \"\",\n      onChange: this.onChange\n    };\n  }\n  onChange = event => {\n    this.setState({\n      value: event.target.value\n    });\n  };\n  render() {\n    return (\n      <FormDataContext.Provider value={this.state}>\n        <FormContainer />\n        <hr/>\n        <PreviewContainer />\n      </FormDataContext.Provider>\n    );\n  }\n}\n\nexport default App;\n\n```\n[![Edit front_end_state_manage_demo](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/moqr8pxzqy?codemirror=1&fontsize=14&module=%2Fsrc%2Fdemo_2_2.js&moduleview=1)\n\n\n从上面ContextAPI的例子可以看到, 我们不需要一层层的传递props到底层的节点, 只需要最外层使用Provider包裹一下, 然后再需要使用数据的底层组件使用 Consumer包裹一下,  数据就能实现从顶层到底层的跨层级传递, redux里面connect实现的原理也是如此, 后续会详细介绍.\n\n#### 自定义事件\n\n没有嵌套关系组件之间的通信可以通过自定义事件来进行通信\n\n```javascript\nimport React, { PureComponent, Component } from \"react\";\n\nclass Child_1 extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      msg: \"hello\"\n    };\n  }\n\n  componentDidMount() {\n    setTimeout(() => {\n      // 发布 msg 事件\n      document.dispatchEvent(new CustomEvent(\"msg\", { detail: \"world\" }));\n    }, 1000);\n  }\n  render() {\n    return (\n      <div>\n        <p>child_1 component: {this.state.msg}</p>\n      </div>\n    );\n  }\n}\n\nclass Child_2 extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      msg: \"\"\n    };\n  }\n\n  componentDidMount() {\n    // 监听 msg 事件\n    document.addEventListener(\n      \"msg\",\n      e => {\n        this.setState({\n          msg: e.detail\n        });\n      },\n      false\n    );\n  }\n\n  render() {\n    return (\n      <div>\n        <p>child_2 component: {this.state.msg}</p>\n      </div>\n    );\n  }\n}\n\nclass App extends Component {\n  render() {\n    return (\n      <div>\n        demo_2_3:\n        <Child_1 />\n        <Child_2 />\n      </div>\n    );\n  }\n}\nexport default App;\n\n```\n[![Edit front_end_state_manage_demo](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/moqr8pxzqy?codemirror=1&fontsize=14&module=%2Fsrc%2Fdemo_2_3.js&moduleview=1)\n\n\n组件A如果依赖组件B的状态, 可以监听组件B的状态变化事件,进而获取数据, 这种方式本质上是一种观察者模式. 和状态数据共享其实是两回事, 最终达到的目的是一样的. 在这一理念甚至已经衍生出相关的框架了 [cyclejs](http://cyclejs.cn/)\n\n\n","tags":["Vue"],"categories":["前端状态管理"]},{"title":"浅析组件化时代的前端状态管理(一):背景","url":"%2F2019%2F02%2F19%2Ftech%2F%E6%B5%85%E6%9E%90%E7%BB%84%E4%BB%B6%E5%8C%96%E6%97%B6%E4%BB%A3%E7%9A%84%E5%89%8D%E7%AB%AF%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86(%E4%B8%80)%3A%E8%83%8C%E6%99%AF%2F","content":"\n\n## 为什么要写这个文章?\n\n前端在工程化/组件化上近几年飞速发展, 生态已经相当成熟, 得益于 React Vue等前端框架的普及. 组件化的方式搭建前端页面已经是每一个前端的是标配技能了, 也极大降低了前端开发的入门门槛.  对于一个没有接触过前端的人来说(比如很多后端程序员), 只要大致了解es6语法,  看一下 React 或者 Vue 的官方文档,  使用 create-react-app 脚手架工具创建一个demo app, 基本上可以在半天内搭建出一个 简单的TODO APP, 配合上 Ant Design等流行的UI组件框架, 非专业的前端也能快速搭建起一套不错的后台管理系统. \n<!-- more -->\nUI上得益于开源的组件, 外观看上去非常现代并且简洁, UI设计语言也是高度一致, 这时候难免有些同学会觉得, 前端是在是太简单了.  不就用开源组件跟搭建积木一样把站点搭建起来嘛\n\n\n举一个简单的例子, \n\n\n\n\n```javascript\n// 需求: 写一个表单信息预览卡片, 需要实现 左侧展示表单, 右侧实时预览展示表单的填写数据\n// 实现: 简单的实现就是一个输入框,加一个label\b展示,  可以实现实时输入并预览展示\n\n\nimport React, { PureComponent, Component } from \"react\";\nimport ReactDOM from \"react-dom\";\n\nclass App extends PureComponent {\n  constructor() {\n    super();\n    this.state = {\n      value: \"\"\n    };\n    this.onInput = this.onInput.bind(this);\n  }\n  onInput(event) {\n    this.setState({\n      value: event.target.value\n    });\n  }\n  render() {\n    return (\n      <>\n        <span>demo1_1: </span>\n        <input onChange={this.onInput} value={this.state.value} />\n        <span>{this.state.value}</span>\n      </>\n    );\n  }\n}\nexport default App;\n\n```\n\n[![Edit front_end_state_manage_demo](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/moqr8pxzqy?codemirror=1&fontsize=14&module=%2Fsrc%2Fdemo1_1.js&moduleview=1)\n\n\n当然真实的需求并不会如此简单,  可能表单的输入框有十几项需要填写, 可能表单的预览展示也是有非常多的个性化展示, 在组件化思维的影响下, 一般比较好的选择是把 App 拆成多个子组件\n\n```javascript\n// 需求: 写一个表单信息预览卡片, 需要实现 左侧展示表单, 右侧实时展示表单的填写数据预览\n// 实现: 把 App拆成两个组件, 分别为表单组件和 表单预览组件\n\n\nimport React, { PureComponent, Component } from \"react\";\nimport ReactDOM from \"react-dom\";\n\n// 表单 输入框组件\nclass FormInput extends PureComponent {\n  constructor() {\n    super();\n    this.state = {\n      value: \"2234\"\n    };\n    this.onInput = this.onInput.bind(this);\n  }\n\n  onInput(event) {\n    this.setState({\n      value: event.target.value\n    });\n  }\n  render() {\n    return (\n      <>\n        输入组件:\n        <input onChange={this.onInput} value={this.state.value} />\n        <span>{this.state.value}</span>\n      </>\n      // 更多其他的输入框\n    );\n  }\n}\n\n// 表单预览组件\nclass FormPreview extends PureComponent {\n  render() {\n    return (\n      <>\n        预览部分:\n        <label>{this.props.value}</label>\n      </>\n      //  更多其他的渲染逻辑\n    );\n  }\n}\n\nclass App extends Component {\n  constructor() {\n    super();\n  }\n  render() {\n    return (\n      <div>\n        <span>demo1_2: </span>\n        <br />\n        <FormInput />\n        <hr />\n        <FormPreview />\n      </div>\n    );\n  }\n}\n\nexport default App;\n\n```\n[![Edit front_end_state_manage_demo](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/moqr8pxzqy?codemirror=1&fontsize=14&module=%2Fsrc%2Fdemo1_2.js&moduleview=1)\n\n这时候问题来了,  FormInput组件里面的数据如何传递到 FormPreview中, 所以实际上上述的例子是无法实现需求的. 如何解决? 一个最简单的方法就是把value存放在App组件中,  然后 FormInput FormPreview 共用同一个对象. \n我们这个场景比较简单,可能这样子也行得通, 假如组件的嵌套层级很深. 比如一颗深度为5的组件二叉树, 最底下的叶子节点组件要相互通信怎么办? 难道要把叶子节点的数据状态存在根节点组件上么?  如果这样做,  必然会导致非常冗余的props传递, 所以肯定不会直接这么搞的, 正常情况下大家都会默默打开搜索引擎, 输入 \"React, 组件通信, 状态管理\" 关键词, 搜索的结果大致会分为如下几类:\n\n##### 第一类: 原生的方式\n\n* 父组件向子组件通信: props\n* 子组件向父组件通信: 回调函数/自定义事件\n* 跨级组件通信: 层层组件传递props或者使用contextAPI\n* 没有嵌套关系组件之间的通信: 自定义事件\n\n##### 第二类: 第三方状态管理库\n\n引入Mobx Redux等状态管理库\n\n##### 第三类: React Hooks\n\n使用React Hooks, 例如useState/useReducer/useContext\n\n\n下面将循序渐进的介绍上述几种解决方案.\n\n\n\n\n\n\n\n","tags":["Vue"],"categories":["前端状态管理"]},{"title":"使用hexo重新整理过去的文章","url":"%2F2019%2F01%2F26%2Fdaily_think%2F%E4%BD%BF%E7%94%A8hexo%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E8%BF%87%E5%8E%BB%E7%9A%84%E6%96%87%E7%AB%A0%2F","content":"\n\n![](banner.png)\n\n最近两天使用Hexo重新整理了一下过去几年的技术/生活相关的文档, 希望后续能持续更新下去\n\nSimulay 和 Iotshine是之前上学的时候写个两个项目, 今天也用gitbook生成好文档, 在博客首页加了一个链接过去\n\n由于网上很多了就不重新写了, 这里我贴一个认为是写的比较详细的: [搭建步骤](https://zhuanlan.zhihu.com/p/35668237)\n<!-- more -->\n\n### \b花了三个小时我都做了啥?\n\n1. 首先是选一套自己的主题, 我的博客使用 next主题的 Pisces scheme, 其中的一些参数可能需要自己折腾配置一下, 我主要\b添加了: local_search, mta统计, 把底部的power by hexo隐藏了. 改动的不多, \n2. 开启_config.yml下面的post_asset_folder并添加 hexo-asset-image插件完成图片的\b插入\n3. 梳理将近 25篇文章的格式, 并添加好对应的分类和标签, 这个是最大的体力活了\n4. 把 simulay 和 iotshine这两个项目的 docs文档使用 gitbook生成并上传到对应的github pages上\n5. 把 blog仓库转为私有的了, 所以blog仓库的pages功能就用不了了, 重新注册了一个outshineamaze.github.io的参考, 专门用于存放hexo构建的代码, outshineamaze.github.io这个域名也就成为我个人首页了\n\n\n其实总的来说还是挺高效的. 上次折腾还是去年八月份, 可惜搞到一半就不想搞了, 然后就一个半成品基本是属于不能看的那种. \n\n\n### 后续维护\n\n我给自己的目标是一个月最少一篇文章,  本票文章最大的作用就是在于此, 后面可以拿出来翻一翻旧账\n后续文章可能主要围绕以下方向:\n\n1. 后端:  nodejs, go, docker, http_x, db\n2. 前端: react, vue, flutter\n3. devops: docker, ci/cd, 自动化测试, 敏捷开发\n4. 生活感悟(注意控制数量, 谁让自己平时最大的爱好就是吐槽)","tags":["hexo"],"categories":["日常"]},{"title":"全栈迁移HTTPS/HTTP2总结系列文章","url":"%2F2018%2F09%2F04%2Ftech%2Fhttps%E6%94%B9%E9%80%A0%E6%80%BB%E7%BB%93%2F","content":"\n\n# 全栈迁移HTTPS/HTTP2总结系列文章\n\n## 第一篇 - x.xx.com全站迁移HTTPS/HTTP2总结:\n\nx.xx.com全站迁移HTTPS总结系列文章导航:\n\n* (一):投放端业务迁移介绍\n\n* (二):业务HTTP排查和梳理\n\n* (三):灰度策略和错漏检测\n\n* (四):CSP与HSTS安全策略\n\n* (五):HTTPS/HTTP2与性能提升\n\n\n为了给广告主提供更安全可靠的广告系统，避免一些浏览器将系统表示为不安全, 消除广告投放端被中间人劫持插入广告,  保证广告主的账户安全.\n\n<!-- more -->\n此项工作主要处理了以下任务：\n\n1. \t系统的http调用排查和梳理：我们梳理了约10个关联产品的约20多个相关域名, 并排查出存在MixContent页面50多个\n2. \tx.xx.com 域名下8个服务的HTTPS改造：域名收归为三个域名收归为 x.xx.com (HTML和CGI),cdn.com (JS资源)cdn.com (CSS样式资源)\n3. \t HTTP2相关特性测试和支持：开启HTTP2, HTTPS下页面资源加载性能提升40%\n4. \t 灰度放量机制和错漏排查机制：设计灰度放量机制和开发配套的监控系统确保没有遗漏。\n5. \t 部署相关安全协议： Upgrade-Insecure-Requests, HSTS, CSP等\n\n\n### 整体迁移工作划分\nx.xx.com整站迁移HTTPS工作分为如下三块内容：\n\n1. 业务侧及各个依赖模块HTTPS改造\n2. 服务层接入HTTPS(NGINX)\n3. HTTPS灰度上线\n\n现在将这些工作中的一些经验和工作的技术分享如下\n\n### 业务侧http资源排查和梳理\n\n在推动x.xx.com业务代码兼容HTTPS时, 需要考虑的点非常多, 把工作上的一些要点记录了一下, 并梳理了\b几点方法论, 希望可以提供一些参考\n\n### 灰度策略和错漏检测:\n\n\n在推进HTTPS灰度的阶段, 由于投放端依赖的服务众多, 项目历史包袱较重, 即便是收归了域名之后, 在项目代码中 做了全部的资源url 替换, 有部分资源url是写的数据库中的, 或者是第三方服务加载的. 这部分请求是http的, HTTPS 网页中加载的 HTTP 资源被称之为 Mixed Content（混合内容）. 这种场景首先考虑的时候使用 使用 Content-Security-Policy: upgrade-insecure-requests 升级不安全的请求。\n\n但是面临的问题是: 我们不知道这些触发MixContent的资源是否支持https, 所以前期先部署了 MixContent上报策略.\nContent-Security-Policy-Report-Only: block-all-mixed-content\n\n\n通过近两周的每日MixContent上报统计, 我们排查出 x.xx.com 下面所有的 MixContent, 并逐个推进排查(排查的依赖域名20+, 存在MixContent页面50+)\n\n\n通过两周的排查, 并确认所有的 http资源请求都支持 https之后 , 再部署了 upgrade-insecure-requests策略. 到达这个阶段就完整的实现了灰度的用户 地址栏的绿色协议头不会因为MixContent灰掉了.\n\n\n上线upgrade-insecure-requests策略之后, https页面下http的请求会自动升级为https, 如果存在某些资源不支持https, 同时我们在MixContent排查阶段没有发现, 那么这个资源就会404, 我们在x.xx.com下所有的业务都引入异常上报, 对页面资源 404的进行上报,  经过一周的统计, 没有发现有集中的某个资源404, 初步可以确定当前投放端下所有的资源都是支持https, 也回归验证了MixContent排查的效果. 异常上报的接入可以参考: badjs\n\n### HSTS&CSP安全策略:\n\n\n在网站全站HTTPS后，如果用户手动敲入网站的HTTP地址，或者从其它地方点击了网站的HTTP链接，通常依赖于服务端301/302跳转才能使用HTTPS服务。而第一次的HTTP请求就有可能被劫持，导致请求无法到达服务器，从而构成HTTPS降级劫持。 \nHSTS的作用是强制客户端（如浏览器）使用HTTPS与服务器创建连接。\n当客户端通过HTTPS发出请求时，在服务器返回的超文本传输协议（HTTP）响应头中包含Strict-Transport-Security字段。\n比如，https://x.xx.com/ 的响应头含有Strict-Transport-Security: max-age=31536000; 这意味着：\n在接下来的一年中，浏览器向x.xx.com发送HTTP请求时，浏览器应当自动将 http 转写成 https.\n\n### HTTP2与性能提升:\n\n\n![http 与http2加载性能对比](1536054679_7.png)\n从上面两个图可以看出, HTTP模式下, 资源的请求仍然遵循Chrome对同一源最大6个TCP连接的规则, 从timeline看出HTTP下多个tcp的stalled的时间(灰色部分)总和比较长, 呈现瀑布状   \n在HTTP2 下, 由于tcp连接的多路复用, 可以可以看出整个stalled的时间(灰色部分)大致为一个tcp的时间. \n从整个耗时来算,  HTTP2下加载20个js资源耗时110ms, HTTP下耗时 180ms,  我们在升级HTTPS/HTTP2之后, 在js css等静态资源的加载上反而比之前快了40%左右.\n\n\n### 开发测试环境全环境HTTPS化\n\n在部署https的同时, x.xx.com也部署了 HSTS策略(HTTP严格传输安全), 而我们在开发测试环境中会经常使用HTTP请求来开发调试, 目前已经在开发测试环境预发布环境全部部署了HTTPS证书, 为了跟外网环境保持高度一致, 建议在开发测试中使用https协议. 如果遇到需要抓包的场景, 建议配置代理的HTTPS抓包支持:\n\n* [fiddler](https://blog.csdn.net/idlear/article/details/50999490)\n* [Charles](https://juejin.im/post/5a30a52a6fb9a0451d4175ed)\n* [whistle](https://whistle.gitbooks.io/help/content/webui/https.html)\n\n如果一定需要使用http访问, 可以chrome://net-internals/#hsts  删除对应的域名的 hsts缓存即可\n\n\n## 第二篇 - 老业务HTTP排查和梳理\n\n在推动x.xx.com老的业务代码兼容HTTPS时, 需要考虑的点非常多, 其中重要的包括如下几点:\n\n1. 不能简单的做全局替换:   x.xx.com整个站点下依赖的各种服务约十多个, 各种资源和域名超过五十多个, 全局替换的问题在于, 如何确认这些依赖的域名都支持HTTPS了, 貌似没有比较好的办法, 只能全局搜索并一个个梳理出来一个个推动改造, 最好是有一个check list,  详细的记录各个服务或者资源被调用的地方, 目前是否支持https, 当前推进的进度,  相关的负责人, 截止的时间点等等, 定期去review各个模块的进度\n\n\n2. 并非所有的资源或者URL都在代码库中:  比如在广告投放端中, 有很多URL是写入到DB中的, 或者CGI层只是作为一个透传, 下面还依赖好几层更底层的服务,   而且这些URL调用方并非是只有投放端,  最开始的反应是在CGI层做一层替换, 例如获取qq信息等我们可以通过修改透传数据接口, 强行修改返回的url协议头, 但是更多接口对于返回的内容是不确定的, 贸然修改 成本高, 风险也高. 针对这种情况, 我们的处理方式是: 使用Upgrade-Insecure-Requests策略,  但是需要所有的资源的域名都支持https, 那么问题来了, 如何确认这些域名都支持https?  可以参考一篇文章看看我们是如何在灰度的流程中做minxContent上报错漏检测\n\n3. 并非所有的依赖方能及时支持https\b改造, 甚至有些老的接口已经处于不在维护的状况. 建议CGI层统一对这些不支持https的服务做一层封装转发, 系统尽量只依赖CGI的接口, 减少在前端做跨域跨系统的请求\n\n4. 一些底层的库  还有一些项目本身依赖旧的底层库, 里面有部分异步请求加载模块, 有部分异步加载模块的URL都是固定http协议头的, 如果短时间没有办法剔除前端代码对这些模块的依赖, 只能强行拉取代码进行升级兼容. 比如 底层的上报地址需要修改// 的兼容模式, 测速上报可以修改为 (location.protocol === 'https:' ? '//report.xxx.com/cgi-bin/r.cgi' : '//report.xxx.com//cgi-bin/r.cgi') + params.join('&')\n\n5. 开发,测试环境, 预发布环境要先支持https, 最好的方式联系 运维提供相关的证书,  部署到开发环境和测试环境, 和外网保持高度一致. 推动各环境 部署https证书也是做https改造的一个重要准备工作之一, 建议在做完这块的工作之后, 把各个环境, 各个域名的证书的负责人落地实到wiki或者邮件中去\n\n\n\n## 第三篇 - 灰度策略和错漏检测:\n\n在”(一):投放端业务迁移介绍”文章中提到过,, https全站改造第三个的步骤就是灰度上线, 那么如何设置灰度的策略,并且真正利用灰度这个流程来推动https改造.\n\n先看一下x.xx.com灰度的流程:\n\n1. 开始1%的灰度放量\n2. 上线MixContent上报策略, 以及相关的统计日报表\n3. 在灰度1%-20%期间, 通过MixContent统计的来逐步排查页面中遗漏的http资源\n3. 上线资源404上报机制, 用于排查因为某些静态资源站点不支持https导致的404错误\n5. HTTPS页面部署Upgrade-Insecure-Requests策略, HTTPS页面下http请求自动升级为 HTTPS\n6. 灰度到50%, 观察两周.\n7. 全量, http请求默认重定向到https请求, 并开启HSTS策略\n\n这里有两个关键点:\n\n1. 灰度期间外网同时支持https 和 http, 方便用户在https有问题的时候直接切换为http的页面\n2. 在灰度的前期, 我们允许https页面MixContent的情况出现(地址栏协议头变灰)\n\n在推进HTTPS灰度的阶段, 由于投放端依赖的服务众多, 项目历史包袱较重, 即便是收归了域名之后, 在项目代码中 做了全部的资源url 替换, 有部分资源url是写的数据库中的, 或者是第三方服务加载的. 这部分请求是http的, HTTPS 网页中加载的 HTTP 资源被称之为 Mixed Content（混合内容）. 这种场景首先考虑的时候使用 使用 Content-Security-Policy: upgrade-insecure-requests 升级不安全的请求。\n\n#### [upgrade-insecure-requests](https://www.w3.org/TR/upgrade-insecure-requests/)\n首先它是一个 CSP 指令。 W3C 工作组考虑到了我们升级 HTTPS 的艰难，在 2015 年 4 月份就出了一个 Upgrade Insecure Requests 的草案，他的作用就是让浏览器自动升级当前页面内容的http请求。 对于页面内的 图片 样式 js XHR 等请求生效,  但是对于a标签跳转不会生效.  同时,当自动升级https请求失败时, 不会自动降级到http, 资源就404或者网络错误了.\n\n\n所以我们面临的问题是: 不知道这些触发MixContent的资源是否支持https, 所以前期先部署了 MixContent上报策略\n\n#### MixContent上报策略: \nContent-Security-Policy-Report-Only: block-all-mixed-content\n\nContent-Security-Policy-Report-Only 可以让我们只上报违反CSP策略的情况, 而不会真正的拦截这些MixContent资源\nblock-all-mixed-content: 这条指令在当前页面为通过 HTTPS 协议加载的情况下禁止通过 HTTP 渠道加载任何资源。任何混合类型的资源请求都是被禁止的，包括混合活动内容和混合被动内容。这一条也适用于 iframe 中的文档，确保整体页面都不包含混合内容。\n\nupgrade-insecure-requests 指令会在 block-all-mixed-content 之前执行；如果前者执行成功，后者就不再发挥任何作用。推荐的做法是设置二者之一，而不是全部\n\n\n#### MixContent数据统计和查询\n\n配置MixContent上报数据之后, 需要同步上线MixContent数据统计和查询\n\n![数据统计和查询](1536054571_65.png)\n\n通过近两周的每日MixContent上报统计, 我们排查出 x.xx.com 下面所有的 MixContent, 并逐个推进排查(排查的依赖域名20+, 存在MixContent页面50+)\n\n\n确认所有的 http资源请求都支持 https之后 ,  再部署了 upgrade-insecure-requests策略. 到达这个阶段就完整的实现了灰度的用户 地址栏的绿色协议头不会因为MixContent灰掉了\n\n#### 资源加载失败上报\n\n上线upgrade-insecure-requests策略之后, https页面下http的请求会自动升级为https, 如果存在某些资源不支持https, 同时我们在MixContent排查阶段没有发现, 那么这个资源就会404, 我们在x.xx.com下所有的业务都引入异常上报, 对页面资源 404的进行上报,  经过一周的统计, 没有发现有集中的某个资源404, 初步可以确定当前投放端下所有的资源都是支持https, 也回归验证了MixContent排查的效果. 异常上报的接入可以参考 badjs\n\n\n\n## 第四篇 - CSP与HSTS安全策略\n\n在全站升级HTTPS之后, 并不意味着站点就是安全的, 本文主要从 HTTPS重定向劫持 HSTS策略, CSP策略 这三个方面讲述\b投放端在web页面安全这块的建设\n\n#### HTTPS 重定向劫持\n\n![](1536074678_5.png)\n\n1. 重定向劫持劫持 攻击\n 中间人一旦发现有重定向到 HTTPS 网站的，拦下这个重定向，然后以 HTTPS 的方式，获取重定向后的内容，最后再以 HTTP 明文的方式，回复给用户。\n2. 重定向劫持之后一般会把页面中的https 请求替换为 http的, 不然第一次劫持了后面客户端依旧发起的是 https 的请求,无法劫持. 传统的方案是在中间人代理层替换 就是经典的中间人攻击工具 —— SSLStrip\n3. 新的攻击方案是在首次劫持返回的前端html 页面中插入代码, 劫持用户的https超链接, 降级为 http\n 4. 页面被 ssl 劫持之后, 攻击者面对的主要问题是如果保证页面再次发起的请求是 http的, \n页面批量超链接替换, 表单提交,window.open 弹窗,框架页面都是需要进行http降级处理的,否则就报跨域错误了.\n\n分析了攻击方法, 下面是应对的方案:\n\n通过代码跳转, 混淆替换代码明文的 https 超链接, 部署hsts\n\nhttp://blog.jobbole.com/78590/?utm_source=blog.jobbole.com&utm_medium=relatedPosts\n\n#### HTST:\nHTTP Strict Transport Security (HSTS)\n访问网站时，用户很少直接在地址栏输入https://，总是通过点击链接，或者3xx重定向，从HTTP页面进入HTTPS页面。攻击者完全可以在用户发出HTTP请求时，劫持并篡改该请求。\n另一种情况是恶意网站使用自签名证书，冒充另一个网站，这时浏览器会给出警告，但是许多用户会忽略警告继续访问。\n\"HTTP严格传输安全\"（简称 HSTS）的作用，就是强制浏览器只能发出HTTPS请求，并阻止用户接受不安全的证书。\n它在网站的响应头里面，加入一个强制性声明。以下例子摘自维基百科。\n\nStrict-Transport-Security: max-age=31536000; includeSubDomains\n\n上面这段头信息有两个作用。\n（1）在接下来的一年（即31536000秒）中，浏览器只要向example.com或其子域名发送HTTP请求时，必须采用HTTPS来发起连接。用户点击超链接或在地址栏输入http://www.example.com/，浏览器应当自动将http转写成https，然后直接向https://www.example.com/发送请求。\n（2）在接下来的一年中，如果example.com服务器发送的证书无效，用户不能忽略浏览器警告，将无法继续访问该网站。\nHSTS 很大程度上解决了 SSL 剥离攻击。只要浏览器曾经与服务器建立过一次安全连接，之后浏览器会强制使用HTTPS，即使链接被换成了HTTP。\n该方法的主要不足是，用户首次访问网站发出HTTP请求时，是不受HSTS保护\n\nhttps 安全问题不仅仅是后端只监听一个443端口就能解决的的事情, 更有前端的页面降级ssl 劫持, 重定向劫持等安全问题需要我们去关注\n\n##### 开发测试环境全环境HTTPS化\n\n在部署https的同时, x.xx.com也部署了 HSTS策略(HTTP严格传输安全), 而我们在开发测试环境中会经常使用HTTP请求来开发调试, 目前已经在开发测试环境预发布环境全部部署了HTTPS证书, 为了跟外网环境保持高度一致, 建议在开发测试中使用https协议. 如果遇到需要抓包的场景, 建议配置代理的HTTPS抓包支持:\n\n* [fiddler](https://blog.csdn.net/idlear/article/details/50999490)\n* [Charles](https://juejin.im/post/5a30a52a6fb9a0451d4175ed)\n* [whistle](https://whistle.gitbooks.io/help/content/webui/https.html)\n\n如果一定需要使用http访问, 可以chrome://net-internals/#hsts  删除对应的域名的 hsts缓存即可\n\n\n\n#### CSP\n\n在x.xx.com 全站迁移HTTPS过程中, 主要使用的CSP规则是 upgrade-insecure-requests 和 block-all-mixed-content, 作为在灰度升级阶段的一个辅助工具. 而在全站https之前, 我们是如何保证投放端的页面安全呢? 使用主要还是CSP规则, 同时配合投放端自研的监控上报系统进行数据展示(MixContent上报也是基于这个系统)\n![csp_report](1536074823_57.png)\n即使在升级\bHTTPS之后, 在页面安全这块依旧不能掉以轻心\n\n\n\n## 第吴篇 - HTTPS/HTTP2与性能提升\n\n## 升级后的性能对比\n\n![http 与http2加载性能对比](1536075062_36.png)\n从上面两个图可以看出, HTTP模式下, 资源的请求仍然遵循Chrome对同一源最大6个TCP连接的规则, 从timeline看出HTTP下多个tcp的stalled的时间(灰色部分)总和比较长, 呈现瀑布状   \n在HTTP2 下, 由于tcp连接的多路复用, 可以可以看出整个stalled的时间(灰色部分)大致为一个tcp的时间. \n从真的耗时来算,  HTTP2下加载20个js资源耗时110ms, HTTP下耗时 180ms,  我们在升级HTTPS之后, 在js css等静态资源的加载上反而比之前快了40%左右.\n\n\n后面继续探究性能提升背后的原理.\n\n\n## 一个HTTPS请求为例，简单描述下接入转发流程：\n\n\n用户发起HTTPS请求，首先到达网关入口。\n网关入口将该请求转发给https网关入口。由于网关入口只是四层的转发，所以无法识别HTTPS请求内容。\nhttps网关入口会对HTTPS请求进行卸载，也就是完成SSL握手及应用层内容的解密，将HTTPS转换成HTTP协议，再按照分流配置转发给业务侧RS。\n业务侧收到HTTP请求后，生产响应内容并回复给https网关入口。\nhttps网关入口将业务的响应内容进行加密，回复给网关入口。\n网关入口再返回给用户。\n\n\n了解过一个https请求的链路之后, 我们将从 TLS 和 HTTP/2 这两\b方方向分析性能提升背后的原理\n\n\n## TLS 优化\n\n耗时:\n```\ncurl -w \"TCP handshake: %{time_connect}, SSL handshake: %{time_appconnect}\\n\" -so /dev/null https://x.xx.com\nTCP handshake: 0.012235, SSL handshake: 0.044042\n```\n网关 的对其 tsl 握手的优化\n\n\n网关针对HTTPS进行了全方位的优化。包括：\n##### 非对称加密—-异步代理计算\n    算法分离。\n    代理计算\n    异步执行。\n##### 网络协议栈全链路优化\n    TCP。包括拥塞窗口的调整，tcp fast open的支持，reuseport的支持。\n    SSL，分布式session cache, session ticket，False start, ocsp stapling file，动态record size等。\n    应用层。同时支持SPDY，HTTP2.\n##### 前后端优化\n    域名收归。通过页面资源及性能分析，确实域名收归方案，比如移动页面不超过3个\n    预建连接。https网关入口提供预连接页面，通过对热点页面的用户行为进行分析，提前建立连接，减少协议开销对用户体验的影响。\n    通过CDN及多地IDC就近完成HTTPS卸载。\n\n##### session identifier\nSession Identifier（会话标识符），是 TLS 握手中生成的 Session ID。服务端可以将 Session ID 协商后的信息存起来，浏览器也可以保存 Session ID，并在后续的 ClientHello 握手中带上它，如果服务端能找到与之匹配的信息，就可以完成一次快速握手。\n\n##### Session Ticket\nSession Identifier 机制有一些弊端，负载均衡中，多机之间往往没有同步 Session 信息，如果客户端两次请求没有落在同一台机器上就无法找到匹配的信息；2）服务端存储 Session ID 对应的信息不好控制失效时间，太短起不到作用，太长又占用服务端大量资源。\n而 Session Ticket（会话记录单）可以解决这些问题，Session Ticket 是用只有服务端知道的安全密钥加密过的会话信息，最终保存在浏览器端。浏览器如果在 ClientHello 时带上了 Session Ticket，只要服务器能成功解密就可以完成快速握手。\n部署的需要注意: 例如在 Nginx 中，就需要通过 ssl_session_ticket_key 参数让多台机器使用相同的 key 文件\n\n\n## HTTP/2\n\n相比 HTTP/1.x，HTTP/2 在底层传输做了很大的改动和优化：\n1.\tHTTP/2 采用二进制格式传输数据，而非 HTTP/1.x 的文本格式。二进制格式在协议的解析和优化扩展上带来更多的优势和可能。\n2.\tHTTP/2 对消息头采用 HPACK 进行压缩传输，能够节省消息头占用的网络的流量。而 HTTP/1.x 每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。头压缩能够很好的解决该问题。\n3.\t多路复用，直白的说就是所有的请求都是通过一个 TCP 连接并发完成。HTTP/1.x 虽然通过 pipeline 也能并发请求，但是多个请求之间的响应会被阻塞的，所以 pipeline 至今也没有被普及应用，而 HTTP/2 做到了真正的并发请求。同时，流还支持优先级和流量控制。\n4.\tServer Push：服务端能够更快的把资源推送给客户端。例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 再发送这些请求。当客户端需要的时候，它已经在客户端了。\n\n本次x.xx.com迁移HTTPS 并且升级到HTTP2主要使用到的特性是 TCP的多路复用, 在收归静态资源域名之后, 减少TCP握手环节的耗时, 也减少了\bTSL握手的耗时. 对静态资源的并行加载性能提升非常明显\n\n\n文末的HTTP2.0总结文档中详细的对比了HTTP/2 与 HTTP1.X, 对HTTP2关键的四个特性做了原理上的分析. \n另外关于传输层安全也有一篇翻译文档专门介绍  [传输层安全性(Transport Layer Security,TLS)-译](https://segmentfault.com/a/1190000008656644)","tags":["https"],"categories":["网络协议"]},{"title":"浅谈React事件系统-事件绑定","url":"%2F2018%2F01%2F25%2Ftech%2F%E6%B5%85%E8%B0%88React%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%2F","content":"\n\n浅谈React事件系统主要分为两篇:\n\n\n[浅谈React事件系统-事件绑定](事件绑定)\n[浅谈React事件系统-源码解读](源码解读)\n\n## 场景\n\n一位同事在群里抛出一个问题, 假设一个列表有800个节点, 给每个节点都绑定一个 onClick事件, 如果下面这样子写页面就会有非常卡\n<!-- more -->\n\n```\n<ul>\n    {\n        list.map((item) => {\n            return (<li \n                value={item.value}\n                onClick={(event) => {onClick(event, item.desc)}\n                ></li>)\n            })\n    }\n</ul>\n```\n\n假如当这个list的长度为800个节点的时候, 每次渲染都会进行都会由于生成一个新的匿名函数 (event) => {onClick(event, data) , props.onClick的已用发生改变, 导致li这个组件会重新执行render, 如果是 800个节点, 自然就卡了. \n\n要解决不卡顿, 就要保证每次传入的onClick引用不发生变化\n<!-- more -->\n### 先声明事件处理函数\n\n不推荐在大量节点的场景使用下面的绑定事件方式\n\n```\n    onClick={this.handleClick.bind(this)} \n    onClick={(event) => {onClick(event, data)}\n```\n\n这种方式, 因为bind本身就是产生一个新的函数.  这两种的onClick引用会发生变化, 在使用PureComponent的时候, 容易触发重复的渲染\n\n推荐在类里面先声明好事件处理函数\n\n```\nclass App extends PureComponent {\n    constructor(props) {\n        super(props)\n    }\n    // 箭头函数自动绑定this作用域 \n    // 这种类实例的公共属性方法 在 ES2018 stage-3\n    _onClick = (e) => {\n        console.log(e)\n    }\n    // 构造器声明也会在初始化的时候绑定this作用域\n    _onClick(e) {\n        console.log(e)\n    }\n    render() {\n        return (\n            <button onClick={this._onClick}></button>\n        )\n    }\n}\n```\n\n### 解决参数传递\n\n1. 直接给组件传入已经定义好的方法, 我们先在组件里面定义个onClick方法, 当然这样子也会有问题, 假如我要传入相关的数据咋办, 比如我要传一个desc的字符串到 onClick方法里面, 怎么实现,  这里我们可以通过data-xxx的属性来实现, 在onClick中只需要 event.tcurrentTarget.dataset.desc就可以获取到 desc字符串了.\n\n```\nclass App extends PureComponent {\n    const _onClick = (event) =>　{\n        const desc = event.currentTarget.dataset.desc\n        // other code.....\n    }\n    render() {\n        return (\n            <ul>\n                {\n                    list.map((item) => {\n                        return (<li \n                            value={item.value}\n                            data-desc={item.desc}\n                            onClick={this._onClick}\n                            ></li>)\n                    })\n                }\n            </ul>)\n    }\n}\n```\n\n2. 把list 转换为 listMap的结构, 每次只需要传入索引值, 在onClick方法里面从 listMap 中取值\n\n```\nclass App extends PureComponent {\n    constructor(props) {\n        super(props)\n        this.listMap = list.reducer((pre, item) => {\n            pre[item.value] = item.desc\n            return pre \n        }, {})\n    }\n    const _onClick = (event) =>　{\n        const desc = this.listMap[event.curentTarget.value]\n        // other code.....\n    }\n    render() {\n        return (\n            <ul>\n                {\n                    list.map((item) => {\n                        return (<li \n                            value={item.value}\n                            data-desc={item.desc}\n                            onClick={this._onClick}\n                            ></li>)\n                    })\n                }\n            </ul>)\n    }\n}\n```\n\n\n### 下文引言\n\n在完成重构Tree组件的过程中, 为了追求最好的性能, 我也对代码进行如上的改造, 这一改就出问题了\n\n>每个人都有这样子一种经历吧, 因为某些意外的原因看到一些特殊的现象, 就以为自己发现新大陆了.\n\n在改造代码过程中, 发现每次onClick事件中event对象中的currentTarget都是指向 document, 由于自己接触过一点react的事件模型, React的所有的事件都是绑定到 document上面, 并不是绑定到元素上面的. 所以看整个dom树只有document是绑定了事件的. 然后再由React事件系统去分发事件, 这样子一联想, 可不得了, 我就以为自己发现React事件模型的bug了, 作为这么成熟的前端框架, 居然currentTarget这个属性都有问题了,这明显是不合理的.....  我把我的发现分享到群里, 结果脸好疼.....\n\n痛定思过, 重新写demo来排查问题, 结果是自己的代码逻辑错误, 同时也研究了一下React Event源码\n\n","tags":["react"],"categories":["React"]},{"title":"浅谈React事件系统-源码解读","url":"%2F2018%2F01%2F25%2Ftech%2F%E6%B5%85%E8%B0%88React%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%2F","content":"\n浅谈React事件系统主要分为两篇:\n\n[浅谈React事件系统-事件绑定](事件绑定)\n[浅谈React事件系统-源码解读](源码解读)\n\n## 准备工作\n\n-  去github下载一份源码[react v16.2.0](https://github.com/facebook/react/releases/tag/v16.2.0)\n-  下载一个好用的编辑器, 支持快速定位到当前function的引用\n<!-- more -->\n## 概念\n\n在理解React中如何实现一个事件之前, 需要声明几个概念:\n\n1.  React中几乎所有的事件都是代理到document监听\n2.  事件是由统一的分发函数dispatchEvent进行分发\n3.  事件对象(event)是合成对象(SyntheticEvent), 是原生的event对象的超集\n\n## 事件处理步骤\nReact的事件系统主要分为四部曲: \n\n1. 事件绑定:  在初始化组件时, 会根据当前组件传入的事件属性, 在document上绑定对应的事件及其依赖的事件\n\n2. 事件分发:  页面组件触发的事件根据冒泡机制, 最后会被document上的listener捕获,  之后统一由dispatchEvent进行分发, 从触发事件的节点往上递归其祖先节点, 把事件分发给它们\n\n3. 事件合成: 当节点拿到一个事件之后, 首先要进行根据事件的类型, 进行事件的合成, React有个基础的SyntheticEvent对象,  事件合成就是根据事件类型给这个对象添加该事件才有的属性\n\n4. 事件回调函数执行: 获取Fiber(虚拟dom)中的事件回调函数, 执行它\n\n<!-- more -->\n## 源代码\n\n```\n引用源码里面的一个图来描述React的事件系统\n/*\n * Overview of React and the event system:\n *\n * +------------+    .\n * |    DOM     |    .\n * +------------+    .\n *       |           .\n *       v           .\n * +------------+    .\n * | ReactEvent |    .\n * |  Listener  |    .\n * +------------+    .                         +-----------+\n *       |           .               +--------+|SimpleEvent|\n *       |           .               |         |Plugin     |\n * +-----|------+    .               v         +-----------+\n * |     |      |    .    +--------------+                    +------------+\n * |     +-----------.--->|EventPluginHub|                    |    Event   |\n * |            |    .    |              |     +-----------+  | Propagators|\n * | ReactEvent |    .    |              |     |TapEvent   |  |------------|\n * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|\n * |            |    .    |              |     +-----------+  |  utilities |\n * |     +-----------.--->|              |                    +------------+\n * |     |      |    .    +--------------+\n * +-----|------+    .                ^        +-----------+\n *       |           .                |        |Enter/Leave|\n *       +           .                +-------+|Plugin     |\n * +-------------+   .                         +-----------+\n * | application |   .\n * |-------------|   .\n * |             |   .\n * |             |   .\n * +-------------+   .\n *                   .\n *    React Core     .  General Purpose Event Plugin System\n */\n```\n\n### 事件绑定:\n\n初始化一个组件的会调用 ensureListeningTo 给document对象绑定事件. \n比如一个子组件绑定了一个onChange事件, \n根据事件的冒泡机制, 那么document对象就要绑定一个onChange事件, \n下面的代码就是根据不同的标签类型, 给document绑定不同的事件\n```\n// react-dom/src/client/ReactDOMFiberComponent\nexport function setInitialProperties(){\n  switch (tag) {\n    case 'iframe':\n    ...\n    case 'select':\n      ReactDOMFiberSelect.initWrapperState(domElement, rawProps);\n      props = ReactDOMFiberSelect.getHostProps(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n      ...\n    default:\n      props = rawProps;\n  }\n}\n\n// 这段代码主要就是给document绑定需要监听的事件\nfunction ensureListeningTo(rootContainerElement, registrationName) {\n  var isDocumentOrFragment =\n    rootContainerElement.nodeType === DOCUMENT_NODE ||\n    rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;\n  var doc = isDocumentOrFragment\n    ? rootContainerElement\n    : rootContainerElement.ownerDocument;\n  listenTo(registrationName, doc);\n}\n\n```\n\nensureListeningTo 最终是调用listenTo方法,  listenTo主要作用是解决事件的依赖问题, 比如\nonMouseEnter实际是依赖于 'topMouseOut', 'topMouseOver'两个事件, 所以document也要注册这两个事件\n\n最终都是调用 trapCapturedEvent 或者 trapBubbledEvent 两个方法来进行实际的事件注册\n\n```\n// react-dom/src/event/ReactBrowserEventEmitter\nexport function listenTo(registrationName, contentDocumentHandle) {\n  var mountAt = contentDocumentHandle;\n  var isListening = getListeningForDocument(mountAt);\n  var dependencies = registrationNameDependencies[registrationName];\n\n  for (var i = 0; i < dependencies.length; i++) {\n    var dependency = dependencies[i];\n    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {\n      if (dependency === 'topScroll') {\n        trapCapturedEvent('topScroll', 'scroll', mountAt);\n        ...\n        ...\n      } else if (topLevelTypes.hasOwnProperty(dependency)) {\n        trapBubbledEvent(dependency, topLevelTypes[dependency], mountAt);\n      }\n      isListening[dependency] = true;\n    }\n  }\n}\n```\n\n\n```\n// react-dom/src/event/ReactDOMEventListener\nexport function trapBubbledEvent(topLevelType, handlerBaseName, element) {\n  if (!element) {\n    return null;\n  }\n  return EventListener.listen(\n    element,\n    handlerBaseName,\n    dispatchEvent.bind(null, topLevelType),\n  );\n  // EventListener.listen 可以类似于下面的代码, 但是做了一些平台上的兼容\n  // react有个merge request: Remove EventListener fbjs utility\n  // 就是直接用下面addEventListener的替换EventListener.listen, 但是拒绝了\n  element.addEventListener(\n     handlerBaseName,\n     dispatchEvent.bind(null, topLevelType),\n     true,\n   );\n}\n```\n\n这时候, 已经完成第一个步骤: 事件绑定, 下面看一下事件是如何分发的\n\n### 事件分发\n\n```\n// react-dom/src/event/ReactDOMEventListener\nexport function dispatchEvent(topLevelType, nativeEvent) {\n  var nativeEventTarget = getEventTarget(nativeEvent);\n  var targetInst = getClosestInstanceFromNode(nativeEventTarget);\n  \n  // 生成一个BookKeeping的对象,包含 事件类型, 原生事件, 触发事件的target的实例\n  var bookKeeping = getTopLevelCallbackBookKeeping(\n    topLevelType,\n    nativeEvent,\n    targetInst,\n  );\n\n  try {\n    \n    // 下面的代码等同于 handleTopLevelImpl(bookKeeping), 后面可能会拓展batchedUpdate方法\n    // 目前只是预留了一个借口, handleTopLevelImpl里面有个for循环拿出来才叫 batchedUpdate吧\n    batchedUpdates(handleTopLevelImpl, bookKeeping);\n  } finally {\n    releaseTopLevelCallbackBookKeeping(bookKeeping);\n  }\n}\n\n\nfunction handleTopLevelImpl(bookKeeping) {\n  var targetInst = bookKeeping.targetInst;\n  var ancestor = targetInst;\n  // 这里要做遍历触发事件的虚拟dom节点,以及该节点的祖先节点, 存到ancestors里面去\n  // 这个地方要把祖先的Fiber对象(virtual dom)存起来, 因为在_handleTopLevel可能会改变Fiber树(virtual dom tree)结构\n  do {\n    if (!ancestor) {\n      bookKeeping.ancestors.push(ancestor);\n      break;\n    }\n    var root = findRootContainerNode(ancestor);\n    if (!root) {\n      break;\n    }\n    bookKeeping.ancestors.push(ancestor);\n    ancestor = getClosestInstanceFromNode(root);\n  } while (ancestor);\n\n  // 遍历 ancestors祖先节点, 调用 _handleTopLevel 方法去处理事件\n  for (var i = 0; i < bookKeeping.ancestors.length; i++) {\n    targetInst = bookKeeping.ancestors[i];\n    _handleTopLevel(\n      bookKeeping.topLevelType,\n      targetInst,\n      bookKeeping.nativeEvent,\n      getEventTarget(bookKeeping.nativeEvent),\n    );\n  }\n}\n\n```\n\n到这里, 假设有一个节点被点击了, 触发了onClick事件一直冒泡到document,  document监听到这个事件, 触发 dispatchEvent方法, 遍历触发事件节点的祖先.\n\n现在, 一个事件已经被dispatch了. 下面就是要进入到处理具体的某个事件的逻辑了\n\n### 事件合成与处理 Mixin\n\n事件合成与处理 Mixin: handleTopLevel 主要有三个逻辑\n\n1. 构造合成的事件\n2. 把合成事件push到 eventQueue\n3. processEventQueue处理eventQueue里面的事件\n\n```\n// event/ReactEventEmitterMixin.js\nexport function handleTopLevel(\n  topLevelType,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget,\n) {\n    // 合成事件\n  var events = extractEvents(\n    topLevelType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget,\n  );\n  // 把合成的事件合并到事件队列里面\n  enqueueEvents(events);\n  // 处理事件队列里面的事件\n  processEventQueue(false);\n}\n\n```\n\n### 事件合成\n\n#### 合成事件(SyntheticEvent)\n\nReact的事件系统有很多种事件合成的插件(Plugin), 这些插件就是根据不同的事件类型, 给SyntheticEvent加各种事件特性\n\n```\nexport function extractEvents(\n  topLevelType: string,\n  targetInst: Fiber,\n  nativeEvent: AnyNativeEvent,\n  nativeEventTarget: EventTarget,\n) {\n  var events;\n  for (var i = 0; i < plugins.length; i++) {\n    // Not every plugin in the ordering may be loaded at runtime.\n    var possiblePlugin: PluginModule<AnyNativeEvent> = plugins[i];\n    if (possiblePlugin) {\n        // 这里的extractedEvents 就是一个 合成事件(SyntheticEvent)对象\n      var extractedEvents = possiblePlugin.extractEvents(\n        topLevelType,\n        targetInst,\n        nativeEvent,\n        nativeEventTarget,\n      );\n      if (extractedEvents) {\n        // accumulateInto这个方法实际上就是拼接两个数组\n        // 把每个插件合成的事件压到events数组里面\n        events = accumulateInto(events, extractedEvents);\n      }\n    }\n  }\n  return events;\n}\n\n```\n\n#### 主要的Plugin:\n\n1. SimpleEventPlugin\n2. TapEventPlugin\n3. Enter/LeavePlugin\n\n先分析一下最基础的 simpleEventPlugin, 每个PluginModule都会有一个extractEvents对外的接口, 它主要的工作就是根据事件类型, 给Event对象添加一些数据特有的属性, 比如 MouseEvent就会加上 screenX, screenY, clientX, clientY 等等属性. 最终返回的是一个SyntheticEvent(合成事件对象)\n\n```\nvar SimpleEventPlugin: PluginModule<MouseEvent> = {\n  eventTypes: eventTypes,\n\n  extractEvents: function(\n    topLevelType: TopLevelTypes,\n    targetInst: Fiber,\n    nativeEvent: MouseEvent,\n    nativeEventTarget: EventTarget,\n  ): null | ReactSyntheticEvent {\n\n    // 根据事件的类型, 给 SyntheticEvent 这个对象添加一些属性\n    var EventConstructor;\n    switch (topLevelType) {\n      ...\n\n      case 'topScroll':\n        EventConstructor = SyntheticUIEvent;\n        break;\n      case 'topWheel':\n        EventConstructor = SyntheticWheelEvent;\n        break;\n      ...\n      default:\n        EventConstructor = SyntheticEvent;\n        break;\n    }\n    var event = EventConstructor.getPooled(\n      dispatchConfig,\n      targetInst,\n      nativeEvent,\n      nativeEventTarget,\n    );\n    // 事件的回调函数\n    accumulateTwoPhaseDispatches(event);\n    return event;\n  },\n};\n\n```\n\n上面的 accumulateTwoPhaseDispatches(event) 主要的工作:\n\n1. 获取当前虚拟dom实例绑定的事件回调函数\n2. 把事件回调函数push到 event._dispatchListeners 里面\n3. 把当前的Fiber(virtual-dom)实例push到 event._dispatchInstances 里面\n\n这三个步骤很关键. \n```\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  // 获取当前dom节点中某某事件回调函数, 比如 onClick={(event)=>{}}\n  var listener = listenerAtPhase(inst, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(\n      event._dispatchListeners,\n      listener,\n    );\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n\n```\n\n#### enqueueEvents和processingEventQueue\n上面事件已经调用各种plugin, 生成好了一个 events事件列表\n接下来进行:\n\n1. 把合成的events合并到 eventQueue事件队列中(eventQueue是一个公用的事件队列)\n2. 遍历 processingEventQueue中的每个事件, 调用 executeDispatchesAndReleaseTopLevel去执行\n\n```\nexport function enqueueEvents(events) {\n  if (events) {\n    // 把合成的事件数组合并到eventQueue\n    eventQueue = accumulateInto(eventQueue, events);\n  }\n}\n\nexport function processEventQueue() {\n  // 这里在处理队列之前, 把eventQueue 设置为null\n  // 这样子当处理事件的时候, eventQueue也能继续接受新的事件\n  var processingEventQueue = eventQueue;\n  eventQueue = null;\n\n// 遍历 processingEventQueue中的每个事件, 调用 executeDispatchesAndReleaseTopLevel去执行\n    forEachAccumulated(\n      processingEventQueue,\n      executeDispatchesAndReleaseTopLevel,\n    );\n}\n```\n\n\n#### 单个事件处理单元\n\nexecuteDispatchesAndReleaseTopLevel里面主要是调用 executeDispatchesAndRelease这个方法\n\n```\nvar executeDispatchesAndRelease = function(\n  event: ReactSyntheticEvent,\n  simulated: boolean,\n) {\n  if (event) {\n    // 按照顺序去依次执行回调函数, 遍历event._dispatchListeners并执行回调函数\n    executeDispatchesInOrder(event, simulated);\n    \n    // React为了节省event对象频繁创建与销毁带来的性能损耗, 特地搞了一个对象池的概念\n    // 当执行完回调函数之后, 就回收这个SyntheticEvent对象\n    // 对象池在我们平常有频繁的对象创建销毁的场景中, 可以好好学习一下\n    if (!event.isPersistent()) {\n      event.constructor.release(event);\n    }\n  }\n};\n```\n\n#### 遍历event._dispatchListeners\n下面的这个方法就是 遍历event._dispatchListeners并执行回调函数\n\n1. for循环遍历_dispatchListeners(回调函数列表)\n2. 如果isPropagationStopped为 true,就停止冒泡事件的执行\n3. 执行单个回调函数\n\n```\nexport function executeDispatchesInOrder(event, simulated) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchInstances = event._dispatchInstances;\n  \n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n\n      // 如果isPropagationStopped为 true\n      // 就不继续执行dispatchListeners里面其他回调函数了\n      // 这个地方是否就是react实现与原生事件一样的 事件停止冒泡传递, 待确定...\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // 去执行单个回调函数\n      executeDispatch(\n        event,\n        simulated,\n        dispatchListeners[i],\n        dispatchInstances[i],\n      );\n    }\n  // 处理一下 dispatchListeners 只有一个元素的情况, 目前看来大部分情况都是这种\n  } else if (dispatchListeners) {\n    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);\n  }\n  // 依旧要重新初始化一下_dispatchListeners, _dispatchInstances, 因为event是要被回收的\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n}\n```\n\n\n#### 执行单个回调函数\n\n```\nfunction executeDispatch(event, simulated, listener, inst) {\n  var type = event.type || 'unknown-event';\n  // currentTarget 是在这里加上的. 这里也直接打脸了最初我 '发现的React的BUG'\n  event.currentTarget = getNodeFromInstance(inst);\n  ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(\n    type,\n    listener,\n    undefined,\n    event,\n  );\n  event.currentTarget = null;\n}\n\nlet invokeGuardedCallback = function(name, func, context, a, b, c, d, e, f) {\n  ReactErrorUtils._hasCaughtError = false;\n  ReactErrorUtils._caughtError = null;\n  const funcArgs = Array.prototype.slice.call(arguments, 3);\n  try {\n    // 这里就真正的执行回调函数了\n    func.apply(context, funcArgs);\n  } catch (error) {\n    ReactErrorUtils._caughtError = error;\n    ReactErrorUtils._hasCaughtError = true;\n  }\n};\n```\n\n看到这里, 也就完整的过了一下React的事件触发到执行的过程了. \n\n## 总结:\n\n关于性能:   在看源码之前, 在网上看过各种分析React事件系统的文章, 很多人的关注点是在于事件系统的性能多么好, 确实, React通过事件代理与分发的机制, 配合Fiber架构, 在提高事件绑定效率的同时, 也能高效的完成事件的分发处理, 在代码中, 随处可见的是队列, 从事件分发开始, 就是各种push队列, 执行队列, 保证了事件系统的稳定高效运行 \n\n关于跨平台:  对于各种终端而言, 只要还没有脱离显示屏这个载体, 交互过程中的各种事件的模型其实都不会差太多. 从React的事件系统中, 一个感受就是React正在逐步的消除平台之间的差异, 各个平台都有自己事件系统, 而React作为应用层框架, 实现自己的事件系统, 通过EventPlugin的方式来丰富Event对象, 用户在React体系下开发, 不管什么平台浏览器绑定一个点击事件只需要onClick就好了, 如果说Jquery的事件消除了浏览器之间的差异, 那么React的事件系统就是消除了平台之间的差异. 层次高了那么一丢丢\n\n\n回过头再看React整个体系, 从React-dom, React, React-reconciler, Event, React-CS-Render, 串起来, 也恰恰印证了React官网首页的那句slogan: A JavaScript library for building user interfaces\n\n\n\n","tags":["react"],"categories":["React"]},{"title":"ReactUI组件设计理念与重构Tree组件实践","url":"%2F2018%2F01%2F18%2Ftech%2FReactUI%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%E4%B8%8E%E9%87%8D%E6%9E%84Tree%E7%BB%84%E4%BB%B6%E5%AE%9E%E8%B7%B5%2F","content":"\n\n## 背景\n\n\n在SPAUI提供的众多组件中, Tree树状选择器组件是比较复杂的UI组件之一, 由于前端架构的演进, 老的Tree组件在功能拓展性和兼容性越来越显得吃力. 重构Tree组件似乎越来越有必要了. \n在重构Tree组件的过程中, 缩小50%+代码量和提升40%性能的背后是对组件完全重新设计, 包括数据传入处理, 渲染, 事件处理等\n\n写这篇文章的初衷也是为了记录自己在重构Tree组件中的一些思考, 方便后续维护的同学理解它, 同时也希望里面提到的组件设计思想可以被认可并推广\n<!-- more -->\n## 组件的设计理念\n\n#### 1. 组件的能力拓展\n\n随着前端架构的不断演进, 底层的UI组件在项目中的角色也慢慢的发生了改变, 从当初大包大揽的提供尽可能多的功能慢慢转换为提供更好的功能组合能力, 在设计组件的时候, 也要节制, 并非功能越多越好. 太多的组件属性一方面会导致组件自身特殊逻辑很复杂, 不方便拓展; 另外一方面开发者要面对N多自己不关心的属性, 在使用的过程中也容易出现理解偏差;\n\n开发组件就好比建房子, 作为底层的基础组件, 先把房屋的框架搭建好, 至于墙用什么材质, 地板用啥瓷砖, 屋顶盖啥颜色的瓦, 使用者通过子组件的形式传入组合即可, 当然组件本身也要提供默认的子组件组件. \n\n#### 2. 组件的数据管理\n\n组件运行的环境也会影响组件最初的设计, 之前的架构中没有把所有的数据完全用redux管理起来, 组件会把数据在state里面存一份, 然后通过 componentWillReceiveProps 等方法获取数据书更新. 可能一个底层小组件的数据要在父节点里冗余好几份. 更新数据的过程除了性能损耗, 还容易出bug. 由于组件渲染之前会对props做浅对比, 为了防止经常出现数据改变但视图不变的情况,  我们不得不写很多的cloneDeep的逻辑, 深复制是非常耗费性能的. 同时也非常容易出现问题\n为了解决系统中的数据管理, 我们做了点小改变\n\n1. 从充血(Smart)组件到贫血(Dumb)组件的转变, 具体的差别是：Smart组件偏向于纯展示，减少组件内置的逻辑, 把更多的逻辑集中到 容器组件(smart组件)或者action和reducer里面\n\n2. 在前端的架构中, 把数据放到全局Store，并且做到数据的immutable, 带来的好处是在架构上更加清晰, 更好的数据流管理, 也减少了很多不必要的渲染, 进而带来了性能上的提升. \n\n#### 3. 往函数式靠拢一点点\n\n##### 1. 使用stateless component\n\nreact本身就是函数式编程的一个实践, render方法就是一个 pure function, 满足 \nview = render(data) 这个公式, 这里要引入stateless component这个概念, 对于很多小的组件我们不需要写成 XXXComponent extends PureComponent 这种形式, 我们只需要定义一个类似下面的方法\n\n```\nconst XXXComponent = (props) => return (<div>{props.data}</div>)\n```\n使用stateLessComponent的好处是没有那么多普通组件的生命周期, 优化系统的性能 \n\n##### 2. 把数据处理的逻辑抽离出来,独立成 pure function的逻辑\n\n组件在渲染之前避免不了会做一些数据处理的逻辑,如果我们使用函数式的编程思维来看待组件的渲染,一个渲染的逻辑可以用下面这样的一个表达式表示\n\n```\nrender(handleData(getData(param)))\n```\n\n可以看到在整个过程中并没有去设置变量, 每个函数的参数是另外一个函数的返回,整个过程中不会设置变量来暂存上一步的执行结果, 这就是面向过程抽象. 每一个函数都可以被看做独立单元，很有利于进行单元测试（unit testing）和调试（debugging），以及模块化组合.\n\n上面讲了三点的组件设计理念, 在新版的Tree组件中, 我们也在努力的把这些概念落地到实际的组件中\n\n## 在Tree组件的实践我们的设计理念\n\ntree组件接受的是一个树状的数据, 这里我们把组件分为: 数据处理,组件渲染,事件响应三块\n\n>注明: \n1. 组件内部不保存状态, 所有的数据与状态由父组件通过props传入\n2. 每次render都会遍历整个树, 时间复杂度为O(n), 因为树的结构比较特殊, 如果一个底层叶子节点选中, 可能会导致整条树枝的元素都是半选的状态\n\n#### 数据处理\n\n直接拿到父组件传入的树状数据直接渲染是不够的, 这里我们扩展一下数据节点的能力, 构建一个属性更多的树. \n```\n/**\n * 一个树的节点数据结构\n */\nexport const treeNodeStruct = {\n    // 作为数据节点的唯一标识, 如果原始数据有value, 则设为value的值\n    key: null,\n    // 节点的的value\n    value: null,\n    // 节点的展示文案\n    desc: null,\n    // 指向原始数据节点的指针\n    sourceData: null,\n    // 指向父节点的指针\n    parentNode: null,\n    // 孩子节点数组,里面是一个个treeNodeStruct的指针\n    childrenNodes: null,\n    // 节点的 check 状态: checked/unchecked/indeterminate\n    status: null,\n    // 节点是否展开子节点\n    isExpand: null,\n    // 节点在处在第几个branch, 最左branch为1, 往右递增\n    deepLevel: null,\n    // 是否展示loading状态\n    isLoading: null\n}\n```\n拿到父组件传入的树状数据之后,  以 treeNodeStruct为节点数据结构的模板,通过 genNodeTree方法, 构建出一个NodeTree的结构.\n\n>genNodeTree是一个递归遍历树的方法, 返回一个NodeTree的数据结构, 还有一些树的熟悉比如深度, valueTreeNodeMap等熟悉\n\n这是一个包含更多信息,可用于简化渲染流程的树状数据, 可以快速获取节点的父亲,兄弟节点, 节点选中状态等. 相当于我们把渲染之前数据处理逻辑全部收敛到 genNodeTree这个函数里面. \n\n#### 组件渲染\n\n拿到genNodeTree生成的 NodeTree之后, 就可以开始执行渲染的步骤了, 具体渲染的逻辑可以参考下面函数式的伪代码\n\n```\nlet renderOneBranch = compose(map, renderOneNode(TreeNodeComponent))\nlet TreeComponent = compose(map, renderOneBranch(TreeBranchComponent))\nrender(compose(TreeComponent, genNodeTree(props.list)))\n```\n\n简述一下组件数据处理和渲染流程:\n\n1. 遍历由父组件传入的整个的树状数据\n2. 生成NodeTree, NodeTree的节点以 treeNodeStruct 为结构模板\n3. 深度遍历仅需要展示的那条路径的节点\n\n#### 事件响应\n\ntree组件在设计的时候开放了两个事件回调接口, onChange 和 onClick\n\nonChange事件:\n\n1. 以勾选的节点TreeNode开始, 向上更新父节点链\n2. 以勾选的节点TreeNode开始, 向下递归更新子节点\n3. 生成新的 checkedIds, 通过传递到到父组件\n4. 由父组件传入value重新render\n\n\nonClick事件:\n\n1. 获取点击的节点的所在树的层级\n2. 生成新的 expandNodeIds, 通过onClick传递到到父组件\n3. 由父组件传入expandNodeIds重新render\n\n## 性能\n\n升级完成之后, 可能最大的担心是: 每次全部递归遍历整个树会不会导致性能下降?\n直接在浏览器里面做比较吧!\n\n测试中树节点数量为: 3480\n\n![重构之前一次点击节点的performance](1516278922_90_w2346_h1126.png)\n\n重构之前一次点击节点操作到视图更新, 大约需要45ms的时间\n\n![新版组件点击节点的performance](1516278898_10_w2536_h1172.png)\n重构之后一次点击到视图更新的操作时间25ms左右, 我们可以看到主要耗时是render这个方法, 因为其中包括对树状数据的遍历操作, 3480个节点大约10s, 这个时间复杂度是 O(n), 随着节点数量呈现线性增长的, 假定浏览器的刷新频率是60Hz, 那么一帧的时间是 16.6666666667ms, 那么树状组件节点只要在5000个以内, 都可以在下一帧被渲染到视图上.\n\n\n### 总结\n在重构树状组件的过程中, 最开始的目标是把代码结构优化一下方便维护和拓展, 后面吸取了同事们的建议采用新的思路摒弃了老的组件的很多字段, 采用新的设计思想, 特别是在代码层面引入新的函数式思维(最后代码看起来其实也不怎么函数式....), 在完成开发之后做了一下性能测试, 代码减少了50%, 性能提升了45%. 简化代码提升性能, 基本完成了重构Tree组件的初衷. 同时也实践了上述的组件设计思想和函数式的应用. \n\n更多组件相关信息可以参考\n","tags":["react"],"categories":["React"]},{"title":"Node异步解决方案-co与async","url":"%2F2018%2F01%2F07%2Ftech%2FNode%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-co%E4%B8%8Easync%3Aawait%2F","content":"\n\n### 问题背景\n有个做NodeJS后台的同学抛出了一段代码, 问为啥输出的结果不一样\n\n```\nco(fucntion* () {\n\tvar a = yield [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)]\n\tconsole.log(a)\n\t// [1, 2, 3]\n})\naysnc fucntion() {\n\tvar a = await [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)]\n\tconsole.log(a)\n\t//  [Promise.resolve(1), Promise.resolve(2). Promise.resolve(3)]\n}\n```\n<!-- more -->\n### 问题分析\n\n首先,  这两个方法想要做的都是同步的执行三个Promise.resolve()的方法,  输出  [1, 2, 3]的结果, 但是 async 的版本貌似有点不对劲\n\nawait后面的跟一个Promise对象,  返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身。\n\n 在上述例子中, 显示await后面跟的是一Array表达式, 会直接返回一个 [Promise.resolve(1), Promise.resolve(2),  Promise.resolve(3)]的数组\n而只co中, yield关键词后面可以跟 Promise, 数组, 对象, thunk函数, generator等对象\n\n这这个情景中, yield后面是一个数组, co内部会把数组转换为一个promise, 最后调用Promise.al()等所有的promise执行完成后的再resolve结果.\n这就解释清楚了为啥两个方法返回执行结果不一样\n\n当时一看这个代码, 下意识觉得这个问题很明显是没有理解清楚 async语法 和 co库之间的差异\n\n下面来系统的归纳一下generator, co, aysnc/await的知识, 当做复习回顾\n\n## 从问题中延伸出的知识点\n\n如果不了解 generator和Promise推荐阅读下面的文章来做知识准备\n\n1.  [Generator](http://es6.ruanyifeng.com/#docs/generator)\n2.  [Promise](http://es6.ruanyifeng.com/#docs/promise)\n\n写这篇文章之前也写过一篇文章提到过co这个库\n浅谈 Web 前端中间件两种模型与实现\n\nkoa的中间件模型就是基于co来实现的, 具体的可以阅读上面的文章了解\n\n### Generator:\n一个普通的Generator使用方式如下:\n#### yield\n需要我们手动触发next方法来执行generator, 其中next()方法返回的当前yield 后面表达式的返回值对象\n\n```\nvar gen = function* (){\n   var promise1 = yield 1\n   var promise2 = yield 2\n   console.log(promise1);\n   console.log(promise2);\n  return ‘end’\n};\nvar it = gen()\nit.next().value\n// 1\nit.next().value\n// 2\n it.next()\n// { value: ‘end’, done: true }\n```\n\n#### yield* \nyield* 后面可以跟一个 iterable object 作为参数，然后去执行这个迭代器，同时 yield* 本身这个表达式的值就是迭代器迭代完成时（done: true）的返回值。\n\n```\nvar iterableFunc = function* () {\n\tyield 'iterableFunc_1'\n\tyield 'iterableFunc_2'\n\treturn 'end iterableFunc'\n}\nvar gen = function* (){\n   var promise1 = yield 1\n   var iterableObject = yield* iterableFunc()\n   var promise2 = yield 2\n   console.log(promise1)\n   console.log(iterableObject)\n   console.log(promise2)\n};\nvar it = gen()\n> it.next()\n{ value: 1, done: false }\n> it.next()\n{ value: 'iterableFunc_1', done: false }\n> it.next()\n{ value: 'iterableFunc_2', done: false }\n> it.next()\n{ value: 2, done: false }\n```\n\n### co:\n\nco的 yield 关键字后面可以跟的类型有: 普通的promise对象,  数组, 对象, thunk函数, generator(iterable object), 比如下面的几个例子:\n\n```\nvar iterableFunc = function* () {\n\tyield 'iterableFunc_1'\n\tyield 'iterableFunc_2'\n\treturn 'end iterableFunc'\n}\nco(function* () {\n\tvar a = yield Promise.resolve(1)\n\tconsole.log(a) // 1\n\tvar b = yield Promise.resolve(2)\n\tconsole.log(b) // 2\n\tvar c = yield Promise.resolve(3)\n\tconsole.log(c) // 3\n\tvar d = yield [Promise.resolve(4), Promise.resolve(5),Promise.resolve(6)]\n\tconsole.log(d) // [4, 5, 6]\n\tvar e = yield iterableFunc()\n\tconsole.log(e) // end iterableFunc\n})\n```\n在co的源码中有一个 toPromise的方法来实现上面那些魔法封装\n对于 yield*的处理, 可以看到 是返回 co.call(this, obj), 而co本身返回的就是一个promise\n\n```\nfunction toPromise(obj) {\n  if (!obj) return obj;\n  if (isPromise(obj)) return obj;\n  if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);\n  if ('function' == typeof obj) return thunkToPromise.call(this, obj);\n  if (Array.isArray(obj)) return arrayToPromise.call(this, obj);\n  if (isObject(obj)) return objectToPromise.call(this, obj);\n  return obj;\n}\n```\n\n### async/await:\n\n一个标准的async wait的使用场景\n\n```\naysnc asyncTask1 () {\n\treturn await Promise.resolve(1)\n}\nasync aysncTask2() {\n\treturn await Promise.resolve(2)\n}\nasync aysncErrorTsak() {\n\tthrow new Error(‘this is a Error’)\n}\naysnc  aysncWork() {\n\ttry { // 最好要用try包裹一下代码,也可以写个装饰器统一管理异常捕捉\n\t\tawait asyncTask1()\n\t\tawait asyncTask2()\n\t\tawait aysncErrorTsak()\n\t}catch(e) {\n\t\tconsole.log(e)\n\t}\t\t\n}\n```\n\nasync 是generator的语法糖升级版本:\n\n1. 内置执行器, 普通的generator需要手动调用next()方法触发, co库就是帮我们自动执行的generator, 而async自动执行\n2. async await 更加符合编程语言的语义,  async 代表这个函数里面是异步操作的, await 表示 要等到后面的表达式执行完之后才会继续执行后续代码\n3. aysnc 函数返回的是一个Promise对象, 函数最后return的结果就是 resolve的结果, 函数中throw error, 会reject到上层\n4. 更好的异常处理, 在回调中无法捕获的异常, 在Promise中有最后的catch可以捕获异常,而在async函数中, 可以直接使用try catch捕获异常,可以说是非常优雅了 (macrotask的异常依旧无法直接捕捉, 需要手动在macrotask函数中捕获并通过reject抛出),  总之我们可以在业务场景中做统一的异常捕获,使用装饰器专门捕获异常, 把异常都交给errorHandler处理\n\n\n现在我们已经在我们的NodeJS项目中放心大胆的的使用async await了\n\n","tags":["nodejs"],"categories":["Nodejs"]},{"title":"React16-Fiber 源码阅读笔记","url":"%2F2017%2F12%2F02%2Ftech%2FReact16-Fiber%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F","content":"\n\n# 前言\n\n提起React,可能脑海里第一印象就是Virtual Dom, 性能好, 渲染快, 之前也看过很多现成的原理分析文章, 但是别人的东西始终是建立在别人的理解之上,\n既然现在平时的工作已经大规模使用React及其生态，那么React 源码分析一方面可以加深对React理解，另外一方面学习其内核原理，更好的在工作业务中寻找一个最佳实践。\n本次源码阅读的版本是 从2017年11.28的发布的 React 16.2版本\n<!-- more -->\n# React16 的新特性\n\n下面先了解一下React16的新特性\n\n[https://reactjs.org/blog/2017/09/08/dom-attributes-in-react-16.html#changes-in-detail](查看React16的changelog)\n\n## 支持在html元素中传入 自定义属性\n```\n<div tabIndex=\"-1\" />\n```\n\n## 允许在render函数中返回节点数组,字符串\n\n```\n//  React 16.0 允许在render函数中返回节点数组\nrender() {\n return [\n  \"Some text.\", // Strings must be wrapped in quotes.\n  <h2 key=\"heading-1\">A heading</h2>, // Don't forget the keys :)\n  \"More text.\",\n  <h2 key=\"heading-2\">Another heading</h2>,\n  \"Even more text.\"\n ];\n}\n// 支持字符串\nrender() {\n  return 'Look ma, no spans!';\n}\n```\n\n\n##  支持了 Fragment 标签\n\n2017年11月28日最新发布的 React v16.2.0, 主要的更新点如下\n\n```\n// 通常我们一个节点列表需要一个 div 或者spn 标签来包裹\nrender() {\n  return (\n    // Extraneous div element :(\n    <div>\n      Some text.\n      <h2>A heading</h2>\n      More text.\n      <h2>Another heading</h2>\n      Even more text.\n    </div>\n  );\n}\n\n// 使用 Fragment 特性\nrender() {\n  return (\n    <Fragment>\n      Some text.\n      <h2>A heading</h2>\n      More text.\n      <h2>Another heading</h2>\n      Even more text.\n    </Fragment>\n  );\n}\n\n// Fragment也能够被省略, 直接写个<>代替\nrender() {\n  return (\n    <>\n      Some text.\n      <h2>A heading</h2>\n      More text.\n      <h2>Another heading</h2>\n      Even more text.\n    </>\n  );\n}\n// 还支持 传入 key值,  后期可能会 支持更多的attributes传入, 类似 event 事件绑定\nrender() {\n  return (\n        <Fragment key={item.id}>\n          <dt>{item.term}</dt>\n          <dd>{item.description}</dd>\n        </Fragment>\n  );\n}\n```\n\n## Portals\n\n```\nrender() {\n  // 第一个参数是一个react的组件, 第二个参数是一个dom节点\n  return ReactDOM.createPortal(\n    this.props.children,\n    domNode,\n  );\n}\n```\n主要的作用就是把组件插入到现有的dom节点中,这个特性对于jq的页面迁移到 react简直是福音.\n比如当前有一个页面某个模块是jquery写的, 现在需要把其中某个模块迁移到react,\n使用这个特性就非常方便, 就不用特地使用 ReactDom.render()方法单独挂载组件到 dom节点上\n\n\n## 采用新的底层架构 [Fiber](#React-Reconciler)\n可以参考一下demo对比两个架构之间的差距:\n\n1.  老架构 stack  https://claudiopro.github.io/react-fiber-vs-stack-demo/stack.html\n2.  新架构 fiber  https://claudiopro.github.io/react-fiber-vs-stack-demo/fiber.html\n\n\n更多细节可以参考官方的博客 https://reactjs.org\n\n\n# 准备阶段\n\nReact的代码好几万行, 盲目的阅读有点大海捞针的感觉, 这里先思考几个问题, 我们总源码中找答案.\n\n1.  [Fiber](#React-Reconciler)引擎是什么, 它的原理是怎么样的\n2.  functionComponent的实现\n3.  新特性中的 render 中return array是怎么实现的\n4.  Fragment 实现\n5.  virtual dom在 react中具体是以一个什么样的方式存在\n\n现在要做的是:\n\n-  去github下载一份源码 [https://github.com/facebook/react/releases/tag/v16.2.0](react v16.2.0)\n-  下载一个好用的编辑器, 支持快速定位到当前function的引用\n\n注意:\n\n-  由于后续react升级, 本文所引用的部分代码可能会过期\n-  为了优化阅读体验, 会删除部分非核心代码:)\n\n# 导航\n\n[Fiber](#Fiber)架构的调用关系链, 方便我们快速浏览整个react-fiber引擎的执行流程\n帮助在阅读的过程中,可以快速定位到当前阅读模块在框架中的位置\n\n看到下面一大堆函数 还有一张那么大的图,感觉无从下手?\n那就直接进入主题:   [进入主题](#React-Reconciler)\n\n### 源码快速导航\n\n#### Component:\n\n[ReactDOM.render](#ReactDOM.render),\n[Component](#Component),\n[React.createElement](#React.createElement)\n\n[legacyRenderSubtreeIntoContainer](#legacyRenderSubtreeIntoContainer)\n\n\n[enqueueSetState](#Component),\n[enqueueReplaceState](#Component),\n[enqueueForceUpdate](#Component)\n\n\n\n[unbatchedUpdates](#unbatchedUpdates),\n[batchedUpdates](#batchedUpdates)\n\n[updateContainerAtExpirationTime](#updateContainerAtExpirationTime)\n\n[scheduleRootUpdate](#scheduleRootUpdate),\n[insertUpdateIntoFiber](#insertUpdateIntoFiber)\n\n#### performWork:\n[performWork](#performWork),\n[scheduleWorkImpl](#scheduleWorkImpl),\n[requestWork](#requestWork)\n\n[findHighestPriorityRoot](#findHighestPriorityRoot),\n[performWorkOnRoot](#performWorkOnRoot)\n\n[renderRoot](#renderRoot),\n[completeRoot](#completeRoot)\n\n[insertUpdateIntoFiber](#insertUpdateIntoFiber),\n[scheduleWorkImpl](#scheduleWorkImpl)\n\n#### Commit:\n[commitRoot](#commitRoot)\n\n[prepareForCommit](#prepareForCommit)\n\n[commitAllHostEffects](#commitAllHostEffects),\n[commitAllLifeCycles](#commitAllLifeCycles)\n\n[commitWork](#commitWork),\n[commitLifeCycles](#commitLifeCycles)\n\n\n#### LifeCycles:\n[componentDidMount](#commitLifeCycles),\n[componentDidUpdate](#commitLifeCycles),\n[shouldComponentUpdate](#updateClassInstance)\n[componentWillUpdate](#updateClassInstance)\n[componentWillReceiveProps](#updateClassInstance)\n\n\n#### workLoop:\n[workLoop](#workLoop),\n[performUnitOfWork](#performUnitOfWork),\n[beginWork](#beginWork)\n\n[updateHostRoot](#updateHostRoot),\n[updateClassComponent](#updateClassComponent)\n\n[reconcileChildren](#reconcileChildren),\n[reconcileChildFibers](#reconcileChildFibers),\n[reconcileChildrenArray](#reconcileChildrenArray)\n\n[updateClassInstance](#updateClassInstance),\n[constructClassInstance](#constructClassInstance),\n[updateFunctionalComponent](#updateFunctionalComponent)\n\n[completeWork](#completeWork),\n[finishClassComponent](#finishClassComponent)\n\n\n![Fiber架构图](https://yuml.me/a3c07b49.png)\n\n\n### DSL\n下面是架构图的DSL代码, 可以复制代码到 https://yuml.me/ 生成 UML 图片, 也可以直接打开该页面 https://yuml.me/a3c07b49 编辑\n\n```\n[ReactDOM.render{bg:wheat}] -Recursive Call> [render],\n\n[legacyRenderSubtreeIntoContainer] -> [unbatchedUpdates],\n\n[unbatchedUpdates] -> [updateContainer|updateContainerAtExpirationTime],\n\n[updateContainer|updateContainerAtExpirationTime]-> [scheduleRootUpdate],\n\n[scheduleRootUpdate] -> [insertUpdateIntoFiber],\n\n[batchedUpdates] -> [performWork] ,\n\n[scheduleWorkImpl]-> [requestWork],\n\n[performWork] -> [findHighestPriorityRoot],\n\n[requestWork] -> [performWorkOnRoot],\n[findHighestPriorityRoot] -> [performWorkOnRoot],\n\n[performWorkOnRoot] -1> [renderRoot],\n[performWorkOnRoot] -2> [completeRoot],\n\n[completeRoot{bg:wheat}] -> [commitRoot],\n\n\n[commitRoot] -> [prepareForCommit],\n[prepareForCommit] -1> [commitAllHostEffects],\n[prepareForCommit] -2> [commitAllLifeCycles],\n\n\n\n[commitAllHostEffects] -While> [commitWork],\n[commitWork] -> [HostConfig.commitUpdate],\n[commitAllLifeCycles] -Whild>[commitLifeCycles],\n\n[commitLifeCycles] -instance_null> [componentDidMount{bg:springgreen}],\n[commitLifeCycles] -instance\\!null> [componentDidUpdate{bg:springgreen}],\n\n\n[renderRoot{bg:turquoise}]-> [workLoop],\n[workLoop] -While> [performUnitOfWork],\n[performUnitOfWork] -> [beginWork],\n\n[performUnitOfWork] -> [completeWork{bg:thistle}],\n\n[completeWork{bg:thistle}] -> [prepareUpdate|updateHostComponent],\n\n[prepareUpdate|updateHostComponent]-> [markUpdate|appendAllChildren],\n\n[markUpdate|appendAllChildren] -> [HostConfig.appendInitialChild],\n\n[Component{bg:turquoise}]-> [render],\n[render] -> [React.createElement],\n\n[React.createElement] -> [legacyRenderSubtreeIntoContainer],\n\n[Component]-> [Component.prototype.setState],\n\n[Component.prototype.setState]  -> [enqueueSetState],\n[Component.prototype.setState]  -> [enqueueReplaceState],\n[Component.prototype.setState]  -> [enqueueForceUpdate],\n[enqueueSetState]-> [insertUpdateIntoFiber],\n[enqueueReplaceState]-> [insertUpdateIntoFiber],\n[enqueueForceUpdate]-> [insertUpdateIntoFiber],\n\n[insertUpdateIntoFiber]->[scheduleWorkImpl],\n\n[beginWork{bg:turquoise}] -type_HostRoot=> [updateHostRoot],\n[beginWork{bg:turquoise}] -type_ClassComponent=> [updateClassComponent],\n[beginWork{bg:turquoise}] -type_other...=> [FunctionalComponent|HostText|CallComponent|HostPortal|Fragment|More],\n[updateHostRoot] -> [reconcileChildren],\n[reconcileChildren]-> [reconcileChildFibers],\n[reconcileChildFibers] -> [reconcileChildrenArray{bg:yellowgreen}],\n\n[updateClassComponent] -> [constructClassInstance|mountClassInstance],\n[updateClassComponent] -> [updateClassInstance],\n\n[constructClassInstance|mountClassInstance] -> [finishClassComponent],\n[updateClassInstance] -1l> [componentWillReceiveProps{bg:springgreen}],\n[componentWillReceiveProps{bg:springgreen}] ->  [finishClassComponent],\n[updateClassInstance] -2> [shouldComponentUpdate{bg:springgreen}],\n[shouldComponentUpdate{bg:springgreen}] -> [componentWillUpdate{bg:springgreen}],\n\n[componentWillUpdate{bg:springgreen}] -> [finishClassComponent],\n\n```\n\n\n\n# 源码阅读\n\n## React\n首先来看一下react这个对象里面有啥\n```\n// packages/react/src/React.js\nimport {Component, PureComponent, AsyncComponent} from './ReactBaseClasses';\nimport {forEach, map, count, toArray, only} from './ReactChildren';\nimport ReactCurrentOwner from './ReactCurrentOwner';\nimport {\n  createElement,\n  createFactory,\n  cloneElement,\n  isValidElement,\n} from './ReactElement';\n\nvar React = {\n  Children: {\n    map,\n    forEach,\n    count,\n    toArray,\n    only,\n  },\n  Component,\n  PureComponent,\n  unstable_AsyncComponent: AsyncComponent,\n\n  Fragment: REACT_FRAGMENT_TYPE,\n\n  createElement: __DEV__ ? createElementWithValidation : createElement,\n  cloneElement: __DEV__ ? cloneElementWithValidation : cloneElement,\n  createFactory: __DEV__ ? createFactoryWithValidation : createFactory,\n  isValidElement: isValidElement,\n  },\n};\n\n```\n我们如果看babel编译过的react项目JSX代码,  通常我们一个下面是一个react的起点, 可以理解为 这个ReactDOM.render做的是吧react的对象和真实的浏览器dom节点关联\n, JSX经过babel编译后，实际是调用createElement()创建实例对象\n\n```\nReactDOM.render(React.createElement(<Component/>, null), document.getElementById('portraits_root'));\n```\n\n### React.createElement 对象创建\n我们先来分析一下 创建组件的入口 createElement\n\n```\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nexport function createElement(type, config, children) {\n  var propName;\n  // Reserved names are extracted\n  var props = {};\n\n  var key = null;\n  var ref = null;\n  var self = null;\n  var source = null;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      ref = config.ref;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        !RESERVED_PROPS.hasOwnProperty(propName)\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  var childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    var defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  return ReactElement(\n    type,\n    key,\n    ref,\n    self,\n    source,\n    ReactCurrentOwner.current,\n    props,\n  );\n}\n\nvar ReactElement = function(type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allow us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n\n    // Record the component responsible for creating this element.\n    _owner: owner,\n  };\n  return element;\n};\n```\n\n上面的源码主要做三个工作 , \n1. 把参数config 的挂到props变量里面\n2. 把 children传入到 props.children属性下\n3. 取出组件类中的静态变量defaultProps，并给未在JSX中设置值的属性设置默认值\n4. 返回一个 ReactElement\n5. 再看看 ReactElement的代码, 其实就是把把参数包装一下再加个 $$typeof标识返回\n6. 截止到这里, 可以看到createElement仅仅是返回一个 element对象\n\n\n### React.Children\nReact.Children提供了对this.props.children的操作的函数。\nreact/src/ReactChildren文件export的函数如下\n```\nexport {\n  forEachChildren as forEach,\n  mapChildren as map,\n  countChildren as count,\n  onlyChild as only,\n  toArray,\n};\n```\n\n###  Component\n\n```\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nComponent.prototype.isReactComponent = {};\n\n\nComponent.prototype.setState = function(partialState, callback) {\n  invariant(\n    typeof partialState === 'object' ||\n      typeof partialState === 'function' ||\n      partialState == null,\n    'setState(...): takes an object of state variables to update or a ' +\n      'function which returns an object of state variables.',\n  );\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n\n\nComponent.prototype.forceUpdate = function(callback) {\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n};\n\n\n\n/**\n * Base class helpers for the updating state of a component.\n */\nfunction PureComponent(props, context, updater) {\n  // Duplicated from Component.\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nfunction ComponentDummy() {}\nComponentDummy.prototype = Component.prototype;\nvar pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());\npureComponentPrototype.constructor = PureComponent;\n// Avoid an extra prototype jump for these methods.\nObject.assign(pureComponentPrototype, Component.prototype);\npureComponentPrototype.isPureReactComponent = true;\n\nfunction AsyncComponent(props, context, updater) {\n  // Duplicated from Component.\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nvar asyncComponentPrototype = (AsyncComponent.prototype = new ComponentDummy());\nasyncComponentPrototype.constructor = AsyncComponent;\n// Avoid an extra prototype jump for these methods.\nObject.assign(asyncComponentPrototype, Component.prototype);\nasyncComponentPrototype.unstable_isAsyncReactComponent = true;\nasyncComponentPrototype.render = function() {\n  return this.props.children;\n};\n\nexport {Component, PureComponent, AsyncComponent};\n\n```\n\n上面的代码是输出三个类Component, PureComponent, AsyncComponent\n\n1. setState 实际上就是调用\nthis.updater.enqueueSetState(this, partialState, callback, 'setState');\n2. forceUpdate实际上是调用 \nthis.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n这一块后面分析Fiber架构会详细深入了解 this.updater.enqueueSetState 和 this.updater.enqueueForceUpdate\n3. PureComponent 和 asyncComponentPrototype 其实就是在Component的基础上分别设置\nisPureReactComponent 和 unstable_isAsyncReactComponent  为true的熟悉, 这个标准在底层的架构中会判断这写标记做特殊判断, 比如 isPureReactComponent= true之后，组件在shoudComponentUpdate中会浅比较渲染前后的props和state，如果没有变化，组件不会进入接下来的生命周期，可以节省不必要的diff操作。\n\n到此我们已经把React的对象分析的差不多了, 但是是不是有还是觉得不知道React是如何运行的? 下面进入React16新一代的架构Fiber 来进行探索\n\n## Fiber\n分析前面的 React代码, 发现主要就是构造element对象, 那现在如何让整个react 引擎跑起来?\n还记得前面的 ReactDOM.render(React.createElement(<Component/>, null), document.getElementById('portraits_root'));\n\n#### ReactDOM.render\n\n```\n// react/packages/react-dom/src/client/ReactDOM.js\n// 先找到 render方法, 发现其实是调用 legacyRenderSubtreeIntoContainer\nrender(\n    element: React$Element<any>,\n    container: DOMContainer,\n    callback: ?Function,\n  ) {\n    return legacyRenderSubtreeIntoContainer(\n      null,\n      element,\n      container,\n      false,\n      callback,\n    );\n  },\n\n//  这个方法的工作就是 是把子组件树挂在到 dom 容器中\nfunction legacyRenderSubtreeIntoContainer(\n  parentComponent: ?React$Component<any, any>,\n  children: ReactNodeList,\n  container: DOMContainer,\n  forceHydrate: boolean,\n  callback: ?Function,\n) {\n  // 如果没有root容器就创建一个\n  if (!root) {\n    // Initial mount\n    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(\n      container,\n      forceHydrate,\n    );\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n      callback = function() {\n        const instance = DOMRenderer.getPublicRootInstance(root._internalRoot);\n        originalCallback.call(instance);\n      };\n    }\n    // Initial mount should not be batched.\n    // 初始化挂载组件 不需要 bathced 的去update\n    DOMRenderer.unbatchedUpdates(() => {\n      // 如果有父组件, 就去挂载这个父组件, 如果没有父组件, 就直接调用DOMRenderer的render方法 渲染组件\n      if (parentComponent != null) {\n        root.legacy_renderSubtreeIntoContainer(\n          parentComponent,\n          children,\n          callback,\n        );\n      } else {\n        root.render(children, callback);\n      }\n    });\n  } else {\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n      callback = function() {\n        const instance = DOMRenderer.getPublicRootInstance(root._internalRoot);\n        originalCallback.call(instance);\n      };\n    }\n    // Update\n    if (parentComponent != null) {\n      root.legacy_renderSubtreeIntoContainer(\n        parentComponent,\n        children,\n        callback,\n      );\n    } else {\n      root.render(children, callback);\n    }\n  }\n  return DOMRenderer.getPublicRootInstance(root._internalRoot);\n}\n\n\n\n\n```\n上面的render中 ,多次使用到 DOMRenderer 这个对象 ,\n下面的我精简了很多function的细节, 只保留了名称, 从这些名称中可以看出来, 下面这些是 浏览器dom操作与react 核心的引擎的桥梁\n同样的,DOM、Canvas、Native、VR、WebGL等等平台都有自己的renderer, 也就是说 fiber引擎可以对接不同平台的渲染接口\n\n#### DOMRenderer\n```\nconst DOMRenderer = ReactFiberReconciler({\n  getRootHostContext\n  getChildHostContext\n  getPublicInstance\n  prepareForCommit\n  resetAfterCommit\n  createInstance\n  appendInitialChild\n  finalizeInitialChildren\n  prepareUpdate\n  shouldSetTextContent\n  shouldDeprioritizeSubtree\n  createTextInstance\n  now: ReactDOMFrameScheduling.now,\n  mutation\n    commitUpdate\n    commitTextUpdate\n    appendChild\n    appendChildToContainer\n    insertBefore\n    insertInContainerBefore\n    removeChild\n    hydration\n    canHydrateTextInstance\n    getNextHydratableSibling\n    getFirstHydratableChild\n    hydrateInstance\n    hydrateTextInstance\n    didNotMatchHydratedContainerTextInstance\n    didNotMatchHydratedTextInstance\n    didNotHydrateContainerInstance\n    didNotHydrateInstance\n    didNotFindHydratableContainerInstance\n    didNotFindHydratableContainerTextInstance\n    didNotFindHydratableInstance\n    didNotFindHydratableTextInstance\n  scheduleDeferredCallback: ReactDOMFrameScheduling.rIC,\n  cancelDeferredCallback: ReactDOMFrameScheduling.cIC,\n  useSyncScheduling: !enableAsyncSchedulingByDefaultInReactDOM,\n});\n\n```\n从上面看到其实DOMRenderer 对象是由ReactFiberReconciler返回的, 下面就真的进入到fiber的代码了\n\n### React-Reconciler\n生看代码很苦涩, 还得结合理论描述来看\n\n#### 基础的概念:\n1.  [React Components, Elements, and Instances](https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html)\n2.  [协调算法（Diff算法）](https://reactjs.org/docs/reconciliation.html)\n3.  [React基本理论概念](https://github.com/reactjs/react-basic)\n4.  [React设计原则](https://facebook.github.io/react/contributing/design-principles.html)\n\n#### 协调算法(reconciliation)\n\n协调: React用以比较两棵树的算法，其决定哪些部分需要更改。\n更新(update): 即渲染React app的数据发生的一个改变。通常是setState的结果。最终会导致重新渲染。\n\n\n#### 调度(scheduling)\n\n调度(scheduling): 决定事务什么时候执行的过程。\n事务(work): 必须执行的计算。事务一般是由update引起的（比如setState）。\n\nFiber的主要目标是使React能够充分利用调度, 具体的需要实现:\n\n- 暂停事务，在一段时间后再接着执行。\n- 分配不同类型事务的优先级。\n- 复用之前已完成的事务。\n- 当事务不再需要时，终止该事务。\n\nFiber为了实现这些功能, 需要保存堆栈结构在内存里，然后在适当的时机去执行它。这点对于实现我们要的调度功能非常重要。\n重要特性是增量渲染：将渲染事务分块并分布到多个帧去完成的能力,\n关键特性包括有新的更新时,暂停、终止或重用事务的功能,为不同类型的更新设置优先级的功能.\n\n以上几点概念理论引用自: [React Fiber架构](https://swenyang.gitbooks.io/translation/content/react/fiber.html)\n\n下面可以详细看看 Fiber 引擎的代码,主要是指 React-Reconciler下面的代码, Reconciler(协调器) 就是所谓的 Virtul DOM\n\nReact组件更新渲染分为两个阶段:\n1. reconciliation 和 commit, Reconciler主要用于生成需要更新dom操作的列表,这个过程是 一个纯函数的过程, effectList = f(newProps, newState), 这个过程不会受到状态的变化而影响.\n2. 生成 effect list之后,  commit effect list才会把变化应用到dom中, 这里需要调用render提供的dom操作接口方法, React-Dom React-Native 等都有提供接口给我Fiber\n\n\n#### ReactFiberReconciler\n\n```\n// react/packages/react-reconciler/src/ReactFiberReconciler.js\n// ReactFiberReconciler对象\n\nexport default function<T, P, I, TI, HI, PI, C, CC, CX, PL>(\n  config: HostConfig<T, P, I, TI, HI, PI, C, CC, CX, PL>,\n): Reconciler<C, I, TI> {\n  var {getPublicInstance} = config;\n\n  var {\n    computeAsyncExpiration,\n    computeUniqueAsyncExpiration,\n    computeExpirationForFiber,\n    scheduleWork,\n    requestWork,\n    flushRoot,\n    batchedUpdates,\n    unbatchedUpdates,\n    flushSync,\n    deferredUpdates,\n  } = ReactFiberScheduler(config);\n\n  return {\n    createContainer\n\n    updateContainer\n\n    updateContainerAtExpirationTime,\n\n    flushRoot,\n\n    requestWork,\n\n    computeUniqueAsyncExpiration,\n\n    batchedUpdates,\n\n    unbatchedUpdates,\n\n    deferredUpdates,\n\n    flushSync,\n\n    getPublicRootInstance\n\n  };\n}\n\n```\nReactFiberReconciler 对外抛出的方法,\n可以看到主要的几个方法都是ReactFiberScheduler返回的, 进一步证明了fiber架构在任务的调度上做了很大的改变\n这些api主要是给 React-dom等 rendener的使用的\n\n#### updateContainerAtExpirationTime\n这个方法主要就是调用 scheduleRootUpdate\n\n```\n  function updateContainerAtExpirationTime(\n    element: ReactNodeList,\n    container: OpaqueRoot,\n    parentComponent: ?React$Component<any, any>,\n    expirationTime: ExpirationTime,\n    callback: ?Function,\n  ) {\n    // TODO: If this is a nested container, this won't be the root.\n    const current = container.current;\n\n    const context = getContextForSubtree(parentComponent);\n    if (container.context === null) {\n      container.context = context;\n    } else {\n      container.pendingContext = context;\n    }\n\n    return scheduleRootUpdate(current, element, expirationTime, callback);\n  }\n\n```\n\n#### scheduleRootUpdate\n\n```\nfunction scheduleRootUpdate(\n    current: Fiber,\n    element: ReactNodeList,\n    expirationTime: ExpirationTime,\n    callback: ?Function,\n  ) {\n\n\n    callback = callback === undefined ? null : callback;\n\n    const update = {\n      expirationTime,\n      partialState: {element},\n      callback,\n      isReplace: false,\n      isForced: false,\n      next: null,\n    };\n    insertUpdateIntoFiber(current, update);\n    scheduleWork(current, expirationTime);\n\n    return expirationTime;\n  }\n\n```\n这个方法有顾名思义是开始调度根节点的update操作\n主要分为三个操作:\n\n1.  生成一个update对象\n2.  把这个update 插入到 Fiber中\n3.  开始调度工作\n\n看到这里开始接触到 Fiber对象了, 下面来了解一下 Fiber对象到底为何物\n\n\n#### typeFiber\n\n下面可以看看一个fiber的对象是怎么样了\n```\nfunction FiberNode(\n  tag: TypeOfWork,\n  pendingProps: mixed,\n  key: null | string,\n  internalContextTag: TypeOfInternalContext,\n) {\n  // Instance\n  this.tag = tag; // fiber的类型\n  this.key = key; // key是在协调算法中用来决定fiber是否可以重用的字段\n  this.type = null; // type描述了它对应的组件。对于复合组件，type就是复合函数或组件的class。对于宿主组件（div, span等），type是一个字符串。\n  this.stateNode = null;\n\n  // Fiber\n  this.return = null; // 指向fiber树中的父Fiber\n  this.child = null; // 子fiber(child fiber)指的是组件的render方法返回来的值。\n  this.sibling = null; // 兄弟fiber(sibling fiber)指代的是render方法返回多个子节点的情况（Fiber中的新特性！）, 兄弟fiber形成一个单链表\n  this.index = 0;\n\n  this.ref = null;\n\n  //  一个fiber的pendingProps会在它开始执行处设置，memoizedProps则会在执行结尾处设置。\n  //  当到来的pendingProps和上一个memoizedProps相等时，它意味着fiber的上一次输出可以重用，避免不必要的事务。\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;  // 待更新update队列\n  this.memoizedState = null;\n\n  this.internalContextTag = internalContextTag;\n\n  // Effects\n  this.effectTag = NoEffect;  // side effect类型\n  this.nextEffect = null; // 单链表结构，方便遍历fiber树上有副作用的节点\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  this.expirationTime = NoWork;\n\n  this.alternate = null;  // 在fiber更新时克隆出的镜像fiber，对fiber的修改会标记在这个fiber上, 这个就是 源码中经常出现的working-in-progres\n}\n\n```\n\n#### insertUpdateIntoFiber\n\n```\nexport function insertUpdateIntoFiber<State>(\n  fiber: Fiber,\n  update: Update<State>,\n): void {\n  // We'll have at least one and at most two distinct update queues.\n  const alternateFiber = fiber.alternate;\n  let queue1 = fiber.updateQueue;\n  if (queue1 === null) {\n\n    queue1 = fiber.updateQueue = createUpdateQueue((null: any));\n  }\n\n  let queue2;\n  if (alternateFiber !== null) {\n    queue2 = alternateFiber.updateQueue;\n    if (queue2 === null) {\n      queue2 = alternateFiber.updateQueue = createUpdateQueue((null: any));\n    }\n  } else {\n    queue2 = null;\n  }\n  queue2 = queue2 !== queue1 ? queue2 : null;\n\n\n  // If there's only one queue, add the update to that queue and exit.\n  if (queue2 === null) {\n    insertUpdateIntoQueue(queue1, update);\n    return;\n  }\n\n  // If either queue is empty, we need to add to both queues.\n  if (queue1.last === null || queue2.last === null) {\n    insertUpdateIntoQueue(queue1, update);\n    insertUpdateIntoQueue(queue2, update);\n    return;\n  }\n\n  // If both lists are not empty, the last update is the same for both lists\n  // because of structural sharing. So, we should only append to one of\n  // the lists.\n  insertUpdateIntoQueue(queue1, update);\n  // But we still need to update the `last` pointer of queue2.\n  queue2.last = update;\n}\n\n```\nfiber.updateQueue是一个单向链表，有first和last指针指向链表的头部和尾部。\n\n一个React element会有一个current fiber和一个alternate fiber。alternate fiber又叫working in progress fiber。\n这两个fiber都有一个Update Queue。\n这两个Queue里面的item的引用是相同的. 区别在于，working in progress fiber会在更新完一个队列项之后将其从队列中移除。\n所以working in progress update queue永远是current queue的一个子集。\n在更新完成之后，working in progress fiber取代current fiber成为新的current fiber。如果更新中断（有更高优先级的更新插入），\ncurrent fiber的update queue就可以作为备份，使得之前中断的更新可以重新开始。\n\n总之, insertUpdateIntoFiber，这个函数处理了将一个update插入到fiber.updateQueue和fiber.alternateFiber.updateQueue两个队列中操作\n\n\n#### scheduleWorkImpl\n\n```\n  function scheduleWorkImpl(\n    fiber: Fiber,\n    expirationTime: ExpirationTime,\n    isErrorRecovery: boolean,\n  ) {\n    recordScheduleUpdate();\n\n    let node = fiber;\n    while (node !== null) {\n      // Walk the parent path to the root and update each node's\n      // expiration time.\n      // 遍历父节点,一直到root节点, 更新每个节点的 expiration time 截止时间(优先级)\n      if (\n        node.expirationTime === NoWork ||\n        node.expirationTime > expirationTime\n      ) {\n        node.expirationTime = expirationTime;\n      }\n      if (node.alternate !== null) {\n        if (\n          node.alternate.expirationTime === NoWork ||\n          node.alternate.expirationTime > expirationTime\n        ) {\n          node.alternate.expirationTime = expirationTime;\n        }\n      }\n      if (node.return === null) {\n        if (node.tag === HostRoot) {\n          const root: FiberRoot = (node.stateNode: any);\n\n          checkRootNeedsClearing(root, fiber, expirationTime);\n\n          // 当root收到update时, 调用requestWork, 请求更新\n          requestWork(root, expirationTime);\n\n          checkRootNeedsClearing(root, fiber, expirationTime);\n        } else {\n          return;\n        }\n      }\n      node = node.return;\n    }\n  }\n\n```\n\n\n#### requestWork\n```\n  function requestWork(root: FiberRoot, expirationTime: ExpirationTime) {\n\n    // Add the root to the schedule.\n    // Check if this root is already part of the schedule.\n    if (root.nextScheduledRoot === null) {\n      // This root is not already scheduled. Add it.\n      root.remainingExpirationTime = expirationTime;\n      if (lastScheduledRoot === null) {\n        firstScheduledRoot = lastScheduledRoot = root;\n        root.nextScheduledRoot = root;\n      } else {\n        lastScheduledRoot.nextScheduledRoot = root;\n        lastScheduledRoot = root;\n        lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n      }\n    } else {\n      // This root is already scheduled, but its priority may have increased.\n      const remainingExpirationTime = root.remainingExpirationTime;\n      if (\n        remainingExpirationTime === NoWork ||\n        expirationTime < remainingExpirationTime\n      ) {\n        // Update the priority.\n        root.remainingExpirationTime = expirationTime;\n      }\n    }\n\n    if (isRendering) {\n      // Prevent reentrancy. Remaining work will be scheduled at the end of\n      // the currently rendering batch.\n      return;\n    }\n\n    if (isBatchingUpdates) {\n      // Flush work at the end of the batch.\n      if (isUnbatchingUpdates) {\n        // ...unless we're inside unbatchedUpdates, in which case we should\n        // flush it now.\n        nextFlushedRoot = root;\n        nextFlushedExpirationTime = Sync;\n        performWorkOnRoot(root, Sync, recalculateCurrentTime());\n      }\n      return;\n    }\n\n    if (expirationTime === Sync) {\n      performWork(Sync, null);\n    } else {\n      scheduleCallbackWithExpiration(expirationTime);\n    }\n  }\n\n```\nrequestWork主要做3件事:\n\n1.  把 root 节点添加到已调度的队列中去\n2.  如果已经在调度的队列中, 则设置 expirationTime (这里的截止时间就是任务执行的优先级)\n3.  调用performWorkOnRoot 或者 performWork来执行更新队列\n\n#### performWorkOnRoot\n```\nfunction performWorkOnRoot(\n  root: FiberRoot,\n  expirationTime: ExpirationTime,\n  currentTime: ExpirationTime,\n) {\n\n  //  设置 isRendering 状态\n  isRendering = true;\n\n  // Check if this is async work or sync/expired work.\n  // 检测 当前是同步的还是异步的任务\n  if (expirationTime <= currentTime) {\n    // Flush sync work.\n    //执行同步的任务\n    let finishedWork = root.finishedWork;\n    if (finishedWork !== null) {\n      // This root is already complete. We can commit it.\n      completeRoot(root, finishedWork, expirationTime);\n    } else {\n      root.finishedWork = null;\n\n\n      finishedWork = renderRoot(root, expirationTime);\n      if (finishedWork !== null) {\n        // We've completed the root. Commit it.\n        completeRoot(root, finishedWork, expirationTime);\n      }\n    }\n  } else {\n    // Flush async work.\n    // 执行异步的任务\n    let finishedWork = root.finishedWork;\n    if (finishedWork !== null) {\n      // This root is already complete. We can commit it.\n      completeRoot(root, finishedWork, expirationTime);\n    } else {\n      root.finishedWork = null;\n\n      // 渲染 root节点\n      finishedWork = renderRoot(root, expirationTime);\n      if (finishedWork !== null) {\n        // We've completed the root. Check the deadline one more time\n        // before committing.\n        // 结束渲染之后,生成effect list, 检测一下 当前周期是否还有多余的时间, 如果有多余时间, 先不执行 commiting\n        if (!shouldYield()) {\n          // Still time left. Commit the root.\n          completeRoot(root, finishedWork, expirationTime);\n        } else {\n          // There's no time left. Mark this root as complete. We'll come\n          // back and commit it later.\n          root.finishedWork = finishedWork;\n        }\n      }\n    }\n  }\n\n  isRendering = false;\n}\n\n```\nperformWorkOnRoot 主要区分 同步渲染和异步渲染, 调用 renderRoot , completeRoot来执行任务\n异步渲染会先判断一下 shouldYield()为false才 执行completeRoot, 也就是说异步渲染会先计算effect list, 但是不 commit effect,\n然后根据当前周期剩余的时间来决定是否执行commiting操作\n\n#### renderRoot\n\n```\nfunction renderRoot(\n    root: FiberRoot,\n    expirationTime: ExpirationTime,\n  ): Fiber | null {\n    isWorking = true;\n\n    // We're about to mutate the work-in-progress tree. If the root was pending\n    // commit, it no longer is: we'll need to complete it again.\n    root.isReadyForCommit = false;\n\n    // Check if we're starting from a fresh stack, or if we're resuming from\n    // previously yielded work.\n    if (\n      root !== nextRoot ||\n      expirationTime !== nextRenderExpirationTime ||\n      nextUnitOfWork === null\n    ) {\n      // Reset the stack and start working from the root.\n      resetContextStack();\n      nextRoot = root;\n      nextRenderExpirationTime = expirationTime;\n      nextUnitOfWork = createWorkInProgress(\n        nextRoot.current,\n        null,\n        expirationTime,\n      );\n    }\n\n      try {\n        workLoop(expirationTime);\n      } catch (e) {\n        didError = true;\n        error = e;\n      }\n```\n\n执行的步骤:\n1.  检测是否有上一次未完成的任务, 如果有, 就回复上个堆栈继续执行\n2.  执行 workLoop\n\n#### workLoop\n\n```\n  function workLoop(expirationTime: ExpirationTime) {\n    if (\n      nextRenderExpirationTime === NoWork ||\n      nextRenderExpirationTime > expirationTime\n    ) {\n      return;\n    }\n\n    if (nextRenderExpirationTime <= mostRecentCurrentTime) {\n      // Flush all expired work.\n      // 执行所有过期的工作\n      while (nextUnitOfWork !== null) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n      }\n    } else {\n      // Flush asynchronous work until the deadline runs out of time.\n      // 当前帧还有剩余的时间, 执行异步操作直到截止的时间\n      while (nextUnitOfWork !== null && !shouldYield()) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n      }\n    }\n  }\n\n```\n\n#### performUnitOfWork\n\n```\n  function performUnitOfWork(workInProgress: Fiber): Fiber | null {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    const current = workInProgress.alternate;\n\n    let next = beginWork(current, workInProgress, nextRenderExpirationTime);\n\n    if (next === null) {\n      // If this doesn't spawn new work, complete the current work.\n      next = completeUnitOfWork(workInProgress);\n    }\n\n    ReactCurrentOwner.current = null;\n\n    return next;\n  }\n\n```\n1.  beginWork, 异步情况会返回一个workLoop里面whild循环中的 nextUnitOfWork,\n2.  如果返回null, 就 completeUnitOfWork ()\n\n一般情况一个react中的事务分为 begin 和 complete 两步, 下面先看 beginWork 的部分\n\n#### beginWork\n\n\n```\n    function beginWork(\n    current: Fiber | null,\n    workInProgress: Fiber,\n    renderExpirationTime: ExpirationTime,\n  ): Fiber | null {\n    if (\n      workInProgress.expirationTime === NoWork ||\n      workInProgress.expirationTime > renderExpirationTime\n    ) {\n      return bailoutOnLowPriority(current, workInProgress);\n    }\n\n    switch (workInProgress.tag) {\n      case IndeterminateComponent:\n        return mountIndeterminateComponent(\n          current,\n          workInProgress,\n          renderExpirationTime,\n        );\n      case FunctionalComponent:\n        return updateFunctionalComponent(current, workInProgress);\n      case ClassComponent:\n        return updateClassComponent(\n          current,\n          workInProgress,\n          renderExpirationTime,\n        );\n      case HostRoot:\n        return updateHostRoot(current, workInProgress, renderExpirationTime);\n      case HostComponent:\n        return updateHostComponent(\n          current,\n          workInProgress,\n          renderExpirationTime,\n        );\n      case HostText:\n        return updateHostText(current, workInProgress);\n      case CallHandlerPhase:\n        // This is a restart. Reset the tag to the initial phase.\n        workInProgress.tag = CallComponent;\n      // Intentionally fall through since this is now the same.\n      case CallComponent:\n        return updateCallComponent(\n          current,\n          workInProgress,\n          renderExpirationTime,\n        );\n      case ReturnComponent:\n        // A return component is just a placeholder, we can just run through the\n        // next one immediately.\n        return null;\n      case HostPortal:\n        return updatePortalComponent(\n          current,\n          workInProgress,\n          renderExpirationTime,\n        );\n      case Fragment:\n        return updateFragment(current, workInProgress);\n      default:\n        invariant(\n          false,\n          'Unknown unit of work tag. This error is likely caused by a bug in ' +\n            'React. Please file an issue.',\n        );\n    }\n  }\n\n```\nbeginWork函数是一个入口, 根据fiber节点不同的tag，调用对应的update方法。\n比如下面可以里先看看 updateClassComponent 这个方法\n\n#### updateClassComponent\n\n```\n  function updateClassComponent(\n    current: Fiber | null,\n    workInProgress: Fiber,\n    renderExpirationTime: ExpirationTime,\n  ) {\n    // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n    const hasContext = pushContextProvider(workInProgress);\n\n    let shouldUpdate;\n    // 如果当前Class实例为null,就构造一个class实例, 否则就更新 class 实例\n    if (current === null) {\n      if (!workInProgress.stateNode) {\n        // In the initial pass we might need to construct the instance.\n        constructClassInstance(workInProgress, workInProgress.pendingProps);\n        mountClassInstance(workInProgress, renderExpirationTime);\n        shouldUpdate = true;\n      } else {\n        invariant(false, 'Resuming work not yet implemented.');\n        // In a resume, we'll already have an instance we can reuse.\n        // shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);\n      }\n    } else {\n      shouldUpdate = updateClassInstance(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    }\n    return finishClassComponent(\n      current,\n      workInProgress,\n      shouldUpdate,\n      hasContext,\n    );\n  }\n\n\n```\nupdateClassComponent 主要判断是否初始化了ClassComponent, 如果没有就constructClassInstance一个实例, mountClassInstance然后挂载实例\n如果有实例,  有就执行updateClassInstance, 主要返回 shouldUpdate\n最后返回 finishClassComponent() 的结果\n\n#### updateClassInstance\n\n```\n  function updateClassInstance(\n    current: Fiber,\n    workInProgress: Fiber,\n    renderExpirationTime: ExpirationTime,\n  ): boolean {\n    const instance = workInProgress.stateNode;\n    resetInputPointers(workInProgress, instance);\n\n    const oldProps = workInProgress.memoizedProps;\n    const newProps = workInProgress.pendingProps;\n    const oldContext = instance.context;\n    const newUnmaskedContext = getUnmaskedContext(workInProgress);\n    const newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n    // Note: During these life-cycles, instance.props/instance.state are what\n    // ever the previously attempted to render - not the \"current\". However,\n    // during componentDidUpdate we pass the \"current\" props.\n\n    if (\n      typeof instance.componentWillReceiveProps === 'function' &&\n      (oldProps !== newProps || oldContext !== newContext)\n    ) {\n      callComponentWillReceiveProps(\n        workInProgress,\n        instance,\n        newProps,\n        newContext,\n      );\n    }\n\n    // Compute the next state using the memoized state and the update queue.\n    const oldState = workInProgress.memoizedState;\n    // TODO: Previous state can be null.\n    let newState;\n    if (workInProgress.updateQueue !== null) {\n      newState = processUpdateQueue(\n        current,\n        workInProgress,\n        workInProgress.updateQueue,\n        instance,\n        newProps,\n        renderExpirationTime,\n      );\n    } else {\n      newState = oldState;\n    }\n\n    if (\n      oldProps === newProps &&\n      oldState === newState &&\n      !hasContextChanged() &&\n      !(\n        workInProgress.updateQueue !== null &&\n        workInProgress.updateQueue.hasForceUpdate\n      )\n    ) {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidUpdate === 'function') {\n        if (\n          oldProps !== current.memoizedProps ||\n          oldState !== current.memoizedState\n        ) {\n          workInProgress.effectTag |= Update;\n        }\n      }\n      return false;\n    }\n\n    const shouldUpdate = checkShouldComponentUpdate(\n      workInProgress,\n      oldProps,\n      newProps,\n      oldState,\n      newState,\n      newContext,\n    );\n\n    if (shouldUpdate) {\n      if (typeof instance.componentWillUpdate === 'function') {\n        startPhaseTimer(workInProgress, 'componentWillUpdate');\n        instance.componentWillUpdate(newProps, newState, newContext);\n        stopPhaseTimer();\n\n      }\n      if (typeof instance.componentDidUpdate === 'function') {\n        workInProgress.effectTag |= Update;\n      }\n    } else {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidUpdate === 'function') {\n        if (\n          oldProps !== current.memoizedProps ||\n          oldState !== current.memoizedState\n        ) {\n          workInProgress.effectTag |= Update;\n        }\n      }\n\n      // If shouldComponentUpdate returned false, we should still update the\n      // memoized props/state to indicate that this work can be reused.\n      memoizeProps(workInProgress, newProps);\n      memoizeState(workInProgress, newState);\n    }\n\n    // Update the existing instance's state, props, and context pointers even\n    // if shouldComponentUpdate returns false.\n    instance.props = newProps;\n    instance.state = newState;\n    instance.context = newContext;\n\n    return shouldUpdate;\n  }\n\n```\n这个updateClassInstance主要的工作:\n\n1.  当前 instance 的 props, state, context备份为老的版本, 比如 oldProps = workInProgress.memoizedProps; newProps = workInProgress.pendingProps;\n2.  调用 callComponentWillReceiveProps\n3.  遍历workInProgress.updateQueue, 执行update, 生成newState\n4.  checkShouldComponentUpdate, 这个地方会调用 ShouldComponentUpdate这个钩子函数\n5.  如果shouldUpdate 为true, 调用componentWillUpdate钩子函数\n6.  不管shouldUpdate是什么, 都更新当前 instance 的 props, state, context,  这样子这个work的相当于可以被复用了, 就算没有rerender, 至少更新了instance内部的状态\n\n\n##### updateFunctionalComponent\n```\n  function updateFunctionalComponent(current, workInProgress) {\n    const fn = workInProgress.type;\n    const nextProps = workInProgress.pendingProps;\n\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else {\n      if (workInProgress.memoizedProps === nextProps) {\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      // TODO: consider bringing fn.shouldComponentUpdate() back.\n      // It used to be here.\n    }\n\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var context = getMaskedContext(workInProgress, unmaskedContext);\n\n    var nextChildren;\n\n    nextChildren = fn(nextProps, context);\n\n    // 直接调用 reconcileChildren 进行 diff, 生成 effect list\n    // 与updateClassInstance对比就可以发现少了生命周期的功能\n    reconcileChildren(current, workInProgress, nextChildren);\n\n    memoizeProps(workInProgress, nextProps);\n    return workInProgress.child;\n  }\n```\n\n#### finishClassComponent\n\n```\nfunction finishClassComponent(\n    current: Fiber | null,\n    workInProgress: Fiber,\n    shouldUpdate: boolean,\n    hasContext: boolean,\n  ) {\n    // Refs should update even if shouldComponentUpdate returns false\n    markRef(current, workInProgress);\n\n    if (!shouldUpdate) {\n      // Context providers should defer to sCU for rendering\n      if (hasContext) {\n        invalidateContextProvider(workInProgress, false);\n      }\n\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    const instance = workInProgress.stateNode;\n\n    // Rerender\n    ReactCurrentOwner.current = workInProgress;\n    let nextChildren;\n\n    // 这个地方调用我们业务代码中的 render方法\n    nextChildren = instance.render();\n\n    // 这个是非常关键的一个方法, 要开始diff virtual dom的变更了\n    reconcileChildren(current, workInProgress, nextChildren);\n\n\n    // Memoize props and state using the values we just used to render.\n    // TODO: Restructure so we never read values from the instance.\n    memoizeState(workInProgress, instance.state);\n    memoizeProps(workInProgress, instance.props);\n\n    // The context might have changed so we need to recalculate it.\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, true);\n    }\n\n    return workInProgress.child;\n  }    \n\n```\n\n#### reconcileChildrenAtExpirationTime\n\n```\n    function reconcileChildrenAtExpirationTime(\n    current,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime,\n  ) {\n    if (current === null) {\n      // If this is a fresh new component that hasn't been rendered yet, we\n      // won't update its child set by applying minimal side-effects. Instead,\n      // we will add them all to the child before it gets rendered. That means\n      // we can optimize this reconciliation pass by not tracking side-effects.\n      workInProgress.child = mountChildFibers(\n        workInProgress,\n        null,\n        nextChildren,\n        renderExpirationTime,\n      );\n    } else {\n      // If the current child is the same as the work in progress, it means that\n      // we haven't yet started any work on these children. Therefore, we use\n      // the clone algorithm to create a copy of all the current children.\n\n      // If we had any progressed work already, that is invalid at this point so\n      // let's throw it out.\n      workInProgress.child = reconcileChildFibers(\n        workInProgress,\n        current.child,\n        nextChildren,\n        renderExpirationTime,\n      );\n    }\n  }\n\n```\n\n这个方法主要判断当前的节点是否已经挂载并且render过了,\n没有挂载: 执行mountChildFibers, 不会做side-effect 的优化, 会直接render这个节点\n已经挂载: 执行reconcileChildFibers, 会在virtual-dom中 使用算法优化, 生成最小的 side-effects, 用最小的dom变更去优化渲染性能\n\n\n#### reconcileChildFibers\n\n下面也能揭晓最开始 说的react新特性 支持 reder中return数组和字符串\n总的来说，这个函数根据newChild的类型调用不同的方法。\nnewChild可能是一个元素，也可能是一个数组（React16新特性）\n如果是reconcile单个元素，以reconcileSingleElement为例比较key和type，如果相同，复用fiber，删除多余的元素（currentFirstChild的sibling），\n如果不同，调用createFiberFromElement，返回新创建的。\n如果是string，reconcileSingleTextNode\n如果是array，reconcileChildrenArray\n如果是空，deleteRemainingChildren删除老的子元素\n\n```\n  // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n  function reconcileChildFibers(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    newChild: any,\n    expirationTime: ExpirationTime,\n  ): Fiber | null {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n\n    // 支持新的 fragments 标签\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    if (\n      typeof newChild === 'object' &&\n      newChild !== null &&\n      newChild.type === REACT_FRAGMENT_TYPE &&\n      newChild.key === null\n    ) {\n      newChild = newChild.props.children;\n    }\n\n    // Handle object types\n    const isObject = typeof newChild === 'object' && newChild !== null;\n\n    if (isObject) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(\n            reconcileSingleElement(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              expirationTime,\n            ),\n          );\n\n        case REACT_CALL_TYPE:\n          return placeSingleChild(\n            reconcileSingleCall(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              expirationTime,\n            ),\n          );\n        case REACT_RETURN_TYPE:\n          return placeSingleChild(\n            reconcileSingleReturn(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              expirationTime,\n            ),\n          );\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(\n            reconcileSinglePortal(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              expirationTime,\n            ),\n          );\n      }\n    }\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      return placeSingleChild(\n        reconcileSingleTextNode(\n          returnFiber,\n          currentFirstChild,\n          '' + newChild,\n          expirationTime,\n        ),\n      );\n    }\n\n    if (isArray(newChild)) {\n      return reconcileChildrenArray(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        expirationTime,\n      );\n    }\n\n    if (getIteratorFn(newChild)) {\n      return reconcileChildrenIterator(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        expirationTime,\n      );\n    }\n\n    if (isObject) {\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    // Remaining cases are all treated as empty.\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\n```\n\n#### reconcileChildrenArray\n\nreact最有名的virtual-dom 的diff过程可以用下面的这个方法来表示\n```\n  function reconcileChildrenArray(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    newChildren: Array<*>,\n    expirationTime: ExpirationTime,\n  ): Fiber | null {\n    // This algorithm can't optimize by searching from boths ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n\n\n\n    let resultingFirstChild: Fiber | null = null;\n    let previousNewFiber: Fiber | null = null;\n\n    let oldFiber = currentFirstChild;\n    let lastPlacedIndex = 0;\n    let newIdx = 0;\n    let nextOldFiber = null;\n\n    // 遍历一遍 新的newChildren数组, 通过 updateSlot来对比 新老数组的元素, 如果是相同元素, 就更新 fiber链表\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      const newFiber = updateSlot(\n        returnFiber,\n        oldFiber,\n        newChildren[newIdx],\n        expirationTime,\n      );\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n\n      // fiber是一个链表的数据结构, 这一步操作就是把 newFiber 放到链表的正确的位置, 构建 fiber 链表\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    // 如果遍历完新数组, 把老数组剩下的元素都删除了\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    // 如果老的数组已经遍历结束了, 但是新的数组没有结束, 遍历一下新数组剩下元素然后插入\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        const newFiber = createChild(\n          returnFiber,\n          newChildren[newIdx],\n          expirationTime,\n        );\n        if (!newFiber) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n        previousNewFiber = newFiber;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    // 如果没有命中上面两中情况: 那就是发生了移动或者删除的操作, 就把所有老数组元素按key放map里\n    const existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    // 继续遍历新的数组, 把老数组中有用的元素的插入到新的数组中, \n    for (; newIdx < newChildren.length; newIdx++) {\n      const newFiber = updateFromMap(\n        existingChildren,\n        returnFiber,\n        newIdx,\n        newChildren[newIdx],\n        expirationTime,\n      );\n\n      // 如果老数组这里面这个元素在新数组中有, 就插入,到新数组中, 并且在existingChildren 把这个元素删除,  因为最后existingChildren 中的元素都会被删除\n      if (newFiber) {\n        if (shouldTrackSideEffects) {\n          if (newFiber.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(\n              newFiber.key === null ? newIdx : newFiber.key,\n            );\n          }\n        }\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n        previousNewFiber = newFiber;\n      }\n    }\n\n    // 删除没有命中上面情况的元素, 就是删除老的数组中  非(老数组 交集 新数组)的元素\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(child => deleteChild(returnFiber, child));\n    }\n    最后返回的是一个fiber链表的第一个元素\n    return resultingFirstChild;\n  }\n\n```\n\ndiff完成之后, 一直return,  workInProgress.child = resultingFirstChild,\n后面回到 performUnitOfWork函数中, 执行 completeUnitOfWork\n\n#### completeUnitOfWork\n```\n  function completeUnitOfWork(workInProgress: Fiber): Fiber | null {\n    while (true) {\n      // The current, flushed, state of this fiber is the alternate.\n      // Ideally nothing should rely on this, but relying on it here\n      // means that we don't need an additional field on the work in\n      // progress.\n      const current = workInProgress.alternate;\n      \n      const next = completeWork(\n        current,\n        workInProgress,\n        nextRenderExpirationTime,\n      );\n      \n\n      const returnFiber = workInProgress.return;\n      const siblingFiber = workInProgress.sibling;\n\n      resetExpirationTime(workInProgress, nextRenderExpirationTime);\n\n      if (next !== null) {\n        stopWorkTimer(workInProgress);\n        if (__DEV__ && ReactFiberInstrumentation.debugTool) {\n          ReactFiberInstrumentation.debugTool.onCompleteWork(workInProgress);\n        }\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        return next;\n      }\n\n      if (returnFiber !== null) {\n\n        // 把 子树的 effect list 插入到 effect list of the parent.\n        // Append all the effects of the subtree and this fiber onto the effect\n        // list of the parent. The completion order of the children affects the\n        // side-effect order.\n        if (returnFiber.firstEffect === null) {\n          returnFiber.firstEffect = workInProgress.firstEffect;\n        }\n        if (workInProgress.lastEffect !== null) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n          }\n          returnFiber.lastEffect = workInProgress.lastEffect;\n        }\n\n        // 把当前fiber节点的effect list 也插入到 effect list of the parent.\n        // If this fiber had side-effects, we append it AFTER the children's\n        // side-effects. We can perform certain side-effects earlier if\n        // needed, by doing multiple passes over the effect list. We don't want\n        // to schedule our own side-effect on our own list because if end up\n        // reusing children we'll schedule this effect onto itself since we're\n        // at the end.\n        const effectTag = workInProgress.effectTag;\n        // Skip both NoWork and PerformedWork tags when creating the effect list.\n        // PerformedWork effect is read by React DevTools but shouldn't be committed.\n        if (effectTag > PerformedWork) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress;\n          } else {\n            returnFiber.firstEffect = workInProgress;\n          }\n          returnFiber.lastEffect = workInProgress;\n        }\n      }\n\n      stopWorkTimer(workInProgress);\n      \n\n      if (siblingFiber !== null) {\n        // If there is more work to do in this returnFiber, do that next.\n        return siblingFiber;\n      } else if (returnFiber !== null) {\n        // If there's no more work in this returnFiber. Complete the returnFiber.\n        workInProgress = returnFiber;\n        continue;\n      } else {\n        // We've reached the root.\n        const root: FiberRoot = workInProgress.stateNode;\n        root.isReadyForCommit = true;\n        return null;\n      }\n    }\n    return null;\n  }\n```\n 函数主主体是一个循环, 主要的功能就是调用 completeWork,  同时也执行 把 子树的 effect list 插入到 effect list of the parent.\n\n#### completeWork\n\n```\n  function completeWork(\n    current: Fiber | null,\n    workInProgress: Fiber,\n    renderExpirationTime: ExpirationTime,\n  ): Fiber | null {\n\n    // 获取组件的的 newProps\n    const newProps = workInProgress.pendingProps;\n\n    // 根据fiber的 tag 来做处理\n    switch (workInProgress.tag) {\n      case FunctionalComponent:\n        return null;\n      case ClassComponent: {\n        // We are leaving this subtree, so pop context if any.\n        popContextProvider(workInProgress);\n        return null;\n      }\n      case HostRoot: {\n        popHostContainer(workInProgress);\n        popTopLevelContextObject(workInProgress);\n        const fiberRoot = (workInProgress.stateNode: FiberRoot);\n        if (fiberRoot.pendingContext) {\n          fiberRoot.context = fiberRoot.pendingContext;\n          fiberRoot.pendingContext = null;\n        }\n\n        if (current === null || current.child === null) {\n          // If we hydrated, pop so that we can delete any remaining children\n          // that weren't hydrated.\n          popHydrationState(workInProgress);\n          // This resets the hacky state to fix isMounted before committing.\n          // TODO: Delete this when we delete isMounted and findDOMNode.\n          workInProgress.effectTag &= ~Placement;\n        }\n\n        // 最后是调用 updateHostContainer 来更新, 传入包含 effect list 的 workInProgress\n        updateHostContainer(workInProgress);\n        return null;\n      }\n      case HostComponent: {\n        popHostContext(workInProgress);\n        const rootContainerInstance = getRootHostContainer();\n        const type = workInProgress.type;\n        if (current !== null && workInProgress.stateNode != null) {\n          // If we have an alternate, that means this is an update and we need to\n          // schedule a side-effect to do the updates.\n          const oldProps = current.memoizedProps;\n          // If we get updated because one of our children updated, we don't\n          // have newProps so we'll have to reuse them.\n          // TODO: Split the update API as separate for the props vs. children.\n          // Even better would be if children weren't special cased at all tho.\n          const instance: I = workInProgress.stateNode;\n          const currentHostContext = getHostContext();\n\n          // 调用 host 传入的 prepareUpdate 方法, 生成需要更新的dom属性\n          const updatePayload = prepareUpdate(\n            instance,\n            type,\n            oldProps,\n            newProps,\n            rootContainerInstance,\n            currentHostContext,\n          );\n\n          // 最终是调用这个方法来更新dom的\n          updateHostComponent(\n            current,\n            workInProgress,\n            updatePayload,\n            type,\n            oldProps,\n            newProps,\n            rootContainerInstance,\n          );\n\n          // 如果 ref 有修改就标记一下ref更新\n          if (current.ref !== workInProgress.ref) {\n            markRef(workInProgress);\n          }\n        } else {\n          if (!newProps) {\n            invariant(\n              workInProgress.stateNode !== null,\n              'We must have new props for new mounts. This error is likely ' +\n                'caused by a bug in React. Please file an issue.',\n            );\n            // This can happen when we abort work.\n            return null;\n          }\n\n          const currentHostContext = getHostContext();\n          // TODO: Move createInstance to beginWork and keep it on a context\n          // \"stack\" as the parent. Then append children as we go in beginWork\n          // or completeWork depending on we want to add then top->down or\n          // bottom->up. Top->down is faster in IE11.\n          let wasHydrated = popHydrationState(workInProgress);\n          if (wasHydrated) {\n            // TODO: Move this and createInstance step into the beginPhase\n            // to consolidate.\n            if (\n              prepareToHydrateHostInstance(\n                workInProgress,\n                rootContainerInstance,\n                currentHostContext,\n              )\n            ) {\n              // If changes to the hydrated node needs to be applied at the\n              // commit-phase we mark this as such.\n              markUpdate(workInProgress);\n            }\n          } else {\n            let instance = createInstance(\n              type,\n              newProps,\n              rootContainerInstance,\n              currentHostContext,\n              workInProgress,\n            );\n\n            appendAllChildren(instance, workInProgress);\n\n            // Certain renderers require commit-time effects for initial mount.\n            // (eg DOM renderer supports auto-focus for certain elements).\n            // Make sure such renderers get scheduled for later work.\n            if (\n              finalizeInitialChildren(\n                instance,\n                type,\n                newProps,\n                rootContainerInstance,\n              )\n            ) {\n              markUpdate(workInProgress);\n            }\n            workInProgress.stateNode = instance;\n          }\n\n          if (workInProgress.ref !== null) {\n            // If there is a ref on a host node we need to schedule a callback\n            markRef(workInProgress);\n          }\n        }\n        return null;\n      }\n      case HostText: {\n        let newText = newProps;\n        if (current && workInProgress.stateNode != null) {\n          const oldText = current.memoizedProps;\n          // If we have an alternate, that means this is an update and we need\n          // to schedule a side-effect to do the updates.\n          updateHostText(current, workInProgress, oldText, newText);\n        } else {\n          if (typeof newText !== 'string') {\n            invariant(\n              workInProgress.stateNode !== null,\n              'We must have new props for new mounts. This error is likely ' +\n                'caused by a bug in React. Please file an issue.',\n            );\n            // This can happen when we abort work.\n            return null;\n          }\n          const rootContainerInstance = getRootHostContainer();\n          const currentHostContext = getHostContext();\n          let wasHydrated = popHydrationState(workInProgress);\n          if (wasHydrated) {\n            if (prepareToHydrateHostTextInstance(workInProgress)) {\n              markUpdate(workInProgress);\n            }\n          } else {\n            workInProgress.stateNode = createTextInstance(\n              newText,\n              rootContainerInstance,\n              currentHostContext,\n              workInProgress,\n            );\n          }\n        }\n        return null;\n      }\n      case CallComponent:\n        return moveCallToHandlerPhase(\n          current,\n          workInProgress,\n          renderExpirationTime,\n        );\n      case CallHandlerPhase:\n        // Reset the tag to now be a first phase call.\n        workInProgress.tag = CallComponent;\n        return null;\n      case ReturnComponent:\n        // Does nothing.\n        return null;\n      case Fragment:\n        return null;\n      case HostPortal:\n        popHostContainer(workInProgress);\n        updateHostContainer(workInProgress);\n        return null;\n      // Error cases\n      case IndeterminateComponent:\n        invariant(\n          false,\n          'An indeterminate component should have become determinate before ' +\n            'completing. This error is likely caused by a bug in React. Please ' +\n            'file an issue.',\n        );\n      // eslint-disable-next-line no-fallthrough\n      default:\n        invariant(\n          false,\n          'Unknown unit of work tag. This error is likely caused by a bug in ' +\n            'React. Please file an issue.',\n        );\n    }\n  }\n\n```\n\n这个方法主要的根据fiber的 tag 来执行不同的 update\n我们可以分析其中的常见的 tag 为 HostComponent的情况,可以看到 调用 host 传入的 prepareUpdate 方法, 生成需要更新的dom属性, 然后执行updateHostComponent方法\nprepareUpdate 和 updateHostComponent 都是react-dom里面传入的方法, 同样 在react-native, canvas等其他平台也有同样的定义, 相当于是一个规范的接口来兼容不同的硬件层\n\n#### updateHostComponent\n```\n      updateHostComponent = function(\n        current: Fiber,\n        workInProgress: Fiber,\n        updatePayload: null | PL,\n        type: T,\n        oldProps: P,\n        newProps: P,\n        rootContainerInstance: C,\n      ) {\n        // If there are no effects associated with this node, then none of our children had any updates.\n        // This guarantees that we can reuse all of them.\n        const childrenUnchanged = workInProgress.firstEffect === null;\n        const currentInstance = current.stateNode;\n        if (childrenUnchanged && updatePayload === null) {\n          // No changes, just reuse the existing instance.\n          // Note that this might release a previous clone.\n          workInProgress.stateNode = currentInstance;\n        } else {\n          let recyclableInstance = workInProgress.stateNode;\n          let newInstance = cloneInstance(\n            currentInstance,\n            updatePayload,\n            type,\n            oldProps,\n            newProps,\n            workInProgress,\n            childrenUnchanged,\n            recyclableInstance,\n          );\n          if (\n            finalizeInitialChildren(\n              newInstance,\n              type,\n              newProps,\n              rootContainerInstance,\n            )\n          ) {\n            markUpdate(workInProgress);\n          }\n          workInProgress.stateNode = newInstance;\n          if (childrenUnchanged) {\n            // If there are no other effects in this tree, we need to flag this node as having one.\n            // Even though we're not going to use it for anything.\n            // Otherwise parents won't know that there are new children to propagate upwards.\n            markUpdate(workInProgress);\n          } else {\n\n            // 下面就是调用 react-dom提供的接口来来添加变更到集合中, 有点类似于git中的 add 暂存操作, 等待commit\n            // If children might have changed, we have to add them all to the set.\n            appendAllChildren(newInstance, workInProgress);\n          }\n        }\n      };  \n```\n\n截止到这里,  reconcile的操作已经结束,  react的两个阶段(reconciliation , commiting) 已经完成了第一步\n现在要回到 performWorkOnRoot, 开始执行 completeRoot\n\n\n\n#### completeRoot\n```\nfunction completeRoot(\n    root: FiberRoot,\n    finishedWork: Fiber,\n    expirationTime: ExpirationTime,\n  ): void {\n    // Check if there's a batch that matches this expiration time.\n    const firstBatch = root.firstBatch;\n    if (firstBatch !== null && firstBatch._expirationTime <= expirationTime) {\n      if (completedBatches === null) {\n        completedBatches = [firstBatch];\n      } else {\n        completedBatches.push(firstBatch);\n      }\n      if (firstBatch._defer) {\n        // This root is blocked from committing by a batch. Unschedule it until\n        // we receive another update.\n        root.finishedWork = finishedWork;\n        root.remainingExpirationTime = NoWork;\n        return;\n      }\n    }\n\n    // Commit the root.\n    root.finishedWork = null;\n    root.remainingExpirationTime = commitRoot(finishedWork);\n  }\n\n```\n这个代码先判断一下是不是满足批量操作的优先级, 如果是满足, 就继续等下一个update, 最后一起批量地update\n不然就调用commitRoot来提交更新\n\n\n#### commitRoot\n```\n  //提交effect list更新到 dom中\n  function commitRoot(finishedWork: Fiber): ExpirationTime {\n    // We keep track of this so that captureError can collect any boundaries\n    // that capture an error during the commit phase. The reason these aren't\n    // local to this function is because errors that occur during cWU are\n    // captured elsewhere, to prevent the unmount from being interrupted.\n    isWorking = true;\n    isCommitting = true;\n    startCommitTimer();\n    const root: FiberRoot = finishedWork.stateNode;\n    root.isReadyForCommit = false;\n\n    // Reset this to null before calling lifecycles\n    ReactCurrentOwner.current = null;\n\n    let firstEffect;\n    if (finishedWork.effectTag > PerformedWork) {\n      // A fiber's effect list consists only of its children, not itself. So if\n      // the root has an effect, we need to add it to the end of the list. The\n      // resulting list is the set that would belong to the root's parent, if\n      // it had one; that is, all the effects in the tree including the root.\n      if (finishedWork.lastEffect !== null) {\n        finishedWork.lastEffect.nextEffect = finishedWork;\n        firstEffect = finishedWork.firstEffect;\n      } else {\n        firstEffect = finishedWork;\n      }\n    } else {\n      // There is no effect on the root.\n      firstEffect = finishedWork.firstEffect;\n    }\n\n    // 调用HostConfig.prepareForCommit的方法, 生成待提交的dom属性变更\n    prepareForCommit();\n\n    // Commit all the side-effects within a tree. We'll do this in two passes.\n    // The first pass performs all the host insertions, updates, deletions and\n    // ref unmounts.\n    nextEffect = firstEffect;\n    startCommitHostEffectsTimer();\n    while (nextEffect !== null) {\n      let didError = false;\n      let error;\n      if (__DEV__) {\n        invokeGuardedCallback(null, commitAllHostEffects, null);\n        if (hasCaughtError()) {\n          didError = true;\n          error = clearCaughtError();\n        }\n      } else {\n        try {\n        // 遍历effect list, commit 所有的 effect\n          commitAllHostEffects();\n        } catch (e) {\n          didError = true;\n          error = e;\n        }\n      }\n    }\n    stopCommitHostEffectsTimer();\n\n    resetAfterCommit();\n\n    // The work-in-progress tree is now the current tree. This must come after\n    // the first pass of the commit phase, so that the previous tree is still\n    // current during componentWillUnmount, but before the second pass, so that\n    // the finished work is current during componentDidMount/Update.\n    root.current = finishedWork;\n\n    // In the second pass we'll perform all life-cycles and ref callbacks.\n    // Life-cycles happen as a separate pass so that all placements, updates,\n    // and deletions in the entire tree have already been invoked.\n    // This pass also triggers any renderer-specific initial effects.\n    nextEffect = firstEffect;\n    startCommitLifeCyclesTimer();\n    while (nextEffect !== null) {\n      let didError = false;\n      let error;\n      if (__DEV__) {\n        invokeGuardedCallback(null, commitAllLifeCycles, null);\n        if (hasCaughtError()) {\n          didError = true;\n          error = clearCaughtError();\n        }\n      } else {\n        try {\n        // 遍历 effect list, commit 所有的生命周期, 就是执行 componentDidupdate之类的方法\n          commitAllLifeCycles();\n        } catch (e) {\n          didError = true;\n          error = e;\n        }\n      }\n      if (didError) {\n        invariant(\n          nextEffect !== null,\n          'Should have next effect. This error is likely caused by a bug ' +\n            'in React. Please file an issue.',\n        );\n        captureError(nextEffect, error);\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n\n    isCommitting = false;\n    isWorking = false;\n    stopCommitLifeCyclesTimer();\n    stopCommitTimer();\n    const remainingTime = root.current.expirationTime;\n\n    if (remainingTime === NoWork) {\n      capturedErrors = null;\n      failedBoundaries = null;\n    }\n\n    return remainingTime;\n  }\n\n```\ncommitRoot 主要分为三步\n1.  prepareForCommit() 调用HostConfig.prepareForCommit的方法, 生成待提交的dom属性变更\n2.  遍历effect list执行 commitAllHostEffects(), commit 所有的 effect,\n3.  遍历 effect list 执行 commitAllLifeCycles(), commit 所有的生命周期, 就是执行 componentDidupdate之类的方法\n\n\n#### commitAllHostEffects\n// 这个地方就是把所有的 effect都提交了,\n```\n  function commitAllHostEffects() {\n    // 把所有的effect 都遍历一遍, 然后\n    while (nextEffect !== null) {\n      if (__DEV__) {\n        ReactDebugCurrentFiber.setCurrentFiber(nextEffect);\n      }\n      recordEffect();\n\n      const effectTag = nextEffect.effectTag;\n      if (effectTag & ContentReset) {\n        commitResetTextContent(nextEffect);\n      }\n\n      if (effectTag & Ref) {\n        const current = nextEffect.alternate;\n        if (current !== null) {\n          commitDetachRef(current);\n        }\n      }\n\n      // The following switch statement is only concerned about placement,\n      // updates, and deletions. To avoid needing to add a case for every\n      // possible bitmap value, we remove the secondary effects from the\n      // effect tag and switch on that value.\n      let primaryEffectTag =\n        effectTag & ~(Callback | Err | ContentReset | Ref | PerformedWork);\n      switch (primaryEffectTag) {\n        case Placement: {\n          commitPlacement(nextEffect);\n          // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n          // any life-cycles like componentDidMount gets called.\n          // TODO: findDOMNode doesn't rely on this any more but isMounted\n          // does and isMounted is deprecated anyway so we should be able\n          // to kill this.\n          nextEffect.effectTag &= ~Placement;\n          break;\n        }\n        case PlacementAndUpdate: {\n          // Placement\n          commitPlacement(nextEffect);\n          // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n          // any life-cycles like componentDidMount gets called.\n          nextEffect.effectTag &= ~Placement;\n\n          // Update\n          const current = nextEffect.alternate;\n          commitWork(current, nextEffect);\n          break;\n        }\n        case Update: {\n          const current = nextEffect.alternate;\n          commitWork(current, nextEffect);\n          break;\n        }\n        case Deletion: {\n          isUnmounting = true;\n          commitDeletion(nextEffect);\n          isUnmounting = false;\n          break;\n        }\n      }\n      nextEffect = nextEffect.nextEffect;\n    }\n  }\n```\n\n\n#### commitWork\n```\n  function commitWork(current: Fiber | null, finishedWork: Fiber): void {\n    switch (finishedWork.tag) {\n      case ClassComponent: {\n        return;\n      }\n      case HostComponent: {\n        const instance: I = finishedWork.stateNode;\n        if (instance != null) {\n          // Commit the work prepared earlier.\n          const newProps = finishedWork.memoizedProps;\n          // For hydration we reuse the update path but we treat the oldProps\n          // as the newProps. The updatePayload will contain the real change in\n          // this case.\n          const oldProps = current !== null ? current.memoizedProps : newProps;\n          const type = finishedWork.type;\n          // TODO: Type the updateQueue to be specific to host components.\n          const updatePayload: null | PL = (finishedWork.updateQueue: any);\n          finishedWork.updateQueue = null;\n          if (updatePayload !== null) {\n            commitUpdate(\n              instance,\n              updatePayload,\n              type,\n              oldProps,\n              newProps,\n              finishedWork,\n            );\n          }\n        }\n        return;\n      }\n      case HostText: {\n        invariant(\n          finishedWork.stateNode !== null,\n          'This should have a text node initialized. This error is likely ' +\n            'caused by a bug in React. Please file an issue.',\n        );\n        const textInstance: TI = finishedWork.stateNode;\n        const newText: string = finishedWork.memoizedProps;\n        // For hydration we reuse the update path but we treat the oldProps\n        // as the newProps. The updatePayload will contain the real change in\n        // this case.\n        const oldText: string =\n          current !== null ? current.memoizedProps : newText;\n        commitTextUpdate(textInstance, oldText, newText);\n        return;\n      }\n      case HostRoot: {\n        return;\n      }\n      default: {\n        invariant(\n          false,\n          'This unit of work tag should not have side-effects. This error is ' +\n            'likely caused by a bug in React. Please file an issue.',\n        );\n      }\n    }\n  }\n\n```\n\n清空当前fiber的 updateQueue\n根据tag选择HostConfig中的 相关的 commit 方法, 比如当 tag = HostComponent , 调用 commitUpdate方法, 提交dom更新\n\n\n#### commitAllLifeCycles\n```\n  function commitAllLifeCycles() {\n    while (nextEffect !== null) {\n      const effectTag = nextEffect.effectTag;\n\n      if (effectTag & (Update | Callback)) {\n        recordEffect();\n        const current = nextEffect.alternate;\n        commitLifeCycles(current, nextEffect);\n      }\n\n      if (effectTag & Ref) {\n        recordEffect();\n        commitAttachRef(nextEffect);\n      }\n\n      if (effectTag & Err) {\n        recordEffect();\n        commitErrorHandling(nextEffect);\n      }\n\n      const next = nextEffect.nextEffect;\n      // Ensure that we clean these up so that we don't accidentally keep them.\n      // I'm not actually sure this matters because we can't reset firstEffect\n      // and lastEffect since they're on every node, not just the effectful\n      // ones. So we have to clean everything as we reuse nodes anyway.\n      nextEffect.nextEffect = null;\n      // Ensure that we reset the effectTag here so that we can rely on effect\n      // tags to reason about the current life-cycle.\n      nextEffect = next;\n    }\n  }\n\n```\n一个循环遍历 effect-list, 调用 commitLifeCycles 来触发相关的钩子函数\n\n#### commitLifeCycles\n\n```\n  function commitLifeCycles(current: Fiber | null, finishedWork: Fiber): void {\n    switch (finishedWork.tag) {\n      case ClassComponent: {\n        const instance = finishedWork.stateNode;\n        if (finishedWork.effectTag & Update) {\n          if (current === null) {\n            startPhaseTimer(finishedWork, 'componentDidMount');\n            instance.props = finishedWork.memoizedProps;\n            instance.state = finishedWork.memoizedState;\n            instance.componentDidMount();\n            stopPhaseTimer();\n          } else {\n            const prevProps = current.memoizedProps;\n            const prevState = current.memoizedState;\n            startPhaseTimer(finishedWork, 'componentDidUpdate');\n            instance.props = finishedWork.memoizedProps;\n            instance.state = finishedWork.memoizedState;\n            instance.componentDidUpdate(prevProps, prevState);\n            stopPhaseTimer();\n          }\n        }\n        const updateQueue = finishedWork.updateQueue;\n        if (updateQueue !== null) {\n          commitCallbacks(updateQueue, instance);\n        }\n        return;\n      }\n      case HostRoot: {\n        const updateQueue = finishedWork.updateQueue;\n        if (updateQueue !== null) {\n          const instance =\n            finishedWork.child !== null ? finishedWork.child.stateNode : null;\n          commitCallbacks(updateQueue, instance);\n        }\n        return;\n      }\n      case HostComponent: {\n        const instance: I = finishedWork.stateNode;\n\n        // Renderers may schedule work to be done after host components are mounted\n        // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n        // These effects should only be committed when components are first mounted,\n        // aka when there is no current/alternate.\n        if (current === null && finishedWork.effectTag & Update) {\n          const type = finishedWork.type;\n          const props = finishedWork.memoizedProps;\n          commitMount(instance, type, props, finishedWork);\n        }\n\n        return;\n      }\n      case HostText: {\n        // We have no life-cycles associated with text.\n        return;\n      }\n      case HostPortal: {\n        // We have no life-cycles associated with portals.\n        return;\n      }\n      default: {\n        invariant(\n          false,\n          'This unit of work tag should not have side-effects. This error is ' +\n            'likely caused by a bug in React. Please file an issue.',\n        );\n      }\n    }\n  }\n```\n这个方法主要就是根据不同的fiber.tag 来处理组件生命周期\n比如当tag=ClassComponent的时候,  把当前fiber中缓存的 props state赋值给组件实例, 并且调用componentDidUpdate钩子函数来完成一次组件更新\n\n\n\n# 回顾问题\n\n让我们来看看有没有解决最开始思考的问题\n\n1.  [Fiber](#React-Reconciler)引擎是什么, 它的原理是怎么样的: [Fiber](#React-Reconciler)\n2.  functionComponent的实现:   [updateFunctionalComponent](#updateFunctionalComponent)\n3.  新特性中的 render 中return array是怎么实现的:  [reconcileChildFibers](#reconcileChildFibers)\n4.  Fragment 实现  [beginWork](#beginWork) -> react/packages/react-reconciler/src/ReactFiberBeginWork.js -> updateFragment\n5.  virtual dom在 react中具体是以一个什么样的方式存在:  [reconcileChildrenArray](#reconcileChildrenArray)\n\n\n在阅读的过程中, 也思考了新的问题:\n\n1. 调度器怎么样找到下一个要执行的事务单元?\n2. 优先级怎么设置的?\n3. 调度器怎么样知道什么时候暂停和继续事务?\n4. 事务是怎么执行和标记为完成的? (事务分为两个步骤, begin complete,complete操作可以延期执行)\n5. 生命周期是怎么样被调用的?\n\n返回到 [导航](#导航), 再看一遍框架图, 可能会有不一样的感觉吧!\n\n\n# 结束\n\n对于React16的Fiber引擎分析到这里的结束了, 手动撒花!!!!\n\n当前文章的代码解读是基于 17年11月28发布的 React 16.2,因为时间和个人经验有限, 难免有理解错误或者不足的地方, 希望多多指正.\n\n------\n\n鉴于当前文章篇幅过长, 后续还将继续分析React-Dom相关的, 这一块主要就是 renderer的的工作\n-  React-Dom/events\n-  React-Dom/client\n\n\n\n","tags":["react"],"categories":["React"]},{"title":"一个NodeJS多进程共享内存,高性能,文件存储,轻量KV数据库","url":"%2F2017%2F08%2F13%2Ftech%2F%E4%B8%80%E4%B8%AANodeJS%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%2C%E9%AB%98%E6%80%A7%E8%83%BD%2C%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%2C%E8%BD%BB%E9%87%8FKV%E6%95%B0%E6%8D%AE%E5%BA%93%2F","content":"\n\n## 需求\n最近在做一个网页静态化的工具, 后台用的 node+ express, 但是没有用 DB, 主要是考虑到业务的数据量实在是小的可怜, 就是几个配置和日志文件 ,  所以我把数据用 fs.writeFile 直接写到 json 文件中, 然后每次读都直接 fs.readFile 读出来\n\n## 优化一\n但是这样子貌似是有些简陋, 其中完全可以把 文件读取相关的封装起来,  然后提供对象读写接口 类似于 get() put() remove() 等接口, \n\n既然是读多写少 , 那么上面的方案肯定是有优化点的, 比如写操作, 可以直接调用 fs readFileSync 同步的写, 反正量少  而读是大头, 经常一个 cgi 请求在返回之前可能会有好几个读的操作 , 那么我这样子直接调用readFileSync 是不是有些简单粗暴\n\n 说干就干, 搞一个 file-storage 的内部组件\n<!-- more -->\n```js\n// 简化版本的伪代码\nfunction Storage(filename) {\n  if (!filename) {\n    throw new Error('Storage requires path to a storage file');\n  }\n  var self = this;\n   try {\n    this..store = JSON.parse(fs.readFileSync(this.filename));\n  } catch(e) {\n    if (e.code !== 'ENOENT') {\n      throw e;\n    }\n      this..store = {};\n  }\n }\n\nStorage.prototype.put = function (key, value) {\n  this._setDeep(key, value, false);\n  this.queue.push();\n};\n\nStorage.prototype.get = function (key) {\n     return this._getDeep(key);\n};\n\nStorage.prototype.remove = function (key) {\n  this._setDeep(key, undefined, true);\n  this.queue.push();\n};\nmodule.exports = Storage;\n```\n\n\n这里我的方案是直接把数据存到内存中, 读直接读内存, 写的时候同时更新内存和文件的数据.  这样子貌似读性能很棒哦, 和当前的业务完美契合\n\n## 惨痛的现实\n生活哪有那么简单,要是有这么简单就不叫生活了\n\n\n我在本地调试的时候, 只有一个node 进程,  所以相安无事,但是部署到服务器的时候, 问题暴露了, 服务器中的是以多进程的模式在运行的, 也就说前后两个请求,并不一定是同一个进程在处理的,  那么, 各个进程中的 数据缓存就不一样了\n\n举例: \n\n在进程1 中,  我写了一条数据, store.put('hello', 'world') \n这里时候文件中内容已经更新了,  这个进程中的内存缓存数据也更新了, 但是, 其他进程的内存缓存数据并没有更新,  也就出现多个进程中数据不同步的现象\n\n## 方案调研\n遇到这种情况, 解决的办法通常有两种\n\n1.  用 memcache 或者 redis 等内存数据库进行多进程数据同步\n2.  ipc 进程通信同步各个进程的数据\n\n想想我们的应用穷的连数据库都上不起, 还想上内存数据库,运营成本有点大,  所以这里我选择 ipc 通信来同步各个 worker 进程中的数据\n\n>进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。\n\n 常用的 IPC通信模式很多\n \n *  管道（Pipe）及有名管道（named pipe，FIFO）  \n *  unix 域socket\n *  信号（Signal）\n *  消息队列(Posix消息队列system V消息队列)\n *  信号量（semaphore）\n *  共享内存( POSIX共享内存对象POSIX内存映射文件SYSTEM V共享内存)\n\n>* 简单的了解可以参考: \nhttp://blog.csdn.net/u013074465/article/details/46051189 \n>* 详细了解可以参考一本很经典的书: UNIX网络编程.卷2:进程间通信 \n\n通过 分析各种 ipc 通信的原来和使用场景\n我们选择使用 POSIX共享内存对象  的模式进行 IPC\n\n```c\nfd = shm_open(*name, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR)\n```\n \nshm_open创建一个名称为name，大小为O_RDWR的共享内存区对象后,\n在/dev/shm/下可以看到对应的文件，cat可以看到内容. \n\n>访问速度：非常快, 因为 /dev/shm 是tmpfs的文件系统，tmpfs是linux/Unix系统上的一种基于内存的文件系统。tmpfs可以使用您的内存或swap分区来存储文件。可以看成是直接对内存操作的，速度是非常快的。\n\n所以, 我可以在我的组件中加上内存共享的功能了,  这样子多进程之间的及不会有数据不同步的烦恼了, \n\n## 救星来了\n有现成的内存共享模块干嘛要自己写, 再说一个前端开发工程师去写 node 的 c++模块不专业,  这里我使用了  https://github.com/kyriosli/node-shared-cache \n\n这个模块就是基于上面提到的 \"共享内存\" 的方法实现的,具体的细节不过多讨论, 反正就是很 niubility\n\n提供一些简单的对象的读写功能, 但是有这两个功能对于我来说就够了\n\n```js\n// create cache instance\nvar cache = require('node-shared-cache');\nvar obj = new cache.Cache(\"test\", 557056);\n// setting property\nobj.foo = \"bar\";\n\n// getting property\nconsole.log(obj.foo);\n\n// 有个一个需要注意的地方是  和 原生的 js 对象之间无法互相引用, 有一定局限\n// 因为原生的 js 对象在进程的堆中, 而共享内存又是单独的一个内存区域\nvar test = obj.foo = {'foo': 'bar'};\ntest === obj.foo; // false\n```\n## 整合 node-shared-cache\n\n所以先我们在 file-storage 组件中增加共享内存的模块\n\n```js\n// 精简版的代码\nvar cache = require('node-shared-cache');\n// 增加共享内存功能的的 file-storage\nfunction Storage(filename) {\n  if (!filename) {\n    throw new Error('Storage requires path to a storage file');\n  }\n  var self = this;\n  // 初始化 obj 和 store\n  let shmName = filename.replace(/\\//g, \"-\").slice(-5, filename.length);\n  this.obj = new cache.Cache(shmName, 1073741824);\n  this.obj.store = self._load();\n  this.store = this.obj.store;\n }\n```\n 从上面的代码中可以看出来我把原本存储数据的 store 对象替换成 node-shared-cache 的对象了, 实现多进程共享 store数据的功能\n \n## 实战使用\n我们可以在项目中安装使用 \n\n注明: 需要 node-gyp 编译 c++模块 , 需要 gcc4.4.8版本支持 c++11\n\n我们一起来看看所以可以看到我修改后的 file-storage 组件在多进程中使用demo\n\n```js\nconst cluster = require('cluster');\nconst http = require('http');\nconst path= require('path');\nconst numCPUs = require('os').cpus().length;\nlet Storage = require('file-storage');\n\nif (cluster.isMaster) {\n    console.log(`主进程 ${process.pid} 正在运行`);\n    let store = new Storage(path.dirname(__filename) + '/test');\n    store.put('processid', []);\n\n    // 衍生工作进程。\n    for (let i = 0; i < numCPUs; i++) {\n        setTimeout(() => {\n            cluster.fork();\n        }, i * 1000);\n    }\n} else {\n\n        let store = new Storage(path.dirname(__filename) + '/test');\n        let processid = store.get('processid');\n        if (!processid) {\n            processid = [process.pid]\n        } else {\n            processid.push(process.pid);\n        }\n        store.put('processid', processid);\n        console.log(`工作进程${process.pid}, 查询的 store 对象为: ${JSON.stringify(store.get('processid'))} `);\n\n         http.createServer((req, res) => {\n             let visitnum = store.get('visitnum');\n             if (visitnum) {\n                 visitnum  = visitnum + 1;\n                 store.put('visitnum', visitnum)\n             } else {\n                 store.put('visitnum', 1);\n             }\n             res.writeHead(200);\n          res.end(`工作进程${process.pid}, 查询的 store 对象为: ${JSON.stringify(store.get('processid'))} 访问次数: ${store.get('visitnum')} `)\n          }).listen(8000);\n\n         }\n```\n\n```bash\n// 以下的数据可以看到不同进程是在共享同一个记数 visitnum\n\ncurl  http://127.0.0.1:8000/\n//工作进程24143, 查询的 store 对象为: [24135,24137,24138,24139,24141,24142,24143] 访问次数: 49\n\ncurl  http://127.0.0.1:8000/\n//工作进程24141, 查询的 store 对象为: [24135,24137,24138,24139,24141,24142,24143] 访问次数: 50\n\ncurl  http://127.0.0.1:8000/\n//工作进程24137, 查询的 store 对象为: [24135,24137,24138,24139,24141,24142,24143] 访问次数: 51\n```\n\n同时去直接查看 test 文件,也能看到我们写入的进程 id 和浏览量的数据\n\n## 总结\n这个组件使用场景还是有限的, 主要是在小数据量,单机多进程, 读多写少的情况比较适用, 读性能大概是原生 js对象的 1/4,  在研究 node-shared-cache 的时候, 也顺便迷上了 node 体系和 v8 引擎的一些原理, 以后研究的再深入一些也来写写自己的一些简单的见解","tags":["share_mem"],"categories":["Nodejs"]},{"title":"NodeServer技术运维调研与探索","url":"%2F2017%2F08%2F01%2Ftech%2FNodeServer%E6%8A%80%E6%9C%AF%E8%BF%90%E7%BB%B4%E8%B0%83%E7%A0%94%E4%B8%8E%E6%8E%A2%E7%B4%A2%2F","content":"\n## 为何要用公司内部的框架, 直接跑服务不好么?\n\n简单的部署运维 pm2 + (koa or express) + MongoDB\n可能遇到的问题:\n\n* 日志怎么管理?\n* 有没有服务监控与告警?\n* 怎么快速部署, 扩容?\n* 运维管理还得用命令行?\n* 负载均衡咋办?\n\n结论:  尽可能接入公司现有的运维与技术框架, 减少开发成本与运维成本,提高系统的稳定性和安全性\n![](1501589836_61_w1880_h806.png)\n<!-- more -->\n> tips: 虽然目前 pm2 等工具已经非常强大, 也提供现有的运维监控平台,但是由于服务运维是关键的路径,直接使用第三方还是需要详细研究,  目前还是使用自研的产品比较好\n\n##  公司现有的管理运维平台\n\nNode in tars --  Node.js 大规模商用平台\n\nTSW -- 针对web前端开发同学的server端web开发解决方案   https://tswjs.org/\n\n\n### Node in tars :\n\n1. 无需进行任何代码层面的的变更\n2. 在线的进程管理系统与运维平台\n3. 实时的日志查询\n4. 系统用量与请求监控\n5. 快速部署工具\n\n\n\n###SNG-TSW\n\n\n1. 开箱自带内部通用组件接口特性\n2. TSW 作者维护 tsw 包的版本, 机器负责人负责机器包更新\n3. 实时日志系统与服务端抓包\n4. 与包发布发布系统耦合\n5. 开源框架的兼容\n6. 路由,全局变量,常用 util\n\n\n\n## 一个技术框架与运维体系的应有的功能与组成\n\n* 进程管理 \n* 请求监控 与 用量监控 \n* 日志与监控告警平台 \n* debug 定位问题 \n* 接入公司内部标准组件\n* 开发流程 \n* 部署流程 \n* 启动,停止,重启,热重启\n* 扩容与迁移\n\n### 进程管理\n#### TSW:\n\n* 主进程负责监听端口,分发请求\n* worker进程负责处理业务\n* 负载均衡\n\n![TSW](1501589941_34_w1900_h868.png)\n\nNode in tars:\n\n![tars](1501590001_50_w1508_h816.png)\n\n>tips: 由主进程负责监听端口，接收新连接后再将连接循环分发给工作进程\n有一种基于round-robin 算法的模型,master 进程创建socket, 绑定地址端口, 同时负责监听\n当获取到新的连接之后(调用 accept 方法与客户端建立 tcp 连接), 再将这个连接分发到指定的 worker 进程, 这里如何分发到指定的 worker 进程是可控的, 这里使用了 round-robin 算法, 当然还有其他的算法也可以用于请求的分发.\n\n### 请求监控用量监控\n* tars: \n\t* 系统集成自带的监控\n\t* SET 内存、CPU用量数据，以及 eventloop 滞后数据\n\n\n* TSW: 主要依赖于公司平台级别的监控\n\t1. 机器性能监控\n\t2. kv 运行查看\n\t3. 模块调用日志\n\t4. 流水\n\n ### tips:  eventloop 滞后的定义\n\n作者给出的定义: js主线程处理不过来了,计算方法为: setTimeout 2s,然后减去2s, 得到的非0值就是滞后时间\n\n我的理解: EventLoop 滞后根据 js 的 event 事件模型中的概念来看的话: 可以作为一个指标来衡量 event 事件队列的长度, 比如 \n\t\t\n```\nfunction a(){\n\tsetTimeout(function(){alert('1');}, 0);\n\talert('2');\n}\na(); \n```\n\n这里 alert(1), 会滞后 alert(2) 执行, 这个之间的时间差可以用来作为 eventloop 滞后数据指标\n(这是我分析了event 事件的运行机制得出, 可能不一定准确, 有错误希望指出)\n\t\t\n### 日志\n\nTSW:\n\n* 实时日志 \n* 历史日志\n* 服务器本地日志\n\nNode in tars:\n\n* Console 重定向到特定的日志\n* 管理端动态变更日志基本\n* 实时日志查看客户端\n\n## 监控告警平台\n\nTSW:\n\n* 邮件告警, 自主配置通知者(业务模块、请求头、错误堆栈等)\n* 模调低于阈值98%告警(短信、内部IM信息通知)\n\ntars:\n\n* 系统/网络层监控(系统负载，磁盘，网络连通性)\n* 应用层监控(ps，http，log，port)\n* 业务层监控: pp监控(自定义多维度上报)\n\n### debug 定位问题\n\nTSW:\n\n* 服务端抓包 (毫秒级延时)\n* log(14天)\n* 服务器端日志\n* 染色\n\ntars\n* 实时日志查看\n* 管理平台更改日志输出级别\n* 染色 平台\n\n\n\n### 开发流程与部署流程\nTSW:\n\n* 推荐本地搭建 tsw 环境调试\n* 需要应用接入 tsw(成本较低)\n* 支持 文件 提单发布\n* 包发布打包发布(推荐)\n\ntars\n\n* 无需配置环境, tars 只是一个运行容器, 本地开发调试\n* nodetools 发布工具\n* Svn, git 在线编译与发布 \n\n>  tips: 在 tars 中,正式部署分为：编译与发布两个环节。\n编译环节中，先在平台上配置 SVN / GIT 并打 TAG 之后即可编译。\n编译完成了之后即可选择不同的版本进行发布，一旦发布出现问题则可快速进行回滚操作。\n\n### 启动,停止,重启,热重启\n\n* 包发布包中设置重启脚本\n* 安装或升级完成之后直接点击热重启或者重启\n* tars也支持在管理页面重启应用等操作\n* reload方案: 60秒刷新cache , 对性能损耗3%\n\n### 扩容\n\n* TSW: 包发布自动化一键安装(安装包,下发配置)\n\n\n# ----------------分割线---------------\n\n## 一点小改变: 在docker容器中运行NodeServer\n\n### 核心概念\n\n* Docker 镜像（Image）就是一个只读的模板。\n* 仓库（Repository）是集中存放镜像文件的场所,\n* 容器（Container）是从镜像创建的运行实例。它可以被启动、开始、停止、删除\n\n> tips:  Docker 和传统虚拟化方式的不同之处， Docker 的基础是 Linux 容器（LXC）,容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。\n\n### 镜像 ufs 容器\n\nDockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。\n![镜像ufs容器](1501590331_94_w1854_h912.png)\n\n```\n// Dockerfile\nFROM ubuntu:14.04\nADD run.sh /\nVOLUME /data\nCMD [\"./run.sh\"]\n```\n\nFROM ubuntu:14.04 :设置基础镜像，此时会使用基础镜像 ubuntu:14.04的所有镜像层，为简单起见，图中将其作为一个整体展示。\nADD run.sh /:将Dockerfile所在目录的文件run.sh加至镜像的根目录，此时新一层的镜像只有一项内容，即根目录下的run.sh.\n\nVOLUME /data:设定镜像的VOLUME，此VOLUME在容器内部的路径为/data。需要注意的是，此时并未在新一层的镜像中添加任何文件，但更新了镜像的json文件，以便通过此镜像启动容器时获取这方面的信息。\n\nCMD [\"./run.sh\"]:设置镜像的默认执行入口，此命令同样不会在新建镜像中添加任何文件，仅仅在上一层镜像json文件的基础上更新新建镜像的json文件。\n\n初始层(Init Layer)与可读写层(Read－Write Layer)，初始层中大多是初始化容器环境时，与容器相关的环境信息，如容器主机名，主机host信息以及域名服务文件等。\n\n### 构建基础镜像与开发部署流程\n\n![使用流程](1501590378_16_w1892_h1048.png)\n\n1. 开发代码\n2. 将代码打入现有的基础镜像\n3. build 出来 release 镜像\n4. 创建容器运行服务\n\n### 容器管理与运维\n\n![docker 三剑客](1501590404_58_w1918_h1068.png)\n\n* docker-machine相当于创建了几台可以运行docker的容器\n* docker swarm将多个容器做replication\n* docker engine就是单独的容器执行命令\n\n tips:开源可视化 swarm 容器管理界面\nhttps://github.com/portainer/portainer\nhttps://github.com/shipyard/shipyard\n\n### 优势\n\n* 告别紊乱的开发环境\n* 开发-生产环境，为应用提供了一致的环境\n* 应用程序运行环境隔离\n* 自带版本控制功能\n* 提升研发交付和运维上线效率\n* 快速部署\n\n\n## 回顾\n\n从部署一个app.js开始, 多维对比 tsw 和tars, 设想Node服务与容器结合, 其实太多的技术细节我们都不了解了, 还是要一步一步慢慢来, 先做好基础技术储备, 一步一个脚印, 从现在的1.0 技术储备时代转向  2.0小规模业务使用的探索时代\n","tags":["运维"],"categories":["Nodejs"]},{"title":"探究HTTP2","url":"%2F2017%2F08%2F01%2Ftech%2F%E6%8E%A2%E7%A9%B6HTTP2%2F","content":"\n\n## 探究HTTP2\n\n点击下载doc文档: [探究HTTP2](探究http2.0.docx)","tags":["https"],"categories":["网络协议"]},{"title":"浅谈 Web 前端中间件两种模型与实现","url":"%2F2017%2F07%2F28%2Ftech%2F%E6%B5%85%E8%B0%88Web%E5%89%8D%E7%AB%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AE%9E%E7%8E%B0%2F","content":"\n\n## 中间件是什么?\n\n首先它是一个组件, 其次, 它与具体的业务逻辑是解耦的,  业务逻辑经常需要调用底层逻辑或者一些系统通用逻辑,  然而每次都需要去编写这些接口和代码是没有必要的,  这时候中间件就可以出场了. \n\n具体的场景是可以看做如下:  前端业务需要某个服务,  我无需关心提供这项服务的具体底层逻辑, 只需要通过中间件获取到结果就好了\n\n## 具体的例子\n\n我们开发了一个很简单 webserver, 现在需要把不同 url 的请求路由到不同的业务处理 模块, 一开始我们的请求路径很少, 直接用 switch 语句就可以应付了, 后面随着路径越来越多, 每次都要改这个往这个 switch 加 case, 后面需求越来越变态了, 竟然要根据url路径中的参数(如用户 id 或者商品 id)路由到不同的 handler 方法,   显然我们的路由逻辑越来越复杂了\n\n作为一个开发者, 关于如何处理好的路由的显然不是我最关心的(我只想好好地写业务代码),  那么这时候如果有一个第三方(路由中间件), 只需要传入请求的匹配规则, 对应的 handler 函数, 至于如何把请求路由到正确的 handler 中, 那是路由中间件的事情了, 之后就可以愉快的写业务代码了\n<!-- more -->\n## 中间件的模型与机制\n\n### 1. 洋葱模型 (代表作 koa)\n首先来两张egg.js 官网的原理图帮助简单明地去理解\n洋葱模型:![](1501247526_13_w478_h435.png)\n中间件执行顺序: ![](1501247580_47_w594_h700.gif)\n\n通过上面的图看以看出, 所有的请求都会经过中间件两次,  先依次的进入中间件, 遇到 yield 退出来,执行下一个中间件,   反过来一个个往上面冒泡执行中间件yield 后面的代码, 这样子好处就是可以非常简单实现了后置处理逻辑, 比如想对返回的结果加一层封装就可以很简单的实现了\n\n下面来学习一下如何去实习,\n提前了解几个知识点:\n\n Generator  http://es6.ruanyifeng.com/#docs/generator  \n Promise   http://es6.ruanyifeng.com/#docs/promise \n Thunk函数  http://es6.ruanyifeng.com/#docs/generator-async#Thunk-函数\n \n可以点击去回顾温习一下\n\n简单的实现:\n\n```\nfunction* f1() {\n    console.log('f1: pre next');\n    yield* f2();\n    console.log('f1: post next');\n}\n\nfunction* f2() {\n    console.log('  f2: pre next');\n    yield* f3();\n    console.log('  f2: post next');\n}\n\nfunction* f3() {\n    console.log('    f3: pre next');\n    console.log('    f3: post next');\n}\n\nvar g = f1();\ng.next();\n```\n\n输出结果为:\n\n```\nf1: pre next\n  f2: pre next\n    f3: pre next\n    f3: post next\n  f2: post next\nf1: post next\n```\n再看看 koa 实现的源码\n\n```\n// 很简单就一行\nvar fn = this.experimental ? compose_es7(this.middleware) : co.wrap(compose(this.middleware));\n```\n也太简单了吧, 继续深入挖掘一下, 我们这里再重现一下\n \n\n```\n//  compose 的作用就是把 compose([f1, f2, ..., fn])转化为fn(...f2(f1(noop())))\nfunction compose(middleware) {\n    return function*(next) {\n        var i = middleware.length;\n        var prev = next || noop();\n        var curr;\n        while (i--) {\n            curr = middleware[i];\n            prev = curr.call(this, prev);\n        }\n        yield* prev;\n    }\n}\nvar co = require('co');\nco(compose([f1, f2, f3]));\n\n```\n\n看到这里可能会问 co 是什么?   https://github.com/tj/co  可以看一下官网的 readme, 同时源代码很少很精巧.  co 是一个函数库, 可以帮助我们不用自动执行 generator 函数, 不需要我们手动执行 next() 方法.\n\n有两种方式可以自动执行 Generator\n\n1. Thunk \n2. Promise 对象\n\nco 模块其实就是将两种自动执行器集合到一起去了（Thunk 函数和 Promise 对象）\n下面分别用用 Thunk 函数简单的实现 co 的原理\n\n```\n// Promise 版本的 co\nfunction co(gen) {\n  var ctx = this;\n\n  return new Promise(function(resolve, reject) {\n    if (typeof gen === 'function') gen = gen.call(ctx);\n    if (!gen || typeof gen.next !== 'function') return resolve(gen);\n  });\n}\n// Thunk 版本的 co\nfunction co(fn) {\n  var gen = fn();\n\n  function next(err, data) {\n    var result = gen.next(data);\n    if (result.done) return;\n    result.value(next);\n  }\n\n  next();\n}\n\nvar gen = function* (){\n  var f1 = yield Promise.resolve('f1');\n  var f2 = yield Promise.resolve('f2');\n  // 还支持数组的写法, 可以处理并发的异步操作,全部完成之后才会下一步\n  // var result  = yield [ \n  //\t\t Promise.resolve(1),\n  // \t\t Promise.resolve(2)]\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\nco(gen);\n\n```\n\n\n\n小结: \n\n使用  洋葱模型的 中间件很多, 比较有名就是 koa 的,  阿里出品的 egg 也是基于这个模式的,  前端的 Redux 中间件也是基于这个模型的, 本质上就是捕捉store.dispatch(action), 然后在dispatch 前后执行一些操作,比如记录日志\n\n\n### 2. 瀑布流模型 (代表作 connect  )\n虽然 \"洋葱模型\"  的中间件功能很强大, 也很符合中间件的设计逻辑, 但是\"瀑布流模型\"(connect) 结合 express中间件理念的设计, 我还是更加喜欢这种瀑布流方式的中间件设计方法\n\n具体的代码可以参考 https://github.com/senchalabs/connect#readme   connect 是一个中间件的库 , express 的中间件就是这个东西\n\n在 express 中, 一个完整个应用就是各种调用中间件\n\n```\napp.use(function(request,response,next){\n    if(request.url === '/'){\n        response.writeHead(200,{\"Content-Type\":\"text/plain\"});\n        response.end(\"This is home\\n\");\n    } else {\n        next();\n    }\n})\n```\n而这种调用方式也是十分优美的, 一个接着一个,顺序调用, 这与 express 框架的设计哲学相辅相成.\n实现起来没有洋葱模型的 koa 那么炫酷,比较朴素 ,源码有284行,  精简一下,中间件相关代码如下:\n\n```\n// 中间件本身是一个函数\nfunction middleware(req,res,next){\n    // do something;\n    // 做完后调用下一个函数\n    next();\n}\nfunction express() {\n    var funcs = []; // 待执行的函数数组, 这里可以拓展 funcs 为多层级对象,\n                    //可以借用中间件来实现路由的功能.\n    var app = function (req, res) {\n        var i = 0;\n        function next() {\n            var task = funcs[i++];  // 取出函数数组里的下一个函数\n            if (!task) {    // 如果函数不存在,return\n                return;\n            }\n            task(req, res, next);   // 否则,执行下一个函数\n        }\n        next();\n    }\n    /**\n     * use方法就是把函数添加到函数数组中\n     * @param task\n     */\n    app.use = function (task) {\n        funcs.push(task);\n    }\n    return app;    // 返回实例\n}\n```\n\n\n简单的来说express 的 connect 中间件功能并不入如洋葱模型的 中间件强大,  但是优势是结合了 express 框架的基于中间件运行的理念 , 在开发使用上面也能够得心应手\n\n## 小结\n\n本篇文章是最近了解 koa 和 egg.js 之后, 对  Web前端Server框架学习与探索  文中中间件部分的一个展开了解,  在学习的过程中, 也更加深刻的理解 generator 异步编程以及基于co 这个库一些异步编程应用\n\n","tags":["nodejs"],"categories":["Nodejs"]},{"title":"Web前端Server框架学习与探索","url":"%2F2017%2F07%2F23%2Ftech%2FWeb%E5%89%8D%E7%AB%AFServer%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8E%A2%E7%B4%A2(%E6%89%BF%E4%B8%8A)%2F","content":"\n\n## 前言\n最近开始接触到公司内部的一个 nodejs 的框架 TSW, 也看了很多内部论坛是上关于 tsw 文章 , 在学习开发使用的过程中, 也对部分技术框架的设计存有疑惑.\n但是, 就目前 tsw 在公司内部大范围的使用的情况来说, 接入完善的公司内部业务模块以及与走织云发布流程, 在使用上很好的承担了许多业务.\n\n由于个人的兴趣爱好,在业余的时间也打算研究一下如何去实现一个类似的框架以及开发流程, 本系列文章也算是自我学习的一个记录,加深理解.\n\n此次文章打算分上下两篇:\n\n上篇: 主要介绍如何去实现一个类似 tsw 的集合开发运维一条龙服务的框架.\n下篇: 尝试一下开发运维模式--node与服务容器化\n\n友情链接:   tswjs.org, tsw 的官网的文档还是写的挺幽默风趣的,就是内容比较少, 需要大家边用边摸索\n<!-- more -->\n\n## 进程管理:\n\n大部分的 node 程序都是通过 forever 或者 pm2之类的 Node应用的进程管理器来启动并且服务维护, \n使用这类工具可以使node服务在后台运行（类似于linux的nohup），另外它们可以在服务因异常或其他原因被杀掉后进行自动重启。 由于Node的单线程特征，自动重启能很大程度上的提高它的健壮性。\nNodeJS是单线程的工作方式，如何利用好 cpu 的多核也是开发者刚刚入门会遇到的问题之一。其实，NodeJS很早就支持了Cluster模式，这个就是同时开启多个进程来监听同一个端口，分发http请求处理，这里大家也许有疑问，如何合理的分发请求到给个子进程， 后面会提到...\n\n###最原始的 cgi\n\n每个请求，都需要经过启动进程、处理请求、结束进程三个步骤，对服务器的资源占用较大, 容易导致性能下降系统不稳定\n\n### FastCGI 协议\n FastCGI 协议让解释程序常驻在内存中, 不需要为每个请求都 fork 一个进程, 极大的提高了系统稳定性和资源的合理利用, 在这个基础上, FastCGI 也被设计为多进程调度的模式\n\n这个过程同样可以描述为三个步骤：\n\n1. 初始化 FastCGI 进程管理器，并启动多个 CGI 解释器子进程；\n2. 当请求到达 Web 服务器时，进程管理器选择并连接一个子进程，将环境变量和标准输入发送给它\n3. 处理完成后将标准输出和错误信息返还给 Web 服务器\n4. 子进程关闭连接，继续等待下一个请求的到来\n\n关于 cgi 和 fastcgi 之间的技术细节对比可以参考该文章: http://www.awaimai.com/371.html , 不在这里过多的阐述  \n\n## nodeJs 的child_process 和 cluster\n\nnodeJS 的单线程的模型决定了 node 原生只能利用单核的 cpu , 如果线程崩溃之后, 整个 web 程序都会崩溃, 和传统的原始 cgi 一样面临 稳定性差的问题, 不适合大规模的生产环境的使用\n为了解决整个问题, nodejs 自带 child_process 模块和 cluster 模块, 后者是对前者的一个更好的封装\n\nchild_process.fork()或者  cluster.fork() ,  衍生一个新的 Node.js 进程，并通过建立一个 IPC 通讯通道来调用一个指定的模块，该通道允许父进程与子进程之间相互发送信息。通过 fork 方法可以衍生任意多个同样的的 node.js 进程, 可以充分的利用好 cpu 的多核性能.看到这里, 我们是不是就会想如果通过 fork 功能, 是不是就实现一个类似 FastCGI 的协议了, master 进程负责监听端口, 接收到新的请求之后负责分发给多个工作进程, \n这里有两种连接分发的模式:\n\n模式一: 主进程创建监听socket后发送给感兴趣的工作进程，由工作进程负责直接接收连接:\n\nmaster 进程出创建socket, 绑定到 ip 和端口之后,  本身并不会调用 listen 和 accept 方法去建立连接, 而是将 socket 的 fd(文件描述符)传递到 fork 出来的work子进程中, work 进程负责监听新的连接, 然后执行业务代码. \n\n然而这种模式主要有两个问题, \n多个进程之间会 竞争 accept 一个连接,  容易导致 \"惊群现象\"(linux 内核2.6以上已经不会出现这个情况了) 惊群现象:  http://blog.csdn.net/russell_tao/article/details/7204260\n不能够确定哪个进程来处理新的连接, 完全是由系统自动分配, 对于开发者来说是不可控的, 容易导致各个 work 进程负载不均衡.\n\n模式二: 循环法。由主进程负责监听端口，接收新连接后再将连接循环分发给工作进程\n有一种基于round-robin 算法的模型, \nmaster 进程创建socket,  绑定地址端口, 同时负责监听\n当获取到新的连接之后(调用 accept 方法与客户端建立 tcp 连接), 再将这个连接分发到指定的 worker 进程, 这里如何分发到指定的 worker 进程是可控的, 这里使用了 round-robin 算法, 当然还有其他的算法也可以用于请求的分发.\n\n所以我们在一般的生产环境中都是使用模式二来出处理连接的分发\n\n\ndemo1:\n\n```\n// 以下的例子使用 socket 举例是为让大家更好的了解 连接 是如何分发的\nconst cluster = require('cluster');\nconst net = require('net');\nconst numCPUs = require('os').cpus().length;\n\nif (cluster.isMaster) {\n  console.log(`主进程 ${process.pid} 正在运行`);\n\n  // 衍生工作进程。\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`工作进程 ${worker.process.pid} 已退出`);\n  });\n  let handle = net._createServerHandle('0.0.0.0', 3000);\n  handle.listen();\n  handle.onconnection = function (err,handle) {\n    var worker = workers.pop();\n    worker.send({},handle);\n    workers.unshift(worker);\n}\n} else {\n  process.on('message', function (m, handle) {\n    let buf = 'worker process';\n    let res = ['HTTP/1.1 200 OK','content-length:'+buf.length].join('\\r\\n')+'\\r\\n\\r\\n'+buf;\n  console.log('got a connection on worker, pid = %d', process.pid);\n    let socket = new net.Socket({\n        handle: handle\n    });\n    socket.readable = socket.writable = true;\n    socket.end(res);\n});\n}\n\n\n```\n\ndemo2\n```\nconst cluster = require('cluster');\nconst http = require('http');\nconst numCPUs = require('os').cpus().length;\n\nif (cluster.isMaster) {\n  console.log(`主进程 ${process.pid} 正在运行`);\n  // 衍生工作进程。\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n} else {\n  // 工作进程可以共享任何 TCP 连接。\n  // 在本例子中，虽然表面上创建了多个 http 服务, 但是本质上共享的是一个 HTTP 服务器。\n  http.createServer((req, res) => {\n    res.writeHead(200);\n    res.end('helloworld\\n');\n  }).listen(8000);\n}\n```\n\n跑下 demo2, 可以发现\n分配给 master 进程和 worker 进程的 device(内核地址)都不一样,  说明各个进程都有自己的 socket, 并且只有一个master 进程在处于 listening 状态, 说明只有 master 进程负责监听8000的端口, worker 进程的 tcp 状态都是 Established, 说明master 把Established状态的连接分配给多个 worker 进程,  worker进程不需关心建立 socket 连接, 只需要处理业务和 连接的 io 操作(比如往连接中写数据),通过上述的分析也验证了cluster 确实是使用模式二来进行连接分发的. 而且从结果来看 round-robin 的调度策略还是可以很好的负载均衡的.\n\n特殊情况: socket.io 可以使用 ip hash, master 进程只把同源 ip 的连接分配给同一个 worker 进程就行了 \n\n```\nif (cluster.isMaster) {\n    // ip hash\n    var worker_index = function(ip, len) {\n        var s = '';\n        for (var i = 0, _len = ip.length; i < _len; i++) {\n            if (!isNaN(ip[i])) {\n                s += ip[i];\n            }\n        }\n        return Number(s) % len;\n    };\n    var server = net.createServer({ pauseOnConnect: true }, function(connection) {\n        var worker = workers[worker_index(connection.remoteAddress, num_processes)];\n        worker.send('sticky-session:connection', connection);\n    }).listen(port);\n}\n\n```\n具体的实践有多种方式,可以参考该篇文章 https://segmentfault.com/a/1190000009622158\n\n\nhttp://upload-images.jianshu.io/upload_images/332289-af4940f6779a796c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\n\n\n### 进程守护\nmessage 事件是 master 与 worker 之间的通信桥梁, 也是进程守护的一个基础, 当工作子进程因为未处理异常而崩溃时,  master 进程监听 exit 和 disconnect 事件 然后重新fork 新的子进程, 同时也可以利用这个机制来进行热重启.\n\n```\n// 监控进程退出事件,  看情况决定是否重新 fork 进程\ncluster.on('exit', function (worker, code, signal) {\n    if (worker.exitedAfterDisconnect === true) {\n        console.log('Oh, it was just voluntary – no need to worry');\n    } else {\n        clsuter.fork();\n    }\n});\n// disconnect 事件: worker 进程可以通过调用 process.disconnect() 方法主动断开与 master 的ipc 管道连接,  可以设置 worker.exitedAfterDisconnect 来区分自发退出还是被动退出，主进程可以根据这个值决定是否重新衍生新的工作进程\ncluster.on('disconnect', function () {\n    clsuter.fork();\n});\n```\n\n## 进程间通信\n\n在 nodejs 的 child process 模块中, 运行通过 child.send()方法向子进程发送发送消息, 子进程也可以通过 process.send()向父进程发送消息,\n```\n// 使用进程之间的通信很简单, 比如下面\n// 父进程:\nif (cluster.isMaster) {\n    cluster.on('message', (worker, message, handle) => {\n        worker.send(message);\n        // ...\n    });\n} else if(cluster.isWorker){\n    // 子进程\n    process.send({ foo: 'bar' });\n    process.on('message', (msg) => {\n    process.send(msg);\n  });\n}\n\n```\n\n关于 ipc(Inter-Process Communication, 进程间通信) 全双工双向通信的方案:socketpair , 了解更多可以参考如下\nhttps://www.ibm.com/developerworks/cn/linux/l-pipebid/index.html\nhttp://www.cnblogs.com/keepsimple/archive/2013/05/20/3088248.html\n\n\n关于 node 的进程管理可以暂时告一段落, 看到这里,就是可以自己实现一个简单的版本PM2 的 node 进程管理程序,获取更加激进一点去做一个负载均衡的 node 多进程服务器了\n\n## 应用层接入\n\n前面一节我们认识到了 node 的进程管理, 也知道怎么样去做一个多进程模型的服务器了, 那么现在tcp 的连接有了, 该上升到 http 的应用层了\n```\nlet server = http.createServer(app).listen(port);\n\n// app 就是应用层的入口了, \nconsot app = (request, response) => {\n    response.writeHead(200, {\n        \"Content-Type\": \"text/plain\"    \n    });\n    response.end(\"Hello world!\\n\");\n}\n```\n现在市面上大部分的框架也所做的工作其实都在扩展这个 app 函数的功能, 主要分为以下几个部分\n### request response 增强:\n这里需要做两件事:\n    1. 扩展了Node的http.IncomingMessage对象，提供了一个稳健的对象请求。\n    2. 扩展了Node的http.ServerReponse对象，提供响应对象。\n###路由:\n```\n// 一个很丑陋但是很基础的路由\nconsot app = (request, response) => {\n    if(request.url == '/'){\n    response.writeHead(200, { \"Content-Type\": \"text/plain\" });\n    response.end(\"Home Page!\\n\");\n  } else if(request.url == '/about'){\n    response.writeHead(200, { \"Content-Type\": \"text/plain\" });\n    response.end(\"About Page!\\n\");\n  } else{\n    response.writeHead(404, { \"Content-Type\": \"text/plain\" });\n    response.end(\"404 Not Found!\\n\");\n  }\n}\n```\n显然在实际的生产中是不会这样子写路由的,  常规的做法是把路由抽象出来变成路由的配置, 然后调用对应的处理函数, 当然看完下面中间件模块之后, 我们将会有一个思维上面的飞跃...\n\n###中间件: \n中间件描述 https://stephensugden.com/middleware_guide/   \n下面以 express 框架为例, 实现一个简化版本的中间件\n\n```\n// 中间件本身是一个函数\nfunction middleware(req,res,next){\n    // do something;\n    // 做完后调用下一个函数\n    next();\n}\nfunction express() {\n    var funcs = []; // 待执行的函数数组, 这里可以拓展 funcs 为多层级对象,\n                    //可以借用中间件来实现路由的功能.\n    var app = function (req, res) {\n        var i = 0;\n        function next() {\n            var task = funcs[i++];  // 取出函数数组里的下一个函数\n            if (!task) {    // 如果函数不存在,return\n                return;\n            }\n            task(req, res, next);   // 否则,执行下一个函数\n        }\n        next();\n    }\n    /**\n     * use方法就是把函数添加到函数数组中\n     * @param task\n     */\n    app.use = function (task) {\n        funcs.push(task);\n    }\n    return app;    // 返回实例\n}\n```\n\n###视图: \n关键就在于模板引擎的实现, 接着上个例子-中间件\n```\nvar fs = require('fs'); // 引入 fs 文件模块\nvar filePath = './views';\napp.use(function (req, res, next) { \n        // 定义一个模板引擎\n        res.render = (filePath, option) => {\n            fs.readFile(filePath, function (err, content) {\n        if (err) return callback(new Error(err));\n        // 这是一个最简单的模板引擎了...\n        var rendered = content.toString().replace('#title#', ''+ options.title +'').replace('#message#', ''+ options.message +'');\n        return callback(null, rendered);\n        });\n    }\n});\n```\n\n###orm:\n对于目前轻量化的框架来说, 加上 orm 的功能貌似有些重, 这里可以考虑使用 MongoDB 的 Mongoose ODM, 作为一个用户可选项\n\n以上的各个应用模块主流的框架都有成熟的可以学习, 相信有时间去阅读一两个框架的源码,估计会功力大增,同时也为以后设计的软件架构打好基础.\n\n\n### 兼容其他框架\n\n以上的 路由, 视图,中间件, orm 等四个模块是一个主流的框架基本所具备的, 所以这里需要我们重复造一个轮子么, 答案是不需要, 一方面主流的框架都有技术社区, 如果是模仿他们的话,完全没有必要, 无非是增加开发者的选择困难. 所以这里兼容其他的框架是必不可少的\n\n切入点: 实现一个简单的路由, 将不同域名的请求转发不同的 app 中去, \n\n```\n// 服务文件所在目录\nvar serverPath = '/data/release/node_modules';\nvar map = {\n    'a.qq.com': {\n        'App1': '/App1/app.js',\n        'App2': '/App2/app.js',\n    },\n    'b.qq.com': {\n        'App1': '/App1/app.js',\n        'App2': '/App2/app.js',\n    }\n};\n/**\n * 根据map 加载不同的 app\n */\nlet findApp = function(req, res) {\n    var host = req.REQUEST.host || '';\n    var app = map[host];\n    if (!app) {\n        res.end('404');\n        return;\n    }\n    if (typeof app == 'object') {\n        var pathname = req.REQUEST.pathname || '';\n        var arr = pathname.split('/');\n        var firstPath = arr[1] || '';\n        return require(serverPath + app[firstPath]);\n    } else if (typeof app == 'string') {\n        return require(serverPath + app);\n    }\n    return require(serverPath + defaultApp);\n};\n```\n 就这样子简单我们的框架只需要负责好转发即可,至于其他的, 扔给 koa express 等框架去处理.\n\n\n##日志上报,监控告警\n\n一个好的系统框架肯定少不了这些\n日志:  现在有很多开源并且成熟的日志库, 可以直接引入使用, 如果开发者需要上报日志,只需要配置一下当前日志的路径即可, \n\n监控告警与日志上报:  master 进程在启动的时候, 除了在启动 worker 进程之外, 还需要启动一个监控相关的进程, 主要的作用\n1. 定时查询服务器的运行状态进程详细信息（PID、重启次数、上线时长、内存占用、错误日志）,并且上报\n2. 定时获取各个 APP的 log, 上报最新的log\n3. 可以把这个进程的作用当做是一个系统运维功能的大杂烩, 减轻主进程的负担, 尽量就让主进程只处理listening 和连接的分发\n\n\n## 小结\n 上篇的文章大致到这里, 很多技术细节由于时间问题,没有能够深挖, 以后有机会再展开细细的品尝,\n当然本文只是一个引子, 主要还是为下文做准备...\n\n\n\n\n\n","tags":["tsw"],"categories":["Nodejs"]},{"title":"20161106实习总结","url":"%2F2016%2F11%2F06%2Fdaily_think%2F20161106-%E5%AE%9E%E4%B9%A0%E5%91%A8%E6%8A%A5%2F","content":"\nHI all:\n\n本周主要的任务\n 1 跟进商圈定向的测试\n 2 新官网数据统计新增 FSiteType 和 FHotTag字段, 跟进db 的 ddl 变更\n 3 米大师白名单, 转化跟踪(付费,加入购物车,付款)去掉白名单限制 , 拆分激活率为 下载激活率和点击激活率\n<!-- more -->\n 总结:\n    在做官网数据的统计这个需求的过程中, 涉及到更新表的字段, 期间多次更改代码的 cr, 第二次体会到公司对 在 db 上的严谨性. db元数据不一致问题拖延了项目的进度, 期间也多次和 mof_helper 争论了 关于 not null 的合理性, not null 对 db 的索引效率的提高我不否认, mysql 是使用 b+ tree 作为索引, 而 b+ tree要对 null 做特殊处理影响效率.\n    疑问: \n        那为什么非索引的字段也要强制 null 呢, 起初我想当然的以为 mysql 的innoDB 引擎默认会对所有的字段做索引的(其实想想就知道不可能)\n        mysql innoDB 使用的 B+ tree, InnoDB的数据文件本身就是索引文件,这种索引类型叫做聚集索引。主要的原理下面的文章写的非常不错,我也简要的概述一下:\n\n        1 表数据文件本身就是按B+Tree组织的一个索引结构:如下图\n        叶节点包含了完整的数据记录。\n        2 InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。这里也解释了为什么不建议使用过长的字段作为主键\n        上面的两点也就排除了我 前面的疑问\n\n    解答\n        这是 mysql 官方的一段话: \n        NULL columns require additional space in the row to record whether their values are NULL. For MyISAM tables, each NULL column takes one bit extra, rounded up to the nearest byte\n        null 值和空值是不一样的, null 值会占用额外的1bit 空间\n\n    1 很多表都包含可为NULL的列，即使应用程序并不需要保存NULL也是如此，这是因为可为NULL是列的默认属性（TIMESTAMP除外），然而通常情况下最好指定列为NOT NULL，除非真的需要存储NULL值。\n\n    2 如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL的列使得索引统计和值比较更加复杂。可为NULL的列会使用更多的存储空间，在MySQL里也需要特殊的处理。当可为NULL的字段被索引时，每个索引记录需要一个额外的字节，在MyASIM里甚至还可能导致固定大小的索引（例如只有一个整数列的索引）变成可变大小的索引。\n\n    3 通常把可为NULL的列改为NOT NULL 带来的性能提升比较小，所以（调忧时）没有必要首先在现有schema中查找并修改这种情况，除非确定这会导致问题。但是，如果计划在列上建索引，就应该尽量避免设计为NULL的列。当然也有一些例外，例如值得一提的是，InnoDB使用单独的位（Bit）存储NULL值，所以对于稀疏数据（很多值为NULL，只有少数行是非NULL）有很好的空间效率。但这一点不适用于MyISAM。\n                                                         ---引用自《高性能MySQL》\n    书上的话基本解答了我的疑问, 同时 ,也证明了光看书还是不行的,在校看过很多的书, 但是 看完之后能记住的不多, 主要还是缺乏真实的项目经验, 所以以后还是要在遇到问题的时候多思考多去探究,同时要反过来多去看看以前看过的那些书, 会有更深刻的理解\n\n    这篇文章在解释关于 db 的索引上面还是讲的深入简出,http://blog.jobbole.com/24006/\n\n  版本管理: \n\n    在接触投放端的一个月中, 对我最大的挑战不是代码, 而是版本管理的流程, 起初内心还是有点小抗拒的, 心想为什么要把版本的管理搞得这么复杂, 而事实上它确实是挺复杂的\n\n    期初我觉得问题是在版本管理软件上面, 如果换了 git 会有很大的改善么? 答案应该是不会, svn 和 git 都是代码管理的软件, 在公司的开发项目中, 就算是使用 git 我们多半也会把 git 当做 svn 来用, 而 git 本身最有特色的分布式的特性 可能在本地切分支的时候用的比较多. git 也许仅仅适用于代码本身的管理吧, 至于在公司的项目中, svn 目前反而更合适高效\n\n    接触的时间越久, 认识到复杂是由于软件系统本身复杂, ssi 使用 include 来拼接不同版本的模块确实是一种非常好的管理方法, 一方面前期是因为自己本身对项目整体了解的不够深入, 其次是v1 \n    v2两个版本的杂糅也增加了一些难度. 相信后面随着项目经验的累计, 对系统会有一个更加全面的掌握\n\n监听 css 动画 transitionend事件,animationend事件:\n        在做商圈定向批量上传的时候, 有个地方会有两个弹框, 弹框消失是自带 css3动画的, 为了防止 上一个动画未完全消失就出现下一个弹框, 我使用 setTimeout来延迟下一个弹框出现的时间.  这里我被自己局限住了, 想当然的以为 css的渲染和 js 的不是同一个线程,和以往的使用 js 实现的动画是不一样, 就认为无法实现 css动画结束的监听, 后来网上搜一下才知道transitionend事件,animationend事件, 这里感谢 Walker 指出我的问题, 容易被自己的认知局限住. 以后遇到类似的问题还是要多去网上搜索一下, 不能想当然的觉得...\n\n                                                                                                                \n\n  \n  ","tags":["B-tree"],"categories":["实习总结"]},{"title":"书籍推荐","url":"%2F2016%2F11%2F01%2Fdaily_think%2F%E8%AF%BB%E4%B9%A6%E4%B9%8B%E6%80%BB%E7%BB%93%2F","content":"\n\n## 读书会做好读书的笔记和总结,一方面是提高自己的读书深度和检测自己的理解程度,其实是给自己的知识输入做一些必要的输出,算是读书之后自己对内容的见解吧.\n\n## 近期读的书主要是\n\n1. 深入理解计算机系统\n2. unix套接字编程(网络编程)\n3. Unix套接字编程(进程通信)","tags":["daily_think"]},{"title":"2016/10实习总结","url":"%2F2016%2F10%2F01%2Fdaily_think%2F%E5%AE%9E%E4%B9%A0%E8%87%AA%E8%AF%84%2F","content":"\n\n1 主要的工作任务\n在腾讯实习的期间,截止到现在,主要的工作任务主要有两块\n\n    1  投放端性能监控上报系统\n    2  内部实验系统前端页面改版优化\n下面详细介绍一下我在以上两个项目中的工作内容\n<!-- more -->\n#### 投放端性能监控上报系统\n背景:\n    广告投放端上面有很多的上报项,主要用于投放端的运行性能监测,在没有做这个项目之前, 内部的人员要是想查看投放端的一些上报数据, 需要在here系统输入的sql语句从hermers中查询 ,同时 ,开发人员想添加一个上报的配置的话, 还得配置xml文件,过程繁琐\n主要功能:\n    1 用户只需要在下拉选择框选中对应的上报项, 就可以查看相关上报项的上报信息,主要以趋势图和表格的形式展示, 表格具有模糊搜索,准确搜索, 点击排序等功能, 方便运营或者开发人员快速定位到某一条上报的信息\n    2 集中式的配置管理, 拥有配置权限的用户可以进入该页面, 快速新增配置,或者 编辑已经存在的配置, \n    3 下载报表或者订阅报表\n我主要的工作内容:\n    1  设计数据库表, 编写后端php代码,在原有的here系统的框架下面,开发一个新的monitor模块, 提供整个性能监控上报系统的cgi接口,包括趋势图和表格的数据,上报配置信息数据等\n    2  使用require.js模块化的方式 组织 监控上报系统的前端代码架构, 使用DataTable的表格组件做table展示, 同时 重写了 datatable的ajax模块, 可以支持自定义的数据接口格式, 不必受限于datatable本身的对数据格式的限制,提高了数据展示的灵活性\n    3  编写配置管理的前端页面,该页面主要的工作就是对上报配置进行增删查改管理, 以个单页应用的形式, 涉及到很多前后端的数据交互.\n    4 由于 上报cgi需要每次从 db拉取配置,会影响性能,也可能出现从db拉取数据失败的情况,  所以开发一个缓冲层, 当从数据库读取配置数据失败时,就从缓冲的文件中拉取配置\n该项目从数据库设计,到后台的编写, 再到前端的页面设计,交互和业务逻辑,都是一个人完成,很锻炼人的能力, 同时也进一步发现自己不足的地方\n\n### 内部实验系统前端页面改版优化\n\n    这是广告定向组的一个需求,由于试验系统需要将查询的维度从原本的一维拉伸到多维 ,需要对原来实验系统的前端页面做改版\n    我主要的开发任务有如下:\n\n    1   开发多维的分类选择组件\n    2   由于table的数据较多,往下滚动参考table数据时 需要将table的表头固定显示\n    3   实验系统后端只提供原始数据, 许多delta和 delta+alpha数据需要前端对数据进行计算处理并table个性化展示,\n    4   重新规划 实验系统的指标选择模块, 并对后台返回的 多维数据进行解析处理\n 2 优势和劣势\n\n 优势:\n\n    技术面广, 从底层的DB,到后台的php或者python以及各种mvc框架,再到前端,客户端,均有涉猎,特别擅长于网络方面的内容\n    做事情比较积极,会主动的去推进项目的进度,遇到问题马上会解决, 不懂的就会一直去把它弄懂为止.\n    喜欢钻研技术问题,勇于去探究新的技术,有较强的学习能力和自我改正能力\n\n 劣势:\n\n    技术面广,但是缺少精通的一面, 需要在工作中不断的累计学习\n    沟通能力有待提高,在需求评审的时候,需要较强的沟通能力, 才能确保双方都正确的理解对方的意思\n    工作效率有待提高, 需要合理的使用各种高效的工具\n    缺乏团队合作编码的经验,需要更多的阅读他人优秀的代码,编码风格有待提高\n\n 3 综合评价\n在腾讯实习的这段时间, 在技术上面 ,我从一个学生开发者的慢慢的向团队协作靠齐,慢慢的纠正自己的编码规范,熟悉公司内部的各种开发流程, 理解 公司前后端框架每一层的作用和设计的理念和目的\n在编写性能监控上报项目的后端代码中, 我发现了一开始看来多此一举的 业务字段和数据库字段映射层是为了提高 数据库字段的的灵活性,特别是针对于上报配置这种多变的且种类复杂的业务\n在实验系统页面改版的过程中, 由于缺乏项目经验和对项目本身的理解, 导致前后端接口对接有问题,吸取教训,以后多多注意这些细节问题. 在做实验系统页面的改版过程中, 也学习了广告定向的一些知识概念\n\n总结: 对于公司的工作生活适应良好,还需多努力,多学习\n\n\n\n项目中遇到的问题\n前端: \n1  项目刚开始, 使用了大量的全局变量,(解决方案, 使用require.js 重新组织代码结构)\n\n在说table展示的时候, 自己有做过一套方案,就是普通的tbale外上加分页按钮,使用ajax拉取table数据 , 但是功能仅限于 做数据的展示 ,十分有局限性\n\n后来使用  使用datatable 组件,   这是一个很好用的开源table组件, 文档的完整性,项目的社区活跃性,开源组件现阶段版本迭代的稳定性,还有该组件对开发者开放的api等方面, 都特别符合在本项目长使用,有现成的搜索,本地或者全局排序功能,自带体验不错的分页功能, 可以引入官方的table样式, 提高开发效率. \n遇到的问题:\n\n    在使用DataTable的过程中,由于dataTable本身的功能的限制,无法与后台配合使用ajax实现分页数据的更新\n    如果使用DataTable默认的ajax交互功能，对传给后台和从后台获取的数据都有命名格式要求，这样一来耦合度较高，不利于后期扩展\n        不能直接适用于需要跟多种不同前端或其他业务交互的项目。\n解决方案  将DataTable中ajax拉取数据部分抽取出来重写,并做好封装, 也就是说调用该封装从服务器拉取数据, 该封装将会调用datatable提供的api ,将数据写入, 等同于将datatable 的数据拉取与渲染 分离出来,\n\n\n 3 PHP插入中文数据乱码（数据库建表的时候没有设置表的编码格式）\n\n 4  在开发投放端性能监控上报系统的时候, 由于老的上报cgi是一直从xml配置中读取上报的数据, 但是在新的上报系统中将配置存储在数据库中,也就是意味着每次上报都要从数据库拉取配置,这样无疑是回影响性能的, 所以这里有一个折中的方法就是将数据中的配置文件化,每次更新的时候把数据更新到票文件上就是了\n\n6  开发实验系统的前端页面优化的过程中\n主要遇到的问题有两个:\n\n表头冻结功能,实现上我尝试了两种 方案了,\n第一种: 检测页面的滚动事件,当table head被隐藏的时候 ,复制一个table head 使用fixed 固定在页面中,  但是这样的问题有如下几个\n\n一是性能不是很好, 二. 实验系统的表格比较复杂,会随着指标的变换会经常发生变动,在样式上面不一定能够百分百的还原出原本head的样式,偶尔会不可预测的发生位置偏移\n\n后来打算直接从css的入手, 通过监听 滚动事件, 计算 页面y轴滚动的距离与tablehead的位置之差, 实时设置 tablehead的 top参数,\n这样做的好处是,tablehead还是那个tablehead, 我们只是通过posittion的属性将其y轴固定住了\n\n7 页面分页问题\n\n由于实验系统的改版之后,用户可以选择多个维度来查询, 所以返回的数据量可能会很大.\n这是要考虑分页的问题, 但是有个问题是在分页的同时,不能将一天的数据切割到两个页面中去,也就是说我们不能再在用简单的 sql limit分页的方法了, 所以我这这里提出一个动态分页的方案目前还没有 运用在实验系统的 (这个还是不要讲了)\n\n8  关于di出错问题: 在一次开发的过程中, 由于修改了数据表的字段, 后端的很多代码也做了很多改动, 后来调试一直报错, 我以为是我的代码出了问题就是一直在检查自己的代码, 但是后面一直找不到问题出在哪里, 后来我的把关注的点转移到数据库那边, 后来的确认数据库也没有问题\n最后通过查看php框架的底层socket 会话层 的代码,发现php连接di出错才就报这个错误\n\n本来就是一个简单的连接错误, 也花费了很多的时间去排查, 所以在使用框架之前对框架有个整体的认识, 这样子出了问题就可以快速定位到错误点\n\n\n","tags":["daily_think"],"categories":["实习总结"]},{"title":"2016/10/17实习总结","url":"%2F2016%2F10%2F01%2Fdaily_think%2F%E5%B7%A5%E4%BD%9C%E5%91%A8%E6%8A%A5161008-1017%2F","content":"\n\n本周工作任务:\n\n1 投放端-lbs定向: 调整用户自定义地点的半径为 0.2km-25km\n2 投放端-lbs定向: 调整用户 lbs 地址的个数限制 至 400\n3 投放段-lbs定向: 用户批量导入地址功能\n4 上报系统修复下载报表的 bug(Hermes 的查询2000行以上就容易无结果返回)\n<!-- more -->\n工作进展: \n\t目前只完成了 atals_v2版本的开发,\n\t前面的两个调整半径和打点数量限制功能比较简单,只需要修改 代码中的参数, 而批量上传地址主要分两块的功能: \n\t\t1 用户上传地址文件, 后端批量解析,并返回成功与失败的地址数据\n\t\t2 获取到解析的结果之后渲染结果到界面, 调用批量上传的接口\n开发的总结:\n\t1  IE 浏览器 input 标签需要 用户手动去触发  , 原本代码是一个 a 标签的点击,然后触发 input 标签的点击事件, input 标签绑定 onchange 事件 调用上传的方法, 这种方式在 在 ie 里面会出现 script 拒绝访问的错误, 这是 ie 浏览器的安全限制问题,后来感谢 Walker 指出这个问题, 并给出解决的方案, 就是使用 label 标签的 for 属性,将 label 的点击事件转移到 input 上面呢\n\n\t2  发现一个旧版系统遗留的 bug , 自己就自己改了, 后来找 lioneli 对了一下, 发现自己修改的还是不够完美的(遇到问题或者 bug 需要找相关的同事确认一下, 不要自己不闷声的就去改代码)\n\t3  遇到一个用户体验的小问题,在用户批量上传的时候, 如果点数超过最大的限制, 我是直接不在地图上显示这些点, 还是把这些点打上去, 然后设置这些点的状态为未选中\n\t结论: 和同事讨论一下, 不要让用户做太多没有必要的选择,决定不把多出来的点打上去, 直接显示用户上传成功了多少个即可,而且, 上面的情况目前是不会出现的, 因为在调用批量上传的时候, 后端就就会确认有没有超过限制 , 返回给前端的的状态有两种, 一种是 全部上传成功的地址json 地址包, 另外一种:超过最大的限制直接返回对应的原因, 前端只需要把信息展示出来即可\n\t4 在刚刚开始开发的过程中, 找到需求对应的模块,就开始开发了, 依旧感谢 walker 作为导师尽职尽责,一次次的来考我投放流程的代码加载逻辑, 最后还耐心的亲自演示,这样子做很有道理, 首先,对应我来说,开发一个需求不仅仅是把功能做好,更重要的是借助做这个需求的过程去熟悉 代码的架构,\n\t而在下次的开发中就不需要分配那么多的时间去熟悉系统了, 同时, 对系统没有一个大局观是很危险的, 可能 代码在这个模块中有但是被其他组件引用之后就出 bug 了, \n\t5 上报系统本周在测试环境测试修改过的上报 cgi, 由于使用了 php 的文件缓存, 从 缓存中读取配置比原先的 xml 配置还要快,本周应该会上预发布和线上环境\n\t6 上报系统中对 Hermes 的依赖 : Hermes 对对用一次查询有10000行数据的限制, 而这个量对上报系统来说是远远不够的 为了解决这个问题,目前主要考虑 在后端细分查询的条件, 减少单次查询的量, 牺牲一定的运行速度, 但是要保证数据能显示出来,当然这是目前的方案, 长远的机会还需要和 eshion 从长计议\noutshine  09:29:57\nHi,all:\n\n在和导师walker商量之后, 以后每周一份周报, 来做工作汇总和技术沉淀总结\n\n本周主要工作任务:\n\n    1 投放端-lbs定向: 调整用户自定义地点的半径为 0.2km-25km\n    2 投放端-lbs定向: 调整用户 lbs 地址的个数限制 至 400\n    3 投放段-lbs定向: 用户批量导入地址功能\n    4 上报系统修复下载报表的 bug (Hermes 的查询2000行以上就容易无结果返回)\n    5 修复了上报系统的遗留bug \n\n工作进展: \n    \n    前面的两个调整半径和打点数量限制功能比较简单,只需要修改 代码中的参数, 而批量上传地址主要分两块的功能: \n        1 用户上传地址文件, 后端批量解析,并返回成功与失败的地址数据\n        2 获取到解析的结果之后渲染结果到界面, 调用批量上传的接口(需要处理各种返回边界的情况)\n    目前只完成了 atals_v2版本的开发\n\n开发的总结:\n\n    1  IE 浏览器 input 标签需要 用户手动去触发  , 原本代码是一个 a 标签的点击,然后触发 input 标签的点击事件, input 标签绑定 onchange 事件 调用上传的方法, 这种方式在 在 ie 里面会出现 script 拒绝访问的错误, 这是 ie 浏览器的安全限制问题,后来感谢 Walker 指出这个问题, 并给出解决的方案, 就是使用 label 标签的 for 属性,将 label 的点击事件转移到 input 上面呢\n\n    2  发现一个旧版系统遗留的 bug , 自己就自己改了, 后来找 lioneli 对了一下, 发现自己修改的还是不够完美的(遇到问题或者 bug 需要找相关的同事确认一下, 不要自己不闷声的就去改代码)\n\n    3  遇到一个用户体验的小问题,在用户批量上传的时候, 如果点数超过最大的限制, 是直接不在地图上显示这些点, 还是把这些点打上去, 然后设置这些点的状态为未选中?\n    结论 :  和同事讨论一下, 不要让用户做太多没有必要的选择,决定不把多出来的点打上去, 直接显示用户上传成功了多少个即可,而且,. 而且上面的情况目前是不会出现的, 因为在调用批量上传的时候, 后端就就会确认有没有超过限制 , 返回给前端的的状态有两种, 一种是 全部上传成功的地址json 地址包, 另一种情况 , :超过最大的限制, 直接返回失败及其 对应的原因, 前端只需要把信息展示出来即可\n\n    4 在刚刚开始开发的过程中, 找到需求对应的模块,就开始开发了, 依旧感谢 walker 作为导师尽职尽责,一次次的来考我投放流程的代码加载逻辑, 最后还耐心的亲自演示,这样子做很有道理, 首先,对应我来说,开发一个需求不仅仅是把功能做好,\n    更重要的是借助做这个需求的过程去熟悉 代码的架构和 开发的流程.\n    而在下次的开发中就不需要分配那么多的时间去熟悉系统了, 同时, 对系统没有一个大局观是很危险的, 可能 代码在这个模块中有用, 但是被其他组件引用之后就出 bug 了, \n\n    5 上报系统在测试环境测试上报 cgi, 由于使用了 php 的文件缓存, 从 缓存中读取配置比原先的 xml 配置还要快,下周会上预发布和线上环境\n\n    6 上报系统中对 Hermes 的依赖 : Hermes 一次查询有10000行数据的限制, 而这个量对上报系统来说是远远不够的 为了解决这个问题,目前主要考虑 在后端细分查询的条件, 减少单次查询的量, 牺牲一定的运行速度, 但是要保证数据能显示出来,当然这是暂时的方案, 长远的机会还需要 从长计议\n","tags":["daily_think"],"categories":["实习总结"]},{"title":"js异步那些事","url":"%2F2016%2F09%2F01%2Fcoding%2Fjs%E5%BC%82%E6%AD%A5%E9%82%A3%E4%BA%9B%E4%BA%8B%2F","content":"\n放在 今天(2019/01/29) async await很普及的情况,  文字部分内容可能已经不适用了, 但是作为技术实现了解也是有好处的\n\n\n\n\n### js事件概念\n\n##### 异步回调：\n首先了讲讲js中 两个方法 setTimeout()和 setInterval（）\n\n###### 定义和用法：\nsetTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。\n\n<!-- more -->\n###### 语法：\nsetTimeout(callback,time)\n\ncallback\t必需。要调用的函数后要执行的 JavaScript 代码串。\ntime\t必需。在执行代码前需等待的毫秒数。\n\n\nsetInterval() 方法和setTimeout很相似，可按照指定的周期（以毫秒计）来调用函数或计算表达式。\n\n<script type=\"text/javascript\">\nfunction timeCount()\n{console.log(\"this is setTimeout\");\nsetTimeout(\"timeCount()\",1000);\n\n}\n\nfunction timeCount2(){\nconsole.log(\"this is setInterval\");\n}\nsetInterval(\"timeCount2()\",1000);\n\ntimeCount();\ntimeCount2();\n</script>\n\n\n比如上述代码就是可以每隔1000毫秒延迟执行timecount函数，不同的是后者是周期的执行timecount函数，\nSetInterval为自动重复，setTimeout不会重复。\n\n#### 线程阻塞\nJavaScript引擎是单线程运行的,浏览器无论在什么时候都只且只有一个线程在运行JavaScript程序.\n\n```javascript\n<script type=\"text/javascript\"> \nfunction f() { console.log(\"hello world\");} \nvar t = new Date();  //运行5秒 \nwhile(true) { \nif(new Date() - t > 5000) { \nbreak; } \n} \nsetTimeout(f, 1000); \n</script>\n```\n执行上述代码，可以发现，总的运行时间几乎要6秒多，因为是单线程，会在while循环里面消耗5秒的时间，然后才去执行settimeout函数。\n\n#### 队列\n\n浏览器是基于一个事件循环的模型，在这里面，可以有多个任务队列，比如render是一个队列，响应用户输入是一个，script执行是一个。任务队列里放的是任务，同一个任务来源的任务肯定在同一个任务队列里。任务有优先级，鼠标或键盘响应事件优先级高，大概是其他任务的3倍。\n\n\n而我们常用的setTimeout函数，其本质上也就是向这个任务队列添加回调函数，JavaScript引擎一直等待着任务队列中任务的到来.由于单线程关系,这些任务得进行排队,一个接着一个被引擎处理.\n\n如果队列非空,引擎就从队列头取出一个任务,直到该任务处理完,即返回后引擎接着运行下一个任务,在任务没返回前队列中的其它任务是没法被执行的.\n\n二，异步函数类型\n\n异步io\n首先来看看很典型的一个例子 ，ajax\n```javascript\n<script type=\"text/javascript\"> \nvar  ajax = new XMLHttpRequest;\najax.open(\"GET\",url); \najax.send(null);\najax.onreadystatechange = function () {\n    if (request.readyState === 4) {\n        if (request.status === 200) {\n            return success(request.responseText);\n        } else {\n            return fail(request.status);\n        }\n    }\n}\n</script>\n```\n异步计时：\nsetTimeout，setInterval都是基于事件驱动型的，通常浏览器不会给这个太快的速度，一般是200次/秒，效率太低了是吧如果遇到有密集型的运算的话，那就呵呵了。但是在node.js中还有process.nextTick()这个强大的东西，运行的速度将近10万次/秒，很可观。\n\nprocess.nextTick(callback)\n\n功能：在事件循环的下一次循环中调用 callback 回调函数。效果是将一个函数推迟到代码书写的下一个同步方法执行完毕时或异步方法的事件回调函数开始执行时；与setTimeout(fn, 0) 函数的功能类似，但它的效率高多了。\n\n基于node.js的事件循环分析，每一次循环就是一次tick，每一次tick时，v8引擎从事件队列中取出所有事件依次进行处理，如果遇到nextTick事件，则将其加入到事件队尾，等待下一次tick到来时执行；造成的结果是，nextTick事件被延迟执行；\n\nnextTick的确是把某任务放在队列的最后（array.push)\nnodejs在执行任务时，会一次性把队列中所有任务都拿出来，依次执行\n如果全部顺利完成，则删除刚才取出的所有任务，等待下一次执行\n如果中途出错，则删除已经完成的任务和出错的任务，等待下次执行\n如果第一个就出错，则throw error\n下面看一下应用场景（包含计算密集型操作，将其进行递归处理，而不阻塞进程）：\n```javascript\nvar http = require('http');\nvar wait = function (mils) {\n    var now = new Date;\n    while (new Date - now <= mils);\n};\nfunction compute() {\n    // performs complicated calculations continuously\n    console.log('start computing');\n    wait(1000);\n    console.log('working for 1s, nexttick');\n    process.nextTick(compute);\n}\nhttp.createServer(function (req, res) {\n    console.log('new request');\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Hello World');\n}).listen(5000, '127.0.0.1');\ncompute();\n```\n三，异步错误处理\n\n\n异步异常的特点\n\n由于js的回调异步特性，无法通过try catch来捕捉所有的异常：\n```javascript\ntry {\n  process.nextTick(function () {\n  \tfoo.bar();\n  });\n} catch (err) {\n  //can not catch it\n}\n而对于web服务而言，其实是非常希望这样的：\n\n//express风格的路由\napp.get('/index', function (req, res) {\n  try {\n    //业务逻辑\n  } catch (err) {\n    logger.error(err);\n    res.statusCode = 500;\n    return res.json({success: false, message: '服务器异常'});\n  }\n});\n```\n如果try catch能够捕获所有的异常，这样我们可以在代码出现一些非预期的错误时，能够记录下错误的同时，友好的给调用者返回一个500错误。可惜，try catch无法捕获异步中的异常。\n难道我们就这样放弃了么？ 其实还有一个办法\n\n#### onerror事件\n我们一般通过函数名传递的方式（引用的方式）将要执行的操作函数传递给onerror事件，如window.onerror=reportError;window.onerror=function(){alert('error')}，但我们可能不知道该事件触发时还带有三个默认的参数，他们分别是错误信息，错误页面的url和错误行号。\n```javascript\n<script type=\"text/javascript\">   \n    window.onerror=testError;   \n    function testError(){   \n    arglen=arguments.length;   \n    var errorMsg=\"参数个数：\"+arglen+\"个\";   \n    for(var i=0;i<arglen;i++){   \n    errorMsg+=\"\\n参数\"+(i+1)+\"：\"+arguments[i];   \n}   \n    alert(errorMsg);   \n    window.onerror=null;   \n    return true;   \n}   \nfunction test(){   \n    error   \n}   \ntest()   \n</script> \n```\n#### 嵌套式回调的解嵌套\nJavaScript中最常见的反模式做法是，回调内部再嵌套回调。\n```javascript\n<script type=\"text/javascript\"> \nfunction checkPassword(username, passwordGuess, callback) {  \n  var queryStr = 'SELECT * FROM user WHERE username = ?';  \n  db.query(queryStr, username, function (err, result) {  \n    if (err) throw err;  \n    hash(passwordGuess, function(passwordGuessHash) {  \n      callback(passwordGuessHash === result['password_hash']);  \n    });  \n  });  \n} </script> \n```\n这里定义了一个异步函数checkPassword，它触发了另一个异步函数db.query，而后者又可能触发另外一个异步函数hash。它能用，而且简洁明了。但是，如果试图向其添加新特性，它就会变得毛里毛躁、险象环生，比如去处理那个数据库错误，而不是抛出错误、记录尝试访问数据库的次数、阻塞访问数据库，等等。\n下面我们换一种写法，虽然这种写法很啰嗦但是可读性更高而且更易扩展。\n```javascript\n<script type=\"text/javascript\"> \nfunction checkPassword(username, passwordGuess, callback) {  \n  var passwordHash;  \n  var queryStr = 'SELECT * FROM user WHERE username = ?';  \n  db.query(qyeryStr, username, queryCallback);  \n \n  function queryCallback(err, result) {  \n    if (err) throw err;  \n    passwordHash = result['password_hash'];  \n    hash(passwordGuess, hashCallback);  \n  }  \n \n  function hashCallback(passwordGuessHash) {  \n    callback(passwordHash === passwordGuessHash);  \n  }  \n}  </script> \n```\n\n在平时写嵌套时，我们应该尽量避免多层嵌套，不然中间某个地方出错了将会导致你投入更多的时间去debug。\n\n\n## PubSub模式：\n从原生的js角度，我们要监听某事件的方法就是利用addEventListener方法，但是当我们的页面趋于复杂，比如要向某个元素添加多个处理事件，那么就要用一个封装函数汇集多个处理函数\n```javascript\nlink.onclick = function() {\n    clickHandler1.apply(this, arguments);\n    clickHandler2.apply(this, arguments);\n};\n```\n在jquery中，jquery.on()方法使用的比较多，在新版的jquery中，也舍弃了bind（）方法，统一使用on，jQuery 将link 元素的事件发布给了任何想订阅此事件的人。\nNode.js中的EventEmitter 对象\n\n要想给EventEmitter 对象添加一个事件处理器，只要以事件类型和事件处理器为参数调用on 方法即可。\nemitter.on('evacuate', function(message) {\n    console.log(message);\n});\nemit（意为“触发”）方法负责调用给定事件类型的所有处理器。举个例子，下面这行代码：\nemitter.emit('evacuate');\n将调用evacuate 事件的所有处理器。\n\n请注意，这里的术语事件跟事件队列没有任何关系。\n\n使用emit 方法触发事件时，可以添加任意多的附加参数。所有参数均传递至所有处理器。\nemitter.emit('evacuate', 'Woman and children first!');\n事件名称不存在任何限制，然而Node 相关文档还是规定了一条有用的约定。\n\n如何实现一个自己的PubSub模式\n\n一个PubSub模型主要方法有3个，订阅，退订，发布\n```javascript\n<script type=\"text/javascript\"> \nvar PubSub = {};\n// 用于储存事件队列\nvar queue = {};\n\n// 订阅接口\nPubSub.on = function(event, cb) {\n  if (!queue[event]) {\n    queue[event] = [];\n  }\n  queue[event].push(cb);\n};\n\n// 退订接口\nPubSub.off = function(event, cb) {\n  var currentEvent = queue[event];\n  var len = 0;\n  if (currentEvent) {\n    len = currentEvent.length;\n    for (var i = len - 1; i >= 0; i--) {\n      if (currentEvent[i] === cb) {\n        currentEvent.splice(i, 1);\n      }\n    }\n  }\n};\n\n// 发布接口\nPubSub.emit = function(event) {\n  var currentEvent = queue[event];\n  if (currentEvent) {\n    for (var i = 0; i < currentEvent.length; i++) {\n      currentEvent[i]();\n    }\n  }\n};\n</script> \n```\n\n#### 使用\n```javascript\n<script type=\"text/javascript\"> \n// 订阅\nvar callbackA = function () {\n    console.log('event a happened')\n};\nPubSub.on('a', callbackA);\nPubSub.on('b', function() {\n    console.log('event b happened')\n});\n\n// 退订 , 第二个参赛传入回调函数的引用\nPubSub.off('a', callbackA);\n\n// 发布\nPubSub.emit('a');\nPubSub.emit('b');\n</script> \n\n```\n\n挖个坑 ，找一下jquery.on()的源码，看一下它自定义事件的实现\n\nPubSub模式不适用在一次性的事件中，，如果是用promise的话就比较适合一次性的事件。\n\n关于分布式事件，也可以参考一下angular.js的双向数据绑定的实现，http://www.tuicool.com/articles/vENni2Y\n\n\n## 五，Promise（或者Deferred）对象\n\n先来谈谈jquery中的promise的使用，来看一个例子\n原本写一个小动画我们可能是这样的\n```javascript\n<script type=\"text/javascript\"> \n$('.animateEle').animate({\n  opacity:'.5'\n}, 4000,function(){\n  $('.animateEle2').animate({\n    width:'100px'\n  },2000,function(){\n    $('.animateEle3').animate({\n      height:'0'\n    },2000);\n  });\n});\n</script> \n```\n\n但是如果我们使用promis对象的话，就可以使得代码更加简单易懂\n```javascript\n<script type=\"text/javascript\"> \nvar animate1 = function() {\n  return $('.animateEle1').animate({opacity:'.5'},4000).promise();\n};\nvar animate2 = function() {\n  return $('.animateEle2').animate({width:'100px'},2000).promise();\n};\nvar animate3 = function(){\n  return $('.animateEle3').animate({height:'0'},2000).promise();\n};\n$.when(animate1()).then(animate2).then(animate3);\n</script>\n```\n看了上面的例子大概对promise的作用有一定的了解了吧，那就来说说promis的原理吧\n\n## promise对象方法\n对于DOM，动画，ajax相关方法，都可以使用 promise 方法。调用 promise 方法，返回的是 promise 对象。可以链式调用 promise 方法。\n比如jquery中的ajax的 $.post $.get $.ajax 等方法，实际上都是默认调用了promise方法，然后返回了一个promise对象\n\npromise对象常见的方法有三个 ： done ， fail ， then 。\n```javascript\n<script type=\"text/javascript\"> \n$.get('/',{}).done(function(data){\n    console.log('success');\n}).fail(function(){\n    console.log('fail');\n});\n</script>\n```\n jquery 这里的接口方法太多了，就跟早期的事件方法绑定一样， live ， delegate ， bind ，最终还是归为 on \n\n ## deferred对象方法\n deferred 对象呢，也就是使用 $.Deferred() 方法，以及 $.when() 等方法创造出来的对象，它可以理解为一个升级版特殊的的promise对象\n 来看看一个例子\n ```javascript\n  <script type=\"text/javascript\"> \n  var  promisepbj = new $.Deferred();\n\n\t promisepbj.done(function() {\n\t  console.log('haha,done');\n\t}).fail(function() {\n\t  console.log('失败了');\n\t}).always(function(res) {\n\t  console.log('我总是被执行啦');\n\t});\n\n\t//使用resolve或者reject就可以调用defferred对象了\n\tpromisepobj.resolve();\n\t//promisepobj.reject();\n\n```\n\nresolve 方法会触发 done 的回调执行， reject 会触发 fail 的回调，对于 always 方法,deferred 对象,无论是 resolve 还是 reject ，都会触发该方法的回调。\n\n\n## ES6 Promise\n前面讲了很多jquery的promise实现，$.Deferred 和 ES2015 的 Promise 是不同的东西，因为前者不符合 Promises/A+ 规范。 Promise 对象在 EMCAScript 2015 当中已经成为标准。现在要来谈谈马上要成为主流趋势的es6原生promise对象，首先贴一个很详细的es6 promise的小书，基本你知道的不知道都在里面  http://liubin.org/promises-book/#introduction，\n\n把promise解释的很清楚的文章很多，我自认为我写不到他们那么好，索性干脆把阮一峰大神的文章贴出来 http://es6.ruanyifeng.com/#docs/promise\n我就来个简化版本的吧，用最短的字数来入个门。\n\n定义：\n谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。\n特点：\n1.   有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。\n2.   一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了\n\n### 基本用法\n```javascript\n  <script type=\"text/javascript\"> \nvar promise = new Promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n</script>\nPromise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。\n  <script type=\"text/javascript\"> \nfunction timeout(ms) {\n  return new Promise((resolve, reject) => {\n    setTimeout(resolve, ms, 'done');\n  });\n}\n\ntimeout(100).then((value) => {\n  console.log(value);\n});\n</script>\n```\n\n上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为Resolved，就会触发then方法绑定的回调函数。\n\n### 异常处理\n\n 　　异常处理一直是回调的难题，而promise提供了非常方便的catch方法：在一次promise调用中，任何的环节发生reject，都可以在最终的catch中捕获到：\n```javascript\nPromise.resolve().then(function(){\n    return loadImage(img1);\n}).then(function(){\n    return loadImage(img2);\n}).then(function(){\n    return loadImage(img3);\n}).catch(function(err){\n    //错误处理\n})\n```\n\n#### 基本的 api\nPromise.resolve()\nPromise.reject()\nPromise.prototype.then()\nPromise.prototype.catch()\nPromise.all() \nPromise.race() \n具体的很多的用法可以参考阮一峰的 http://es6.ruanyifeng.com/#docs/promise 入门教程，还有就是上面提到的电子书。\n## HTML 5 Web Workers\n\n什么是 Web Worker？\n当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。\nweb worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。\n\n创建 web worker 文件\n现在，让我们在一个外部 JavaScript 中创建我们的 web worker。\n在这里，我们创建了计数脚本。该脚本存储于 \"demo_workers.js\" 文件中：\n\n```javascript\nvar i=0;\n\nfunction timedCount()\n{\ni=i+1;\npostMessage(i);\nsetTimeout(\"timedCount()\",500);\n}\n\ntimedCount();\n```\n\n以上代码中重要的部分是 postMessage() 方法 - 它用于向 HTML 页面传回一段消息。\n注释：web worker 通常不用于如此简单的脚本，而是用于更耗费 CPU 资源的任务。\n创建 Web Worker 对象\n我们已经有了 web worker 文件，现在我们需要从 HTML 页面调用它。\n下面的代码检测是否存在 worker，如果不存在，- 它会创建一个新的 web worker 对象，然后运行 \"demo_workers.js\" 中的代码：\n```javascript\nif(typeof(w)==\"undefined\")\n  {\n  w=new Worker(\"demo_workers.js\");\n  }\n```\n然后我们就可以从 web worker 发生和接收消息了。\n向 web worker 添加一个 \"onmessage\" 事件监听器：\n```javascript\nw.onmessage=function(event){\ndocument.getElementById(\"result\").innerHTML=event.data;\n};\n\n```\n\n当 web worker 传递消息时，会执行事件监听器中的代码。event.data 中存有来自 event.data 的数据。\n终止 Web Worker\n当我们创建 web worker 对象后，它会继续监听消息（即使在外部脚本完成之后）直到其被终止为止。\n如需终止 web worker，并释放浏览器/计算机资源，请使用 terminate() 方法：\n\nw.terminate();\n\n完整的 Web Worker 实例代码\n我们已经看到了 .js 文件中的 Worker 代码。下面是 HTML 页面的代码：\n实例\n\n```javascript\n<!DOCTYPE html>\n<html>\n<body>\n\n<p>Count numbers: <output id=\"result\"></output></p>\n<button onclick=\"startWorker()\">Start Worker</button>\n<button onclick=\"stopWorker()\">Stop Worker</button>\n<br /><br />\n\n<script>\nvar w;\n\nfunction startWorker()\n{\nif(typeof(Worker)!==\"undefined\")\n{\n  if(typeof(w)==\"undefined\")\n    {\n    w=new Worker(\"demo_workers.js\");\n    }\n  w.onmessage = function (event) {\n    document.getElementById(\"result\").innerHTML=event.data;\n  };\n}\nelse\n{\ndocument.getElementById(\"result\").innerHTML=\"Sorry, your browser does not support Web Workers...\";\n}\n}\n\nfunction stopWorker()\n{\nw.terminate();\n}\n</script>\n\n</body>\n</html>\n```\n\n## 异步脚本加载\n\n一，阻塞性脚本\n\nJavaScript在浏览器中被解析和执行时具有阻塞的特性，也就是说，当JavaScript代码执行时，页面的解析、渲染以及其他资源的下载都要停下来等待脚本执行完毕\n浏览器是按照从上到下的顺序解析页面，因此正常情况下，JavaScript脚本的执行顺序也是从上到下的，即页面上先出现的代码或先被引入的代码总是被先执行，即使是允许并行下载JavaScript文件时也是如此。注意我们这里标红了\"正常情况下\"，原因是什么呢？我们知道，在HTML中加入JavaScript代码有多种方式，概括如下(不考虑require.js或sea.js等模块加载器)：\n（1）正常引入：即在页面中通过\\<script\\>标签引入脚本代码或者引入外部脚本\n（2）通过document.write方法向页面写入\\<script\\>标签或代码\n（3）通过动态脚本技术，即利用DOM接口创建\\<script\\>元素，并设置元素的src，然后再将元素添加进DOM中。\n（4）通过Ajax获取脚本内容，然后再创建\\<script\\>元素，并设置元素的text，再将元素添加进DOM中。\n（5）直接把JavaScript代码写在元素的事件处理程序中或直接作为URL的主体\n\n具体参考 http://www.jb51.net/article/77920.htm\n\n二，脚本延迟运行\n\n一般在JS页面延迟执行一些方法。可以使用以下的方法:\n```javascript\nWindow.setTimeout  \njQuery.delay\njQuery.queue和jQuery.dequeue\n\n<script src=\"deferdemo.js\" defer></script>加上 defer 等于在页面完全在入后再执行，相当于 window.onload ，但应用上比 window.onload 更灵活！\n\n<script type=\"text/javascript\" src=\"demo_async.js\" async=\"async\"></script>\n```\n\n使用async属性，浏览器会下载js文件，同时继续对后面的内容进行渲染\n通常如果js不需要改变DOM结构时可以使用async进行异步加载（比如一些统计代码可以异步加载，因为此代码与页面执行逻辑无关，不会改变DOM结构）\n\nSeaJS与RequireJS：\n网上写amd和cmd的文章很多，当然也有很多都是误人子弟的片面的看法，所以还是推荐自己看官方文档多加尝试去理解。\n\n“RequireJS 遵循的是 AMD（异步模块定义）规范，SeaJS 遵循的是 CMD （通用模块定义）规范”。\nAMD 是 RequireJS 在推广过程中对模块定义的规范化产出。\nCMD 是 SeaJS 在推广过程中对模块定义的规范化产出。\n\namd 规划 https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88)\n\ncmd 规范 https://github.com/seajs/seajs/issues/242\n\n区别：\n\n1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）\n\n2. CMD 推崇依赖就近，AMD 推崇依赖前置。\n\n## ECMAScript6 Moudle\n\n历史上，JavaScript一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如Ruby的require、Python的import，甚至就连CSS都有@import\n到了ES6，实现了模块化的功能，功能上基本可以取代 cmd和amd的规范，\n\n模块的功能主要由两个命令构成，export和import，export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。\n\nexport的写法，\n```javascript\n// profile.js\nvar firstName = 'Michael';\nvar lastName = 'Jackson';\nvar year = 1958;\n\nexport {firstName, lastName, year};\n上面代码在export命令后面，使用大括号指定所要输出的一组变量。\nimport写法：\n// main.js\n\nimport {firstName, lastName, year} from './profile';\n\nfunction setName(element) {\n  element.textContent = firstName + ' ' + lastName;\n}\n```\n\nES6模块加载的实质\nES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。\nES6模块的运行机制与CommonJS不一样，它遇到模块加载命令import时，不会去执行模块，而是只生成一个动态的只读引用。等到真的需要用到时，再到模块里面去取值，换句话说，ES6的输入有点像Unix系统的”符号连接“，原始值变了，import输入的值也会跟着变。因此，ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。\n```javascript\n// mod.js\nfunction C() {\n  this.sum = 0;\n  this.add = function () {\n    this.sum = 1;\n  };\n  this.show = function () {\n    console.log(this.sum);\n  }\n}\n\nexport let c = new C();\n上面的脚本mod.js，输出的是一个C的实例。不同的脚本加载这个模块，得到的都是同一个实例。\n\n// x.js\nimport {c} from './mod';\nc.add();\n\n// y.js\nimport {c} from './mod';\nc.show();\n\n// main.js\nimport './x';\nimport './y';\n```\n\n现在执行main.js，输出的是1。\n证明加载的是同一个实例\n参考 http://es6.ruanyifeng.com/#docs/module\n\n## 总结\n写这篇博客参考了很多网上的文章和一些书籍，因为太多就没有一一列举，这也算是我学习js异步知识的一个记录吧。\n毕竟马上就要去以一个前端工程师的身份去鹅厂实习了，所以还是要多学点东西，拿点干货出来。\n\nJS异步那些事 一 （基础知识） https://segmentfault.com/a/1190000005081689\n\nJS异步那些事 二 （分布式事件）https://segmentfault.com/a/1190000005081713\n\nJS异步那些事 三 （Promise）https://segmentfault.com/a/1190000005081754\n\nJS异步那些事 四（HTML 5 Web Workers） https://segmentfault.com/a/1190000005081783\n\nJS异步那些事 五 （异步脚本加载） https://segmentfault.com/a/1190000005081882\n\n[JS异步那些事 一 （基础知识）][1]\n[JS异步那些事 二 （分布式事件）][2]\n[JS异步那些事 三 （Promise）][3]\n[JS异步那些事 四（HTML 5 Web Workers）][4]\n[JS异步那些事 五 （异步脚本加载）][5]\n\n  [1]: https://segmentfault.com/a/1190000005081689\n  [2]: https://segmentfault.com/a/1190000005081713\n  [3]: https://segmentfault.com/a/1190000005081754\n  [4]: https://segmentfault.com/a/1190000005081783\n  [5]: https://segmentfault.com/a/1190000005081882\n\n  [JS异步那些事 一 （基础知识）][1]\n[JS异步那些事 二 （分布式事件）][2]\n[JS异步那些事 三 （Promise）][3]\n[JS异步那些事 四（HTML 5 Web Workers）][4]\n[JS异步那些事 五 （异步脚本加载）][5]\n\n  [1]: http://www.jianshu.com/p/6682c5e6289e\n  [2]: http://www.jianshu.com/p/95e1e198066f\n  [3]: http://www.jianshu.com/p/5c18b7823e1c\n  [4]: http://www.jianshu.com/p/64b586be696e\n  [5]: http://www.jianshu.com/p/826f3b4cedbd\n","tags":["JS异步编程"],"categories":["编程语言"]},{"title":"2016下半年规划","url":"%2F2016%2F08%2F01%2Fdaily_think%2F2016%E4%B8%8B%E5%8D%8A%E5%B9%B4%E8%A7%84%E5%88%92%2F","content":"\n\n### laynezhou 下半年 规划\n\n\n\n主要业务 (70%): \n\n\t1   投放端性能监控上报系统, 完善数据统计,配置管理,把代码做进一步的抽象,做好封装, 做出一个比较通用的上报管理及数据展示系统\n\n\t2   开发者平台的前端部分, 包括静态的页面和 wiki文档, 等等, 做好前期的技术调研, \t争取能独立承担起开发者平台的前端开发工作\n\n\t3   官网后期的静态化方案调研,并实现静态化方案部署\n\n<!-- more -->\n其他业务 (15%): \n\n\t1    部门 wiki 维护, 目前 mediawiki 功能还是有局限性, 调研完善\n\n\t2    在项目中实现 http2 的实际的部署和应用,同时也推动 https 部署,(落地到 上报系统或者开发者平台)\n\n\t3    了解投放端相关的开发工作, 完成部分投放端相关的需求\n\t  \n\n技术提升(15%)\n\n\t1  http2 技术的深入及其推广使用, 了解 es6, typescript 等语法,react, angular2,vue 框架等,结合其中某几项技术, 把http2实际应用演示站点搭建好\n\n\t2  代码规范 (在 php 的开发中引入自动化代码规范检测工具 )\n\n\t3  阅读: 细读至少 2本专业的技术书\n\n\t4  最少4次分享输出, 每次分享内容 发表 文章(大概每月一次)\n\n\t5  深入研究缓存体系, 写一个缓存系列的文章,预计分三大类共9篇\n\t","tags":["daily_think"],"categories":["实习总结"]},{"title":"array_push","url":"%2F2016%2F08%2F01%2Fdaily_think%2Fphp-array_push%2F","content":"\n## array_push\n\narray_push — 将一个或多个单元压入数组的末尾（入栈）\n\n说明 \nint array_push ( array &$array , mixed $var [, mixed $... ] )\n\narray_push() 将 array 当成一个栈，并将传入的变量压入 array 的末尾。array 的长度将根据入栈变量的数目增加。和如下效果相同：\n\n<?php\n$array[] = $var;\n?>\n并对每个 var 重复以上动作。","tags":["php"],"categories":["编程语言"]},{"title":"2016/8实习工作记录","url":"%2F2016%2F08%2F01%2Fdaily_think%2F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95201608%2F","content":"\n\n## 2016.07.25\n\n今日的任务\n1   编写投放端性能监控配置管理的页面的后台api接口(大概完成了30%的编写,预计天可以完成后台cgi的编写与自测)\n2   继续完善http2 的分享文档, 搭建http2性能演示网站\n\n总结\n\n今天终于从sublime编辑器转换到phpstorm IDE上面去编码了, 果然对于我这种编码经验不是很丰富的人来说, 一开始尝试使用一个合适编辑器会很大的调提高编码效率\n用欲善其事,必先利其器 这话还是有道理的\n<!-- more -->\n## 2016.08.01\n\n今日任务:\n\n    1    继续确定和对接实验系统的前端优化的方案\n    2    推进 投放端性能监控上报系统的测试与上线\n    3    感谢eshion和walker帮忙解决了数据库中文乱码的问题\n    4    熟悉实验系统的前端 代码框架, 分析需求需要改动的地方\n    5    配置好实验系统的开发环境\n    6    构思新的分页方案\n\n遇到的问题:\n    解决php后台的中文乱码的问题,这个问题其实以前做开发的时候也遇到过,不过由于建表sql语句的疏忽, 没有设置utf8的编码格式导致出现问题.这种问题以后不能再出现了\n\n关于实验系统前端页面优化的分页问题:\n\n背景:\n    由于实验系统的查询数据量是随着用户勾选的维度而变化的,所以可能会一下子返回量很大的数据, 但是前端页面插入dom元素肯定是有限制的, 不可能无限制的插入量很大的数据, 所以分页的问题是需要我们去解决的\n\n初期的方案:\n\n    第一次查询（前端点击『查询』按钮的时候）前端会请求两次cgi 一次请求全量 一次请求分页。 以后在翻页的时候，只请求分页,这是传统的分页方案\n\n遇到的问题:\n\n    实验系统的数据格式比较特殊, 需要每一天的数据不能被 分割, 所以我们在初期的方案加入改进: 具体的内容就是给用户一个 每页显示数量 的下拉选择框,当用户的数据被分割之后,用户可以勾选更大的每页显示条数 来把一整天的数据显示完整\n\n\n还有问题: \n\n    当用户更改了每页的显示条数的时候,一般的前端方案都是重新从第一页开始重新显示,但是我们这里的目的是 让用户可以查看一天完整的数据, 显然是不能从第一页重新开始显示的,一方面体验太差, 另外一方面你不能保证那一天的数据是否被分割了\n\n又是一个方案:\n\n     前端上传的分页参数为 index ,length两个参数, index 是查询结果的起始位置, length是 偏移量, 这样就不用从第一页开始重新显示了, 直接从用户浏览的那一页开始显示, 同时 由于选择了更大的 每页显示条数, 正常情况下可以把那一整天的数据显示完整\n\n问题:\n\n    看起来上面的方案是解决了 一天的数据被 分割的问题, 但是随后带来的是 此页面前面的数据分页被打乱的情况, 比如说 你当前的页面显示500~600的数据, 然后你改为每页显示150条, 即显示500~650的数据, ,那么,前面的500条数据就不好分页了,因为不是150的整数倍了\n\n暂时的处理:\n\n    为了解决上面的问题, 我先打算先做表头冻结的功能, 因为前期数据量不是特别大的情况下, 使用表头冻结是可以满足用户正常查看table的,分页的方案可以在后面的实验推进,不过需要更多的实验保证效率.\n\n这是我晚上构思的一种 分页方案:\n\n1    为了保证一天的数据不会被分割, 我们需要一个 table容器, 这个容器有一个最大的容量 ,比如最大的可以显示1000条数据\n\n2    从后台请求全量的数据, 前端去遍历 全量的数据, 比如每天的数据有300条,     不断的往第一个容器里面填充数据, 当填充到第四天的数据之后, 我们发现第四天数据被分割了,只能在第一个容器中插入100条数据,, 那么我们撤回第四天的数据 第一个容器就让它显示900条共三天的数据\n\n3   第四天的数据开始填充第 2 个table容器, 以此类推,在遍历的过程中我们也可以做一些表格数据的本地计算,比如计算每条数据的ctr Δctr    Δctr±α等等 (原本的数据就要计算这些,遍历数据是少不了的, 所以我们刚刚好可以利用这个遍历的过程,做好数据的分页)\n\n4    把全量数据全部遍历之后, 我们的本地分页也就做完了,然后就可以初始化分页的组件了, 由于数据全部缓存在内存中, 我们的分页不需要请求后台, 可以做到极快的响应 \n\n\n# 2016.08.10\n\nHI All\n今日开发任务\n1   根据eshion的cr评论,修改性能监控上报系统的的php代码规范\n2   修复 实验系统的table 数字过长溢出单元格\n3   切换 实验系统的新老 cgi接口 \n4   修复 实验系统 任何维度不选则查询失败的情况\n5   新增 实验系统读取 url , 自动勾选 查询维度的功能, 避免每次都要重新选择维度\n6   新增 打开性能监控上报展示首页, 自动选择第一个配置 的数据 进行展示\n\n今天时间有限, 早上和leonnliu 聊了在实习期间的一些收获和感触,  发觉在后面的时间里,不仅仅要做好需求, 同时也要去更多的了解 业务本身, 了解广告的一些概念, 帮助以后去更好的去沟通和理解需求\n\n在 下午的周会上面, kirk分享了rudex源码分享:\n以前听说过一直没有机会接触,今天可以趁着这个机会去了解以下的几个概念:\n\nActions、Reducers 和 Store:\n\naction 可以理解为应用向 store 传递的数据信息（一般为用户交互信息）。在实际应用中，传递的信息可以约定一个固定的数据格式，\n为了便于测试和易于扩展，Redux 引入了 Action Creator:\nfunction addTodo(text) {\n  return {\n    type: ADD_TODO,\n    text,\n  }\n}\n\nstore.dispatch(addTodo(text)):\ndispatch(action) 是一个同步的过程：执行 reducer 更新 state -> 调用 store 的监听处理函数。如果需要在 dispatch 时执行一些异步操作（fetch action data），可以通过引入 Middleware 解决。\n\nreducer :\nreducer 实际上就是一个函数：(previousState, action) => newState。用来执行根据指定 action 来更新 state 的逻辑。通过 combineReducers(reducers) 可以把多个 reducer 合并成一个 root reducer。\n\nreducer 不存储 state, reducer 函数逻辑中不应该直接改变 state 对象, 而是返回新的 state 对象（可以考虑使用 immutable-js）。\n\nstore 是一个单一对象：\n    管理应用的 state\n    通过 store.getState() 可以获取 state\n    通过 store.dispatch(action) 来触发 state 更新\n    通过 store.subscribe(listener) 来注册 state 变化监听器\n    通过 createStore(reducer, [initialState]) 创建\n    在 Redux 应用中，只允许有一个 store 对象，可以通过 combineReducers(reducers) 来实现对 state 管理的逻辑划分（多个 reducer）。\n\n关于 redux ,现在的理解还是概念性的, 具体的还是需要自己去写demo,多实践\n\n实习日报\n\n2016.08.12\n\n今日主要任务\n\n1  排查昨天晚上遇到的数据库读取错误的, 最后发现不是代码的问题,而是DI那边出现连接错误, 在排查问题的过程中,我也顺着 代码的路径一步步的找到tcp的连接源代码, 也清楚的理解了一个数据库的查询时经过哪些的流程的, 为以后排查错误累计经验\n\n2  根据cr评论 修改监控上报系统的 代码, 同时,修改后台的接口, 增加 从数据库拉取配置的开关, 这样前端或者上报cgi 可以自由选择 从何处拉取配置, 提高稳定性\n3  熟悉wp和官网的需求 \n4  发布测试的邮件,邀请组内的成员来体验测试 报表系统\n\n总结  :\n    发生昨晚的数据库连接错误的时候, 我一直怀疑是自己的代码问题, 后来花了好几个小时去排查问题, 最终发现是DI的问题, 在DI抛出 错误码时,php后台应该吧数据透传到前台来,,前台需要做响应的错误处理, 这是用户体验很重要的一个环节, 包括在开发的软件中, 需要模拟各种出错的问题或者是低网速的条件, 然后测试程序的稳定性和体验\n\n\n","tags":["daily_think"],"categories":["实习总结"]},{"title":"JS自执行函数","url":"%2F2016%2F07%2F01%2Fcoding%2Fself-executing%2F","content":"\n\n## js中的立即执行函数\n\n( function(){…} )()和( function (){…} () )是两种javascript立即执行函数的常见写法\n问题: 为什么会出现上面的两种不一样的写法,上面的写法难道不是简单的就是一个括号包裹匿名函数对象,再在后面加个括号调用函数，最后达到函数定义后立即执行的目的????然后并不是我想的那么简单\n\n\n<!-- more -->\n```javascript\n除了这种常用的方式:\n (function(){  //do something here; })();\n (function (){ //do something here;} () );\n\n还有一种方式为：\n!function(){  // do something  }();\n```\n在这里开头要加上 ！ 或者 ~ , - 和 +。（note：都是英文符号）\n为什么这里要这样子,为什么要在前面加上（）、！、+、-、=等运算符????\n\n因为 JavaScript 文法明确规定表达式语句不得以 function 或者 {  为开头（http://es5.github.io/#x12.4）\n\n```\nExpressionStatement → [lookahead ∉ {{, function}] Expression;\n```\n好的现在带来更多的困惑了......\n\n首先想要明白这个问题需要弄清函数表达式（function expression）和函数声明（function declaration）的区别：\n函数表达式：\n\n 函数表达式中的函数可以为匿名函数，也可以有函数名，但是该函数实际上不能直接使用，只能通过表达式左边的变量 a 来调用。\n\n```javascript\nvar a = function(){\nalert('Function expression');\n};\nvar b = new a();\n```\n\n函数声明：\n\n// 函数声明时必须有函数名\n\n```\nfunction a(){\nalert('Function declaration');\n}\na();\n```\n\n\n下面来看一下这段代码：\n```javascript\n~function() { \nconsole.log(\"hi\"); \n} (); \n\n```\n\n实际上可以分为两个部分（黑体部分和斜体部分）。黑体部分的匿名函数通过一元操作符变成了函数表达式，因而可以通过在表达式的后面使用 （） 来执行 。\n\n因此，执行匿名函数可以通过+，-，！，（） 这里的括号也是一种运算符,称为分组运算符\n这样的形式来转化为函数表达式，就可以通过表达式的后面使用 （） 来执行 。。\n```javascript\n( function() {}() );\n( function() {} )();\n[ function() {}() ];\n\n~ function() {}();\n! function() {}();\n+ function() {}();\n- function() {}();\n\ndelete function() {}();\ntypeof function() {}();\nvoid function() {}();\nnew function() {}();\nnew function() {};\n\nvar f = function() {}();\n\n1, function() {}();\n1 ^ function() {}();\n1 > function() {}();\n\n```\n\n下面看一个组错误的的现象:\n```javascript\nfunction (){console.log(\"hi\")}();\nVM354:1 Uncaught SyntaxError: Unexpected token )\n\nfunction g(){ console.log(\"hi\")}();\nVM519:1 Uncaught SyntaxError: Unexpected token )\n```\n\n(1) function (){ }()\n期望是立即调用一个匿名函数表达式，结果是进行了函数声明，函数声明必须要有标识符做为函数名称,而这里用()来做为标识符是非法的.\n\n(2) function g(){ }()\n期望是立即调用一个具名函数表达式，结果是声明了函数 g。末尾的括号作为分组运算符，必须要提供表达式做为参数。\n```javascript\nfunction g(){ console.log(\"hi\")}(1);\n>>1\n```\n\n所以那些匿名函数附近使用括号或一些一元运算符的惯用法，就是来引导解析器，指明运算符附近是一个表达式。\n\n\n\n匿名函数的好处在于：可以减少局部变量，以免污染现有的运行环境。jQuery等库都用到了这样的原理。\n另外：通过+，-！这三个符号运行的匿名函数比（）运行的匿名函数可以减少一个字符的使用,但是我们通常使用加(),因为其他的操作符可能会带来其他的影响\n\n更多，可以参考 [ECMA-262-3 in detail. Chapter 5. Functions.]\n\nhttp://dmitrysoshnikov.com/ecmascript/chapter-5-functions/#question-about-surrounding-parentheses\n","tags":["JS"],"categories":["编程语言"]},{"title":"2016/6实习工作记录","url":"%2F2016%2F06%2F01%2Fdaily_think%2F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F","content":"\n2016.06.28项目学习文档\n## require.js学习:\n1 .首先就是checkout 项目的trunk代码, 使用svn工具 将代码检出到文件夹中 (trunk是稳定的支持版本)\n2 .了解grunt构建工具\n3 .学习fet工具,学习require.js的模块化加载流程,具体的在项目中使用参考  C:\\Users\\laynezhou\\Desktop\\project\\trunk\\tools\\fet\\fetMain 下面的操作手册, entrance.js 是requireJs 入口的模块。一切的起源\n<!-- more -->\n2016.06.29学习文档\natlas项目流程学习:\n加载首页逻辑 idnex.js文件, 其中 在index文件中加载页面conmom组件heangularjs的bootstrap来启东angular\n具体的代码逻辑如下\n\t```\n\trequire([\n\t\t'jquery', \n\t\t'angular', \n\t\t'js/pages/common', \n\t\t'js/controller/index',\n\t\t'utils',\n\t\t'prefetchapi',\n\t\t'performanceapi'\n\t\t], \n\tfunction ($, angular, pageComm, indexController, util, prefetchapi, performanceapi) {\n\t\t'use strict';\n\t\tutil.stat.monitorPage.create('modIndex', [175,384,1]);\n\n\t\t$('#main').addClass(\"home\");\n\t\tpageComm.initPage({    //初始化页面的公共模块\n\t\t\tisIndex: true\n\t\t});\n\t\tangular.bootstrap(document, [indexController]);\n\n\t```\n问题: reportJsCache index的作用应该是报告 index的缓存情况,具体情况还需要进一步分析\n\n\ncommon 公共模块 首先引入一些页面的公共组件 比如jquery, route , message, accountlist.\n\n对于这里的require写法的:\n\n \t对于这里的写法he一般的require的写法有点不同, 一般引入多个组件会选择 \n \trequire(['jquery', 'angular', ], function ($, angular) {} 这种形式的方式,淡然这种方式的原理也应该都差不多的,在common中手动引入依赖的模块\n\n同时在initPage中执行各个初始化页面函数 比如\n\n\tinitPageHottag();\n\tinitPageActionHottag();\n\tinitMaterialHottag();\n\tinitShowMPQrcode();\n\tinitPageWrap();\n\t这里有个提示去开户的很频繁,,就是每次都有showAccountNoReadyTips()来提示去开户.\n\n最后common模块return的是initPage,logout: logout,sideslide, maskLayout,showAccountNoReadyTips等对象\n\n2016.06.30学习笔记\n\n react 组件前端编程\n\n\t webpack工具安装 与package.json项目配置\n\t npm install webpack--dev-server 服务器\n\t npm install react 安装\n\n主要开发教程:\n\n学习一个评论框的react开发 http://reactjs.cn/react/docs/tutorial.html 教程地址\n具体学习内容:\n 构造一个commentBox组件\n 然后分别构建一个 commentList和conmment\n 再构建 commentForm组件\n\ncommentBox组件包含 两个子组件, 同时将ajax拉取评论数据抽离出来,代码复用.\n其中有个setState的函数用于更新数据,\n实现本地先更新数据然后再从服务器拉取数据更新的方法\n\t handleCommentSubmit: function(comment) {\n\t    var comments = this.state.data;//获取原本数据评论数据列表数组\n\t    var newComments = comments.concat([comment]);拼接数组和新添加的评论\n\t    this.setState({data: newComments});更新数据状态为新的评论列表对象\n\t      $.ajax({//ajax 拉取新的评论列表\n\t      url: this.props.url,\n\t      dataType: 'json',\n\t      type: 'POST',\n\t      data: comment,\n\t      success: function(data) {\n\t        this.setState({data: data});\n\t      }.bind(this),\n\t      error: function(xhr, status, err) {\n\t        console.error(this.props.url, status, err.toString());\n\t      }.bind(this)\n\t    });\n\t  },\n\n\n##2016.06.30 上午11.25 学习数据报表系统的开发;晚上看房子\n##2016.07.1 今天配置了一天开发的环境, 并没有搞定,下午开会,了解同事们主要的最近的工作,晚上看房子去\n## 2016.07.2 周末, 加班\n\t来配置环境,出现环境的主要原因是找错了Apache的目录了,导致我的一直在错误的目录下面配置, 浪费了很多的时间 在对面的小哥的帮助下找到这个问题\n\t可以正常访问到目录文件之后, 潘合平因为缺少log文件夹导致php代码报错, 在eshioxiao的帮助小创建了log\n\n\n##2016.07.7\n今天是周四，atlas投放端性能监控上报系统已经开发了4天了，\n目前完成了初步的需求，实现了一个较完善的报表系统\n具体的工作内容：\n1 更改bootstrap代码将atlas投放端性能监控系统从hera项目中独立出来， 方便以后应用其他的ui组件并不影响原hera系统\n2 实现趋势图中用户可以同时显示两个曲线，提高图表利用率\n3 将无法使用趋势图展示的对象使用 列表以文本的显示显示出来\n待跟进的工作任务：\n1 增加一次ajax拉取的报表数据内容， 用户在选择其他的字段的内容不需要重复拉取\n2 重新研究php后台提供的配置文件，统一配置的格式方便前端展示（需要和eshionxiao和walkerwang讨论）\n3 减少页面的全局变量，优化组织代理架构\n遇到的问题：\n 在ajax拉取图表数据之后， 需要重复用到这个数据，但是不能每次都重新拉取，所以一开始把这个数据以window对象的形式存储为全局变量。但是考虑的到js开发的避免使用全局变量的原则，目前在参考组里成熟项目的项目代码组织方式，目前有两个解决方案\n 1 可以爱回调函数中写入代码\n 2 使用单全局变量的方式， 定义一个全局对象\n  需要更多的实验来证明那种方式比较适合本项目\n\n ##2016.07.08\n\n\n今天早上把atlas_V2的代码大致又看了一遍, 思考一下昨天遇到的数据共享的问题，\n有如下总结：\n\n\t1 atlas_v2项目还是使用了全局变量的, 不过使用的唯一的全局是window.GDT这个全局变量（walker说这是为了新老项目的迁移而保留的）\n\n\t2 项目中如何将ajax数据存储下来?这个问题也找到解决的方案, 大致是在angular使用 同一个$scope作用域来共享同一个json对象.\n\n\t3 atlas_v2将所有的ajax请求都抽象为service， 每次将业务处理代码以回调函数的形式来传入service，这样可以实现同一个service对象可以被多个controller访问。\n       （问题：angular中有自带的factory方法来定义service，而在atlas中并没有使用这个来定义service，而是直接使用require.js来导入services模块，这两者有什么区别？需要后续的实验探究）\n\n为了编写可维护的前端项目，尽量做到前后端分离，所以在参考e.qq.com项目的代码之后，决定重构报表系统。\n\n后期具体的开发任务：\n\n\t1 使用require.js重组代目结构，实现前端代码的模块化，减少代码耦合度\n\t2 使用angular组件来重新构建前面几天使用原生php开发的投放端性能监控报表系统\n\t3 规范旧项目中的命名规范，和注释规范\n\n今日进度：\n\n\t1 完成新版本代码架构设计\n\t2 学习angular在报表系统的功能实现\n\n三省吾身：\n\n\t1 在学校期间写的代码很随意，代码各种不规范，这些都是急需现在去纠正\n\t2 前端开发的基础比较薄弱，需要多累积代码经验并且要多学习优秀的项目代码\n\t3 要摆正心态，虚心多向同事们学习\n\n##2016.07.11\n周末主要继续完成上周五的定下的重构项目的任务(使用require.js重新组织前端代码),同时也在看书学习前端代码规范.\n今日主要的开发任务:\n1 选用table组件,经过筛选追踪选择了datatables这个前端table组件,主要的原因是:它的功能和目前项目的需求还是很契合的. 同时这是一个相对于比较流行的组件,同时中文社区也活跃,考虑到后期的维护性,使用该组件对项目的本身的代码不会造成很大的变动,就算更换另外一个组件可以通过一行代码来解决.同时我将table的配置写在一个单独的文件中,不影响项目本身的稳定性.\n2 关于前后台的json数据的安全性,在接受hera项目的过程中,原项目本身有些方法把一些数据库的字段也返回到前端去, 在没有破坏原本代码的前提下,我新增了几个方法,可以快速提供安全的xml配置数据输出到前端.\n3 cgi返回数据,在php端从hermers中查询时,在第一版本中我是直接查询结果返回到前台,然后前台解析数据并显示,但是这样的问题是把数据库的字段暴露给前台了,后来发现这个问题之后,在后台提前预处理了查询的数据,然后,返回安全的查询结果\n\n学习的感悟\n\n选用开源组件,要多方面的进行考虑,项目的社区活跃性,开源组件现阶段的稳定性等...另一方面是项目的源代码阅读,只有进行源代码的阅读之后才能更好的去使用开源组件.\n\ndatatable 开源组件资料:\n官网:\nhttps://www.datatables.net/\ngithub https://github.com/DataTables/DataTables\n完善的api文档,并且还有中文文档,\n中文网友很多实现的例子\n配套完善的拓展同时也提供众多css样式以供使用或者修改\n自带分页和搜索功能,减少开发量(参考很多其他的table组件仅仅提供样式,缺少其他的扩展支持)\n项目始于2011年,主要是基于jquery的一个table扩展,现在已经进入到相对于稳定的版本\n\n\n##2016.07.12\n\n\n\n投放端性能监测上报系统 目前进度\n\n\t1 继续完善性能监测系统,使用require.js重新组织项目代码架构\n\t2 引入tablesData组件,增加分页,排序,页面内搜索功能\n\t3 在php后台对输出数据结果进行预处理,避免将数据库字段暴露给前台\n\t4 php后台选择新输出可图表统计的字段数据\n\t5 实现查询分页功能,每次都查询全部如果返回的数据量太大容易页面卡死\n\n\n\n\n\n今日主要任务:\n\n实现php后端查询分页前端分页显示功能\n\n遇到的问题:\n\t在使用DataTable的过程中,由于dataTable本身的功能的限制,无法与后台配合使用ajax实现分页数据的更新\n\t如果使用DataTable默认的ajax交互功能，对传给后台和从后台获取的数据都有命名格式要求，这样一来耦合度较高，不利于后期扩展，不能直接适用于需要跟多种不同前端或其他业务交互的项目。\n\n解决的办法\n\t1 不利用dataTable内置的分页功能, 自己重新实现前端的分页功能.同时也带来了不足的地方,会产生大量的ajax请求,同时也会影响排序和搜索功能(下午在项目中已经实现这种方案,效果不理想)\n\n    2 重写DataTable中的ajax模块,大约 需要一天的工作量(考虑到table在报表系统中的重要性,决定明天实现该方案)\n\n思考:\n\t在使用开源的组件时,往往会因为开源组件本身的功能限制,无法与后台的传出的数据进行良好交互,这时候是去修改后台输出数据或者是去修改前端代码,这就是一个取舍问题了,在本项目中,直接修改后台的输出会很方便实现功能,但是考虑到拓展其他的功能,还是决定修改前端的代码.\n\n\t实现分页操作的过程中,将数据缓存出来,缓存在一个数组中,每次加载的时候先判断本地时候有缓存,然后再决定是否ajax拉取后端数据\n\t另外一个思路是: 每次直接将 table隐藏,然后使用js动态添加新的table,当用户点击已经加存在的table页时,直接显示该页面table.\n\n\n\n\n##2016.07.13\n\n学习的内容:\n\n \thermers的SQL交互说明, 在项目中多处需要查询hermers数据,所以在构造sql语句的时候要注意其规范\n \t在没有看这个文档前, 把sql查询中的取平均值操作写成avg(),而在hermers中是average().\n\n讨论:\n\n\t和Walkerwang和eshionxiao 讨论 上报配置的数据库设计, 需要建立两个表,具体的表的设计如下图\n                    \n\t初步的设计: 用户提交表单到php后台, 后台进行数据校验, 写入DB,(该操作需要需要接入敏感权限)\n\t将DB数据更新到XML配置文件, 解析配置文件返回到前台.\n\n开发任务:\n\n\t1 今日主要的重写dataTable组件的ajax部分,同时实现全局的排序(\t原本实现的本地页面局部的排序,和Walker讨论之后改为全局的排序), \n\n\t2 前端构造模糊搜索参数,传入后台拉取搜索结果,\n\n\t3 php后台开发 dataTable的服务端接口. \n\n\t以上三个功能的开发整体上大概进行到40%左右\n\n\t预期的实现效果: \t将dataTable的数据和php后台传出的数据对接起来,同时实现表头点击整体排序和模糊搜索功能\n\n代码评审记录:\n\n            1  对cgi返回的数据应该做一下数据完整性验证\n\n            2  self是javascript中的关键字，局部变量的命名应避免使用\n\n            3  输出比较多的重复结构时，可以考虑使用 document.createDocumentFragment 来提升性能 , (DocumentFragments 是一个DOM节点。它们不是DOM树的一部分。通常的使用场景是创建一个文档片段，然后将创建的DOM元素插入到文                 档片段中，最后把文档片段插入到DOM树中。在DOM树中，文档片段会被替换为它所有的子元素。因为文档片段存在与内存中，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面回流(reflow)(对元素位置和几何上的                     计算)。因此，使用文档片段document fragments 通常会起到优化性能的作用)\n\n\n4   Date的使用规范  https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date\n\n 总结:\n\t 1 在构思设计数据表的时候,因为对公司的CGI和数据库的交互不熟悉,导致把过程想的太简单,需要再研究一下php后台中一些DB的操作代码\n\n\t 2 一周前的今天,我把报表系统做了个大概出来, 但是那仅仅能看而已,远远达不到能用的,在这一周的时间,投放端性能监控系统在功能上还没有什么大的改进, 更多的是在做好功能细节.\n\t 就如walker中午给我提到的软件开发的就像冰山一样, 产品提出来的需求就是水上能看到那一角,但是我们需要花80%以上的时间去把水下的那一部分做好\n\nlaynezhou(周磊)\n\n\n\n##2016.07.14\n\n学习的内容:\n\t因为看到腾讯班车查询网页的底部菜单栏可以固定不动,以前一直想实现这个功能\n\t禁止浏览器拖动反弹（橡皮筋效果）具体的实现代码如下:\n\t$(document).ready(function(){  \n\t    function stopScrolling( touchEvent ) {   \n\t        touchEvent.preventDefault();   \n\t    }  \n\t    document.addEventListener( 'touchstart' , stopScrolling , false );  \n\t    document.addEventListener( 'touchmove' , stopScrolling , false );   \n\t  \n\t});  \n\t这是touch事件的相关文档  https://developer.mozilla.org/zh-CN/docs/Web/API/Touch_events#跟踪新的触摸行为\n\t由这个可以衍生出更多关于移动端touch事件的特性,同时在业余用较短的代码实现了一个简单的的 <canvas> 绘图程序\n\n开发内容:\n\n\t 1  完成初步的dataTable组件的ajax模块重写, 目前在独立的页面中实现,下一步是把这个模块嵌入到报表系统中\n\t 2  开发php端的 排序, 模糊搜索搜索,精准条件查询 等业务逻辑,并与datatable组件进行ajax数据交互\n\t 3  引入新的css样式,表格看起来更加美观,得益于重写dataTable的ajax模块,以后可以对表格进行更多的功能拓展\n \n遇到的问题:\n\n\t 在做模糊搜索的时候, 使用hermers的sql操作时发现 like 的功能实现不是很好,确切的来说并没有实现like本该有的功能,\n\t 比如要做一个多关键词搜索 一般是 where (fint1||fint2|| fint3) like '201607*',这样子搜索出不来结果 . hermers的 like 只能做到单字段的准确匹配\n\t 有可能是我sql语句写的有问题, 也有可能是hermers本身在实现sql查询和mysql有一些区别我没有发现,这个问题需要持续跟进一下\n\n总结:\n\t今天的开发还算顺利,中途也遇到一个小问题,就是我给json数据多套了一层[],导致前台一直解析不出来数据, 突然意识到代码接口的规范性是多么重要\n\t在一个项目中,每个函数的调用和返回, 每个模块的输出,每个请求的返回结构,都应该遵守一套相对稳定的规范.这样在开发的过程中可以减少很多不必要的错误和麻烦.\n\n##\n2016.07.15\nHi,all\n\n今日的开发任务:\n\n\t\t1 完善报表系统的功能,\n\t\t2 引入新的datePicker组件, 日期选择更加方便\n\t\t3 优化查询步骤, 去除顶部查询的按钮\n\t\t4 美化界面\n\n总结:\n\n\t今天在调试css的时候发现引入的组件样式太多, 存在样式被覆盖的问题,解决的办法就是剥离出我需要的样式即可,只是会比较费时间\n\t做软件不是简单的把功能做出来就可以了,要在实现功能的基础上把用户体验做好才是王道\n\n学习的内容:\n\t因为昨天在实习生群里讨论了一些关于file api的问题,所以特地重新去看一下关于file api的内容\n\t使用FileReader对象,web应用程序可以异步的读取存储在用户计算机上的文件(或者原始数据缓冲)内容,可以使用File对象或者Blob对象来指定所要处理的文件或数据.其中File对象可以是来自用户在一个<input>元素上选择文件后返回的FileList对象,也可以来自拖放操作生成的 \n\n\t想要创建一个FileReader对象,很简单,如下:\n\n\tvar reader = new FileReader();\n\t\n\tFileReader 有如下方法:\n\t\tvoid abort();\n\t\tvoid readAsArrayBuffer(in Blob blob);\n\t\tvoid readAsBinaryString(in Blob blob);\n\t\tvoid readAsDataURL(in Blob blob);\n\t\tvoid readAsText(in Blob blob, [optional] in DOMString encoding);\n\n\n\t\treadAsArrayBuffer()\n\n\t\t开始读取指定的Blob对象或File对象中的内容. 当读取操作完成时,readyState属性的值会成为DONE,如果设置了onloadend事件处理程序,则调用之.同时,result属性中将包含一个ArrayBuffer对象以表示所读取文件的内容.\n\n\n\t\treadAsBinaryString()\n\n\t\t开始读取指定的Blob对象或File对象中的内容. 当读取操作完成时,readyState属性的值会成为DONE,如果设置了onloadend事件处理程序,则调用之.同时,result属性中将包含所读取文件的原始二进制数据.\n\n\t\treadAsDataURL()\n\n\t\t开始读取指定的Blob对象或File对象中的内容. 当读取操作完成时,readyState属性的值会成为DONE,如果设置了onloadend事件处理程序,则调用之.同时,result属性中将包含一个data: URL格式的字符串以表示所读取文件的内容.\n\n\n\t\t这是一个实现上传文件并本地预览的例子\n\n\t\thttps://developer.mozilla.org/zh-CN/docs/Web/API/FileReader\n\n##2016.07.16\n\n\nprintf 函数的实现\n\nprintf函数格式化即先根据你的格式分配一定大小的内存空间,然后再把你的参数压栈顺序 具体实现也很简单\n比如：\nprintf(\"%d%f%c\",i,f,ch);\n参数压栈（从右到左），\n具体的代码实现\n\nhttp://blog.hostilefork.com/where-printf-rubber-meets-road/\n\nhttp://blog.csdn.net/cinmyheart/article/details/24582895 \n\nhttps://www.zhihu.com/question/28749911\n\nhttps://github.com/LastAvenger/OS67/blob/master/usr/uio.c#L49 \n uio 实现\n\n\n\n\n\n##2016.07.18\n\n开发任务\n\n\t1 设计好数据库建表的细节,在tapd提交建表的项目 子需求\n\t2 验证转义json数据中的html特殊字符,防止xss攻击\n\t3 添加 用户上报项管理页面, 具体的功能逻辑未完成\n\t4 添加加载中过度页面,优化加载体验(已完成)\n\n学习-关于http2.0与web性能优化\n1 http 为什么慢:\n\t影响一个网络请求的因素主要有两个，带宽和延迟。\n\t连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。\n\thead of line blocking会导致带宽无法被充分利用\n在http1.0时代的解决方案:\n针对 连接复用,http1.0协议头里可以设置Connection:Keep-Alive。\n\t\t1 基于tcp的长链接\n\t\t2 http long-polling\n\t\t3 http streaming\n\t\t4 web socket\n解决head of line blocking:\n\t使用http pipelineg ,浏览器几乎在同一时间把request发向了服务器。节约等待时间,极大的降低了整体的延迟(只适用于http1.1,存在很多的缺陷不被主流浏览器支持)\n\n来到http2.0时代\nhttp2.0对于web开发影响比较大的地方:\n\n1 新的二进制格式（Binary Format）\n\t\n\thttp1.x是明文协议，其格式由三部分组成：start line（request line或者status line），header，body  http2.0的协议解析决定采用二进制格式，http2.0的格式定义更接近tcp层的方式，这张二机制的方式十分高效且精简。length定义了整个frame的开始到结束，type定义frame的类型（一共10种），flags用bit位定义一些重要的参数，stream id用作流控制，剩下的payload就是request的正文了。看上去协议的格式和http1.x完全不同了，实际上http2.0并没有改变http1.x的语义，只是把原来http1.x的header和body部分用frame重新封装了一层而已。\n\n2 多路复用（MultiPlexing）\n\n\t上面协议解析中提到的stream id就是用作连接共享机制的。一个request对应一个stream并分配一个id，这样一个连接上可以有多个stream，每个stream的frame可以随机的混杂在一起，接收方可以根据stream id将frame再归属到各自不同的request里面。\n\n\thttp2.0里的每个stream都可以设置又优先级（Priority）和依赖（Dependency）。优先级高的stream会被server优先处理和返回给客户端，stream还可以依赖其它的sub streams。\n\n3 header压缩\n\thttp2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。\n\thttp的header现在膨胀到有可能会超过tcp有slow start的intial window的值了，所以更显得压缩header的重要性。\n\n4 Server Push\n\n\thttp2.0能通过push的方式将客户端需要的内容预先推送过去，所以也叫“cache push”。HTTP/2 的多路复用特性，使得可以在一个连接上同时打开多个流，双向传输数据。Server Push，意味着服务端可以在发送页面 HTML 时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。另外，服务端主动推送的资源不是被内联在页面里，它们有自己独立的 URL，可以被浏览器缓存，当然也可以给其他页面使用。\n\n\tHTTP/2 能解决的时间延迟：1）同域名并发连接数限制造成的阻塞时间；3）浏览器从 HTML 中找出外链资源这段时间；3）浏览器发起请求到服务端收到请求这段时间。\n##2016.07.19\n\n开发进度:\n1  投放端性能监控上报系统的数据基础展示功能目前已经大致完成 \n\thttp://snsad.isd.com/hera/index.php?mod=atlas&act=view\n\t需要配置host: 10.123.14.19 snsad.isd.com\n\n2  今天设计好上报项目配置管理界面结构,编写部分前端界面代码\n3  和eshionxiao讨论数据库建表的具体细节,同时写好项目的技术方文档\n\n学习的内容 :\n\n\njs代码中的curry化:\n\n在一些纯粹的函数式编程语言中，对函数的描述不是被调用（called或者invoked），而是被应用（applied）。在JavaScript中也有同样的东西——我们可以使用Function.prototype.apply()来应用一个函数\n\t在这段代码中，第一次调用add()时，在返回的内层函数那里创建了一个闭包。这个闭包将原来的x和y的值存储到了oldx和oldy中。当内层函数执行的时候，oldx会被使用。如果没有部分应用，即x和y都传了值，那么这个函数会简单地将他们相加。\n\nAPI模式，它们帮助我们为函数给出更干净的接口，包括：\n\n\t回调模式\n\n\t传入一个函数作为参数\n\t配置对象\n\n\t 帮助保持函数的参数数量可控\n\t返回函数\n\n\t 函数的返回值是另一个函数\n\n 总结:\n\t柯里化\n\t 新函数在已有函数的基础上再加上一部分参数构成\n\t初始化模式，这些模式帮助我们用一种干净的、结构化的方法来做一些初始化工作（在web页面和应用中非常常见），通过一些临时变量来保证不污染全局命名空间。这些模式包括：\n\t立即执行的函数\n\t 当它们被定义后立即执行\n\t立即初始化的对象\n\t 初始化工作被放入一个匿名对象，这个对象提供一个可以立即被执行的方法\n\t条件初始化\n\t 使分支代码只在初始化的时候执行一次，而不是在整个程序生命周期中反复执行\n\t性能模式，这些模式帮助提高代码的执行速度，包括：\n\tMemoization\n\t 利用函数的属性，使已经计算过的值不用再次计算\n\t自定义函数\n\t 重写自身的函数体，使第二次及后续的调用做更少的工作\n\n##2016.07.20\n\n开发任务:\n\n\t1 投放端性能监控上报系统的 配置管理页面大致定型, 同时在编写业务逻辑部分代码\n\t2 学习php后端与di数据写入和读取的代码结构和规范\n\t3 每周例会,今天satan做了https的资料汇总, 学习到很多, 业余要花时间好好研究一下,看能否在项目中应用到\n\n\n学习的任务\n今天在周会上面提到的https非对称加密, 很早之前就了解了,但是会后又去看了一下wiki百科: https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95  个人觉得在https和http2.0上面可以花一些时间去研究学习一下.\n\n\n#2016.07.21\n\n今天的开发任务\n\n\t1 完成配置报项目的前端页面,等待数据表的建立,编写php后台api接口拉取数据\n\t2 学习php后台框架的代码结构, 搞清楚一个请求是如何从index.php一直到返回response的过程\n\t3 学习建立数据表的命名规范和流程(感谢eshionxiao耐心的指导)\n\n学习:\n\n\t1 今天在看php后台的代码的时候,感触特别深, 深深的体会到公司代码的规范和完整性, 因为以前我也尝试做过数据库操作的封装, 对比一下公司的框架对数据增删查改的封装, 自己以前写的封装就是小儿科\n\n\t2 janzenzhang过来跟我讲了一下他以前写的fetmain工具的终端的原理,了解到node.js 中的child_process这个模块:\n\n\t\t\texec() 执行bash命令，它的参数是一个命令字符串\n\n\t\t\texecSync()  execSync是exec的同步执行版本,接受两个参数，第一个参数是所要执行的命令，第二个参数用来配置执行环境。\n\n\t\t\texecFile()  execFile方法直接执行特定的程序，参数作为数组传入，不会被bash解释\n\n\t\t\tspawn() spawn方法创建一个子进程来执行特定命令，用法与execFile方法类似，但是没有回调函数，只能通过监听事件，来获取运行结果。它\t\t属于异步执行，适用于子进程长时间运行的情况。\n\n\t\t\tfork()  fork方法直接创建一个子进程，执行Node脚本，fork('./child.js') 相当于 spawn('node', ['./child.js']) \t与spawn方法不同的是，fork会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。\n\n\t\t\tsend()  使用 child_process.fork() 生成新进程之后，就可以用 child.send(message, [sendHandle]) 向新进程发送消息。新进程中通过监听message事件，来获取消息。\n\n\tfetmain里面的终端的原理应该是通过child_process的 spawn方法来调用grunt或者一些其他的工具程序来实现的\n\t关于child_process  :  http://javascript.ruanyifeng.com/nodejs/child-process.html\n\n\t3 对php后台一个请求的过程描述: \n\n\n\n2016.07.22\n实习日报:\nHIall\n\n今日任务:\n\n\t 1 完善上报配置页面的搜索功能,\n\t 2 修改table的双击事件,变成双击弹出框展示点击的行详细内容\n\t 3 配置文件+IDE的方式来进行规范化。\n\n今天因为主要在调一些前面项目的细节同时格式化一些代码\n\n总结一下hera系统 数据库建表的需要注意的地方\n\t1 表的字段以F开头\n\t2 表的命名和字段的命名以驼峰式命名\n\t3 在涉及到多个表有相对应的字段可以考虑使用同样的字段名称\n\t4 设计表需要结合业务逻辑,数据库的设计原理等等多方面的因素考虑,应当慎重","tags":["daily_think"],"categories":["实习总结"]},{"title":"高性能网络浏览器-第四章传输层安全性","url":"%2F2016%2F04%2F01%2Fblog_tanslation%2F%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%B5%8F%E8%A7%88%E5%99%A8_TSL%2F","content":"\n原文: [高性能网络浏览器-第四章传输层安全性(Transport Layer Security,TLS) ](1] \n翻译: outshineamaze\n\n# 介绍:\nSSL协议在网景公司最初开发支持电子商务网络交易安全,需要加密 http 请求 来保护客户的个人资料,以及身份验证和完整性保证,以确保一个安全的交易。为了达到这个目标,SSL协议在应用程序层实现,直接上TCP(图4 - 1上面),使协议(HTTP、电子邮件、即时消息和许多其他人)在使用上不做改变,同时提供安全通信时的通信网络。\n\n正确使用SSL时,第三方观察者只能推断出连接端点类型的加密,以及频率和一个近似发送的数据量,但不能读取或修改任何实际的数据。\n\n<!-- more -->\n\n![图片描述](001.png)\n图4 - 1。传输层安全性(Transport Layer Security,TLS)\n\n\nSSL协议由IETF标准化时,它被命名为传输层安全性(TLS)。许多地方不太区分SSL和TLS名称,但从技术上讲,它们是不同的,因为每个描述了不同版本的协议。\n\nSSL协议的2.0是第一个公开发布的版本,由于发现安全漏洞,但它很快就被SSL 3.0取代了. 因为SSL协议是网景私有的,努力形成的IETF标准化协议,最终定稿为RFC 2246,这是1999年1月出版,被称为TLS 1.0。此后,IETF继续迭代协议来解决安全漏洞,以及扩大其功能:TLS 1.1(RFC 2246)发表在2006年4月,TLS 1.2(RFC 5246)2008年8月,现在正在开发中的版本,将定义为TLS 1.3。\n\n## 不要让大量的版本号误导你:\n服务器会更加倾向于选择最新稳定版本TLS协议,以确保最好的安全,功能和性能保证。事实上,一些性能关键型特性,比如HTTP / 2,明确需要使用TLS 1.2或更高版本,否则将终止连接。良好的安全性和性能齐头并进。\n\n#### notice\nTLS是被设计用于支持的可靠传输的协议(如TCP。然而,它也被适应碾如UDP数据报协议。数据报传输层安全(迪泰)),在RFC 6347中定义的是: 基于TLS协议能够提供类似的安全保障,同时保留数据报传递模型。\n\n# 加密、身份验证、完整性 (Encryption, Authentication, Integrity)\nTLS协议旨在提供三个基本服务上面运行的应用程序:加密、认证和数据完整性。从技术上讲,你不需要在所有的情况中全部使用上面三个特性。你可以决定接受证书没有验证其真实性,但是你应该清楚这样做的安全风险和影响。在实践中,一个安全的web应用程序将利用所有三个服务。\n\n加密\n主机发送数据到到另一个终端的一种混淆机制。\n\n身份验证\n提供一种机制来验证的有效性身份资料。\n\n完整性\n一种机制来检测消息篡改和伪造。\n\n为了建立一个密码安全的数据通道,peers 之间的连接必须同意使用密码套件和密钥用于加密数据。TLS协议定义了一个明确的握手顺序来执行这个交换,我们将详细检查TLS握手。TLS 设计巧妙并且可靠原因,是由于其使用公钥加密(也称为非对称密钥加密),它允许同伴协商共享密钥,而无需建立彼此的任何先验知识,并通过未加密的通道。\n\nTLS协议允许两个 peer 在握手的过程中验证对方的身份。当在浏览器中使用TSL 协议时,这种验证机制允许客户端验证服务器是谁(如。,你的银行),而不是一个虚假的名称或IP地址。这个验证是基于信任的建立的——看到的链的信任和证书颁发机构。此外,服务器还可以选择验证客户端的身份——如。公司代理服务器可以验证所有员工,每个人都可以有公司为自己签署唯一的的证书。\n\n\n最后,包含加密和认证的地方,TLS协议还提供自己的消息框架机制和信号每个消息与消息身份验证代码(MAC)。MAC算法是单向加密哈希函数(有效校验和),谈判的两个连接的关键。每当TLS发送记录,MAC值是生成和附加信息,然后接收者是能够计算和验证发送MAC值,以确保消息的完整性和真实性。\n\n所有三个机制结合在一起,作为网络安全通信的基础。所有现代web浏览器提供支持多种密码套件,可以对客户端和服务器进行身份验证,并透明地为每一个记录执行消息完整性检查。\n\n# 代理,中介机构,TLS,web 上的新协议\n\nHTTP的可扩展性和成功创造了一个充满活力的网上代理和中介机构:缓存服务器,安全网关,网络加速器,内容过滤器,和许多其它生态系统。在某些显式的代理,我们可以意识到它们的存在,最终对于用户是完全透明的。\n在实践中, 在80端口上常常会部署不可靠的服务,这些服务偏离的定义良好的HTTP / 1语义, 一些客户没有问题,一些客户的不可预知。相同的客户端在不同的网络环境中可能会看到不同的结果,\n\n由于这些行为,新协议和HTTP扩展,比如WebSocket,HTTP / 2等,必须依靠建立一个HTTPS隧道绕过中间代理, 加密隧道可以很好的保护数据通过中间机构。如果你曾经想知道为什么大多数WebSocket指南会告诉你使用HTTPS来传送数据到移动客户端,这就是为什么。\n\n# HTTPS无处不在\n未加密的HTTP和其他protocols-creates通信提供大量的隐私、安全性和完整性的漏洞。这样的连接很容易被拦截、操纵和模拟,并能暴露用户凭证,历史,身份,和其他敏感信息。HTTPS可以很好的为用户的隐私提供保护 。\n\n## HTTPS保护网站的完整性\n\n加密可以防止入侵者篡改data-e.g交换。重写内容、注入 广告的和恶意的内容等等。\n\n## HTTPS保护用户的隐私和安全\n加密可以防止入侵者监听传输的数据。每个未受保护的请求可以暴露用户的敏感信息,当这些数据包含很多的 session 信息,可以用来推测用户的身份和其他敏感信息。\n\n## HTTPS支持强大的功能\n越来越多的新的网络平台特性,如访问用户地理位置,拍照,录音录像,支持离线应用经验,,需要显式的用户选择,反过来,需要HTTPS。HTTPS提供的安全性和完整性保证至关重要的一部分在一个安全的用户权限工作环境中\n进一步指出,因特网工程任务组(IETF)和互联网架构委员会(IAB)发布了指导开发人员和强烈鼓励采用HTTPS协议设计师:\n\nIETF:无处不在的监控是攻击\n\n内勤局:互联网保密声明\n\n当我们依赖互联网的发展,所以对每个依赖它的人来说都有风险,它是我们的责任,作为应用程序开发人员和用户,以确保我们保护自己通过启用HTTPS无处不在。\n\n## Let’s Encrypt\n\n对广泛采用HTTPS常见的疑问和障碍的要求是 从一个可信证书颁发机构购买证书。\n\n“Let’s Encrypt是一个免费的、自动化的、开放的证书颁发机构为您的网络安全研究小组(ISRG)。让我们加密和ACME协议的目的是能够建立一个HTTPS服务器并让它自动获得browser-trusted证书,没有任何人工干预。”\n\n访问项目网站学习如何设置它在你自己的站点上。没有限制,现在任何人都可以获得一个受信任的证书的网站,免费的。\n\n# TLS握手\n\n之前,客户机和服务器可以交换应用程序数据/ TLS加密隧道必须协商:客户端和服务器必须同意TLS协议的版本,如果有必要选择密码套件,并验证证书。不幸的是,每一个步骤需要新的数据包往返(图4 - 2客户机和服务器之间的),这增加了启动延迟所有TLS连接。\n\n![图片描述](002.png)\n图4 - 2。TLS握手协议\n图4 - 2假设相同(乐观的情况)28日毫秒的“光纤”延迟纽约和伦敦之间的使用在以前的TCP连接建立的例子,看看表1 - 1.\n\n0 ms\nTLS运行在一个可靠的运输(TCP),这意味着我们必须首先完成TCP三方握手,这需要一个完整的往返。\n\n56 ms\n与TCP连接,客户端发送一个纯文本的规范,如TLS协议的版本运行,支持的密码套件列表和其他可能想使用TLS选项。\n\n84 ms\n服务器选择TLS协议版本进行进一步的沟通,决定从列表所提供的客户端密码套件,高度的证书,并将响应发送回客户端。可选地,服务器也可以发送一个请求客户机的证书和其他参数TLS扩展。\n\n112 ms\n假设双方可以协商一个共同的版本和密码,和客户满意提供的证书服务器,客户端发起RSA或diffie - hellman密钥交换,这是建立对称密钥用于随后的会话。\n\n140 ms\n服务器处理客户端发送的密钥交换参数,检查消息完整性通过验证MAC,并返回一个加密 Finished消息发送回客户端。\n\n168 ms\n客户端与谈判对称密钥解密消息,验证MAC,如果一切顺利,那么建立了隧道和应用程序数据现在可以发送。\n\n如上述所示,新的TLS连接需要两个往返的“握手”。然而,在实践中,优化部署可以做得更好并提供一个一致的1-RTT TLS握手:\n\nFalse Start 是TLS协议的扩展,它允许客户端和服务器上开始传输加密应用程序数据只是部分complete-i.e握手时。,一旦 ChangeCipherSpec和 Finished消息被发送,但没有等待另一侧做同样的事情。这种优化降低了新TLS握手开销连接一个往返,明白了支持TLS FALSE Start.\n\n如果客户曾与服务器通信,可以使用一个“缩写握手”,这就需要一个往返,还允许客户端和服务器CPU开销降低安全会话重用先前商定的参数;看到TLS会话恢复.\n\n上述优化的组合使我们能够为首次访问的和非首次访问的访客提供一个 1-RTT TLS握手,加上计算储存先前的会话,可以恢复协商会话参数。确保在部署中利用这些优化点。\n\nTLS 1.3的设计目标之一是减少建立安全连接的延迟开销:新会话1-RTT,和恢复会话0-RTT!\n\n# RSA、diffie - hellman和保密\n由于各种历史和商业原因RSA握手一直大多数TLS实现中占主导地位的密钥交换机制:客户端生成一个对称密钥,与服务器的公钥进行加密,并将它发送到服务器使用的对称密钥建立会话。反过来,服务器使用自己的私钥解密对称密钥和密钥交换完成发送。从这个角度提出了客户端和服务器使用对称密钥来加密会话协商。\n\nRSA的握手,但有一个重要缺点:使用相同的公私密钥对服务器进行身份验证和加密对称会话密钥发送到服务器。结果,如果一个攻击者可以访问服务器的私钥和并监听数据传输,他们可以就解密整个会话。更糟糕的是,即使攻击者目前没有访问私钥,他们仍然可以记录加密的会话,之后一旦在获得私钥就可以解密它。\n\n相比之下,diffie - hellman密钥交换允许客户端和服务器协商共享密钥没有明确沟通的握手:服务器的私钥用于签名和验证的握手,但对称密钥从未离开过客户机或服务器,攻击者无法拦截即使他们获得私钥。\n\n维基百科文章diffie - hellman密钥交换\n\n最重要的是,diffie - hellman密钥交换可以用来减少传递 session 的风险:我们可以为每个对话生成一个新的“短暂”对称密钥,每一个密钥交换后丢弃之前的钥匙。因为 暂时的 key 是从来没有沟通,新的会话会导致重新协商,最坏的情况是,攻击者可以破解的客户端或服务器,拿到的当前会话密钥和未来的会话密钥。然而,知道现在的私钥,不能帮助攻击者解密任何先前的会话!\n\n结合,使用diffie - hellman密钥交换和临时会话密钥使“完美向前保密”(PFS):长期密钥的妥协(如服务器的私钥)和过期的会话密钥 不允许攻击者解密以前记录的会话。一个高度可取的属性,至少可以这样说!\n\n结果,这个不应该感到惊讶,RSA握手在渐渐的被淘汰:所有流行的浏览器选跟先进的加密算法(即依靠diffie - hellman密钥交换),作为额外的奖励,可能使某些协议优化只有当保密是available-e.g向前发展。通过TLS的 False Start 实现1-RTT握手。\n\n\n## 公共与对称密钥加密的性能\n\n使用公开密匙加密只在初始设置的TLS隧道:证书认证和密钥交换算法执行。\n\n对称密钥加密,使用对称密钥是用于建立客户机和服务器之间的所有进一步沟通在会话。这样做,在很大程度上,提高performance-public密钥加密计算昂贵得多。为了说明不同,如果你有OpenSSL安装在您的计算机上,您可以运行下面的测试:\n\n$> openssl speed ecdh\n\n$> openssl speed aes\n\n注意,两次测试之间的单位不具有直接可比性:椭圆曲线diffie - hellman(ECDH)测试提供了一个汇总表的操作每秒对于不同大小的关键,同时AES性能以字节每秒。尽管如此,它应该很容易看到ECDH操作计算昂贵得多。\n\n使用的具体性能数据建立在不同硬件、核心数量,TLS版本,服务器配置,和其他因素。不要爱上一个过时的基准!总是在自己的硬件上运行性能测试和参考降低计算成本额外的上下文。\n\n## 应用程序层协议谈判(ALPN)\n两个peer 可能想要使用一个自定义协议相互通信。解决这个问题的一个方法是确定协议的前期,分配一个使用比较广泛的端口(如。HTTP 80端口, TLS端口443), 然后配置所有客户端和服务器使用它。然而,在实践中,这是一个缓慢而不切实际的过程:每个端口分配必须批准,更糟糕的是,防火墙和其他中介机构常常允许流量只在端口80和443。\n\n为了使自定义协议容易部署,我们必须复用端口80或443,使用一个额外的机制应用协议进行协商。端口80是用于HTTP,HTTP规范提供了一个特殊的 Upgrade流这一目的。然而,使用 Upgrade可以添加一个额外的网络往返延迟,在实践中往往是不可靠的许多中介机构,  代理,中介机构,TLS,新协议在网络上.\n## notice\nHTTP操作示例的升级流程,提前翻转升级到HTTP / 2.\n\n解决方法是使用端口443,它是用于安全的HTTPS会话运行/ TLS。使用端到端加密通道, 一种快速而可靠的方法来部署新应用程序协议。然而,我们还需要另一种机制谈判中的协议,它将使用于TLS会话。\n\n## 应用程序层协议谈判(ALPN)\n顾名思义,是一个TLS扩展。它扩展了TLS握手(图4 - 2),并允许在同行谈判协议没有额外的循环。具体来说,过程如下:\n\n客户端添加一个新的 ProtocolNameList领域,包含支持的应用程序协议列表,进入 ClientHello消息。\n\n服务器检查 ProtocolNameList场,并返回一个 ProtocolName字段显示选中的协议的一部分 ServerHello消息。\n\n服务器可能只有一个响应协议名称,如果它不支持任何客户机请求,那么可以选择终止连接。因此,一旦TLS握手完成后,建立安全的隧道,和客户端和服务器协议将使用哪些应用协议;客户端和服务器可以立即开始通过协商协议交换消息。\n\n## 历史和NPN型和ALPN的关系\n\n(NPN)是一个TLS扩展,谷歌开发它作为SPDY功能的一部分,使应用程序在TLS握手高效地协议谈判。听起来是不是很熟悉?最终的结果是功能上相当于ALPN。\n\nALPN修订和IETF批准版的NPN型扩展。广告在NPN型中,服务器所支持的协议,然后客户端选择和确认协议。在ALPN,这种交换是逆转:现在客户端指定它所支持的协议,然后,服务器选择并确认协议。变化的基本原理是,这让ALPN更为契合其他协议谈判的标准。\n\n简而言之,ALPN是NPN型的一个接班人。\n\n## 服务器名称指示(SNI)\n可以建立一个加密的TLS隧道之间的任何两个TCP同行:客户端只需要知道其他同行的IP地址进行连接和执行TLS握手。然而,如果服务器希望托管多个独立站点,每个都有自己的TLS证书,在相同的IP地址——这是如何工作的呢?技巧问题;它不。\n\n解决前面的问题,服务器名称指示(SNI)扩展了TLS协议,它允许客户端显示客户机试图连接到主机名的TLS握手。反过来,服务器可以检查SNI主机发送的 ClientHello信息,选择合适的证书,并完成所需主机的TLS握手。\n\n## TLS、HTTP和专用IPs\n\nTLS + SNI工作流是相同的 Host在HTTP头声明,客户端显示站点的主机名要求:一个IP地址可能会 host 过个域名,SNI和 Host他们之间需要消除歧义。\n\n不幸的是,一些老客户(如。,大多数IE版本上运行Windows XP,Android 2.2,和其他人)不支持SNI。因此,如果您需要提供TLS这样的客户,那么你可能需要一个专用的IP地址为每一个主机。\n\n# TLS会话恢复\n额外的延迟和成本计算完整的TLS握手一个严重的性能损失强加给所有的应用程序都需要安全通信。为了降低延时上的成本,TLS提供一个机制来共享多个连接之间相同的协商密钥数据。\n\n## 会话标识符\n第一个会话标识符(RFC 5246)恢复机制是在SSL 2.0中引入的,它允许服务器创建和发送32字节的会话标识符的一部分 在TLS协商之前发送ServerHello消息。与会话ID,客户机和服务器可以存储之前协商会话parameters-keyed会话ID和后续会话重用它们。\n\n具体来说,客户端可以包括的会话ID ClientHello消息告诉服务器它还记得密码套件和密钥协商从先前的握手和能够重用它们。反过来,如果服务器能够找到会话参数与广告相关的缓存ID,然后缩写握手(图4 - 3)可以发生。否则,就需要一个完整的新会话协商过程了,这将生成一个新的会话ID。\n![图片描述](003.png)\n图4 - 3。缩写TLS握手协议\n\n利用会话标识符允许我们减少一个完整的往返,以及公钥密码学的开销,用于协商共享密钥。这样子在建立一个安全快速的连接同时, 也不会损失的安全性,因为我们是重用以前协商会话数据。\n\n对于HTTP / 1会话恢复是一个重要的优化。HTTP / 2 x的应用可以消除了一个完整的往返延迟和显著减少计算双方的成本。\n\n事实上,如果浏览器需要多个连接相同的主机(例如当HTTP / 1.x是使用),它往往会故意等待第一个TLS协商完成之后才连接到同一台服务器上,这样他们可以“恢复”和重用相同的会话参数。如果你曾经看着网络跟踪,想知道为什么你很少看到同一主机TLS多个谈判并行,这就是为什么!\n\n然而实际的限制要求服务器会话标识符机制来创建和维护一个会话缓存为每一个客户。这导致服务器上的几个问题,这可能会每一天看到成千上万甚至上百万独特的连接:每打开TLS连接消耗内存,要求一个会话ID缓存和拆迁政策,对于拥有大量服务器的热门网站是一个重要挑战,在理想情况下,使用一个共享TLS会话缓存可以获得最佳性能。\n\n前面的问题都无法解决,但是许多高流量网站如今使用会话标识符依旧很成功。但对于任何多服务器部署、会话标识符需要仔细思考和系统架构,确保会话缓存的合理性。\n\n## Session Tickets\n为解决服务器端部署TLS会话缓存这个问题,“Session Ticket”(RFC 5077)替换机制被引入,服务器不需要保持每个客户机会话状态。相反,如果客户表示它支持Session Ticket,服务器可以包含一个 New Session Ticket记录,包括所有协商会话数据, 这些会话数据用一个只有服务器知道的密匙加密。\n\n这次会话Ticket然后会被存储在客户端,可以包含在 Session Ticket内的扩展 ClientHello消息的后续会话。因此,所有会话数据只存储在客户端,但Ticket仍然是安全的,因为它是用一个只有服务器知道的密钥加密。\n\n会话标识符和会话票机制通常分别称为会话缓存和无状态恢复机制。无状态恢复的主要改进是服务器端会话缓存,这简化了部署,每个新连接服务端要求客户端提供session ticket,直到ticket已经过期。\n\n在实践中,票在一组负载均衡服务器中部署session Tickets 也需要仔细思考和系统架构:所有服务器必须使用相同的初始化会话密钥,和一个额外的安全机制需要定期和旋转所有服务器的共享密钥。\n\n# 信任链和证书颁发机构\n身份验证是不可分割的一部分,建立每一个TLS连接。毕竟,可以进行一次谈话在一个与任何同行加密通道,包括攻击者,除非我们可以确定主人对我们信任,那么所有的加密工作可以。了解我们如何验证对等的身份,让我们看看一个简单的验证工作流之间的爱丽丝和鲍勃:\n\n爱丽丝和鲍勃生成自己的公钥和私钥。\n\n爱丽丝和鲍勃隐藏各自的私钥。\n\n爱丽丝和鲍勃,分享她的公钥和鲍勃分享了他与爱丽丝。\n\n爱丽丝为鲍勃和迹象表明,它生成一个新消息与她的私钥。\n\nBob使用爱丽丝的公钥验证提供消息签名。\n\n信任是一个关键组成部分前面的交换。具体来说,公钥加密允许我们使用发送方的公钥来验证消息正确的私钥签署,但决定批准发送方仍是建立在信任的基础之上的。在交换显示,Alice和Bob可以交换他们的公钥亲自会面时,因为他们彼此很了解,他们确信他们的交流不被黑客impostor-perhaps他们甚至通过另一个验证他们的身份,秘密(物理)握手他们早先建立了!\n\n接下来,爱丽丝收到消息从查理,她从来没有见过谁,而是谁声称是鲍勃的朋友。事实上,证明他的朋友鲍勃,查理问鲍勃签署自己与鲍勃的公钥私钥,并与他的消息(这个签名图4 - 4)。在这种情况下,爱丽丝首先检查鲍勃的签名的查理的关键。她知道鲍勃的公钥,因而能够确认鲍勃确实签查理的关键。因为她相信鲍勃决定验证查理,她接受消息和对查理的消��执行类似的完整性检查,以确保它是,事实上,从查理。\n\n![图片描述](004.png)\n图4 - 4。信任链的爱丽丝,鲍勃,和查理\n我们刚刚做的就是建立信任链:爱丽丝相信鲍勃,鲍勃信托查理,传递信任,爱丽丝决定相信查理。只要没有人链中的妥协,这让我们构建出一个信任方的列表。\n\n网络身份验证和在浏览器中遵循相同的过程如图所示。这意味着在这一点上你应该问:你的浏览器信任谁,你信任谁,是你本人在使用浏览器吗?至少有三种回答这个问题:\n\n手动指定证书\n所有浏览器和操作系统提供了一种机制让你手动导入任何你信任的证书。你如何获得证书并验证其完整性是完全取决于你。\n\n证书颁发机构\n一个证书颁发机构(CA)是一个受信任的第三方信任的证书的主体(所有者)。\n\n浏览器和操作系统\n每一个操作系统和大多数浏览器附带一个知名证书颁发机构列表。因此,您应该相信这个软件的供应商提供和维护的信任方列表。\n\n在实践中,手动的去储存每个网站证书是不切实际(尽管你可以)。因此,最常见的解决方案是使用证书颁发机构(ca)为我们做这个工作(图4 - 5):浏览器指定ca信任(根ca), 中科院的作用就是用来验证每个站点的sign,审计和验证这些证书不被误用或妥协。如果任何站点的安全与CA的证书被打破,那么它的责任,CA撤销妥协证书。\n![图片描述](005.png)\n图4 - 5。CA签名的数字证书\n每个浏览器都允许你检查的信任链安全连接(图4 - 6),通常可以通过单击锁定图标旁边的URL。\n![图片描述](006.png)\n图4 - 6。信任的证书链为igvita.com(Google Chrome,25节)\nigvita.com证书签署StartCom类1主要中间服务器。\n\nStartCom类1主要中间服务器证书签署的StartCom认证权威。\n\nStartCom认证中心是公认的根证书颁发机构。\n\n整个链的“信任锚”是根证书权威,这只是显示,StartCom认证权威。所有浏览器附带一个预表受信任的证书颁发机构(“根”),在这种情况下,浏览器信托和能够验证StartCom根证书。因此,通过传递信任链的浏览器,浏览器厂商和StartCom证书颁发机构,我们扩展信任我们的目的地网站。\n\n## 证书的透明度\n\n每一个操作系统供应商和每一个浏览器提供一个他们信任并且公开上市的默认证书颁发机构。可以搜索引擎来查找和调查这些列表。在实践中,你会发现大多数系统依赖数以百计的受信任的证书颁发机构,这也是一个对系统常见的抱怨:大量的受信任的ca在您的浏览器中创建一个大型攻击表面积的信任链。\n\n好消息是,证书的透明度项目正在努力解决这些缺陷通过提供一个框架公开日志监控和审核发行的新证书。访问项目网站,了解更多信息。\n\n## 证书撤销\n偶尔的发行者证书需要撤销或无效证书由于许多可能的原因:证书的私钥被入侵,证书颁发机构本身已经遭到破坏,或由于各种良性原因取代证书等的变化关系,等等。为了解决这个问题,自己的证书包含指令(图4 - 7)如何检查是否已被撤消。因此,为了确保信任链不是妥协,每个同行都可以检查每个证书的状态根据嵌入式的指导,以及签名,验证证书链。\n\n![图片描述](007.png)\n图4 - 7。CRL和OCSP指令为igvita.com(Google Chrome,25节)\n## 证书撤销列表(CRL)\n证书撤销列表(CRL)由RFC 5280定义和指定了一个简单的机制来检查每一个证书的状态:每个证书颁发机构维护和定期发布撤销证书编号的列表。任何一个试图验证证书的人就能下载撤销列表,缓存,并检查特定序列号的存在,如果它存在,那么它被撤销。\n\n这个过程简单明了,但有很多限制:\n\n越来越多的撤销签证意味着CRL列表只会变得更长,和每个客户端必须获取序列号的完整列表。\n\n没有即时通知证书机制revocation-if CRL证书被撤销前由客户端缓存,然后CRL认为撤销证书有效,直到缓存到期。\n\n需要获取最新的CRL, CA可能会阻止证书验证列表,这将显著延长TLS握手时间。\n\nCRL获取可能会失败,由于各种原因,在这种情况下,浏览器的行为是未定义的。大多数浏览器把这种情况下定义为“软失败”,允许验证proceed-yes。\n\n## 在线证书状态协议(OCSP)\n解决一些CRL机制的局限性,介绍了在线证书状态协议(OCSP)由RFC 2560,这提供了一种机制来执行一个实时检查证书的状态。不像CRL文件,其中包含所有的撤销序列号,OCSP允许客户端直接查询CA的证书数据库序列号的问题,同时验证证书链。\n\n因此,消耗更少的带宽和OCSP机制能够提供实时验证。然而,要求执行实时OCSP查询创建自己的一组问题:\n\nCA必须能够处理负载的实时查询。\n\nCA必须确保服务和全局可用。\n\n实时OCSP请求可能损害客户的隐私因为CA知道哪些网站客户端访问。\n\n客户端必须阻止OCSP请求而验证证书链。\n\n浏览器行为,再一次,未定义,通常导致“软失败”如果OCSP获取失败由于网络超时或其他错误。\n\n作为一个现实世界的数据点,Firefox遥测表明OCSP请求时间高达15%的时间,并添加TLS握手当successful-see大约350毫秒hpbn.co / ocsp-performance.\n\n## OCSP装订\n上面列出的原因,无论是CRL或OSCP撤销机制提供了安全性和性能保证我们渴望我们的应用程序。但是,不要绝望,因为OCSP装订(RFC 6066,“证书状态请求”扩展)解决了大部分的问题我们之前看到通过允许执行验证的服务器和发送(“钉”)的TLS握手到客户端:\n\n而不是客户OCSP请求,服务器,定期检索签署和时间戳OCSP CA的响应。\n\n然后,服务器(即附加内容。“主食”)签署了OCSP响应作为TLS握手的一部分,允许客户端验证证书和附加OCSP撤销CA签署的记录。\n\n这角色转换是安全的,因为ping CA签署的记录,可以由客户端验证,并提供一些重要的好处:\n\n客户不会流失,其导航历史。\n\n客户端没有阻止和查询OCSP服务器。\n\n客户端可能“hard-fail”撤销处理如果服务器选择加入(通过广告OSCP Must-Staple国旗)和验证失败。\n\n简而言之,两个最好的安全性和性能保证,确保在您的服务器上配置和测试OCSP装订。\n\n# TLS协议记录\n不同的IP或TCP层下面,TLS会话中的所有数据交换框架使用一个定义良好的协议(图4 - 8)。TLS协议记录负责识别不同类型的消息(握手、警告或数据通过“内容类型”字段),以及保护和验证每个消息的完整性。\n\n![图片描述](008.png)\n图4 - 8。TLS记录结构\n交付应用程序的典型工作流数据如下:\n\n记录协议接收应用程序数据。\n\n接收的数据分为块:最多214字节,或16 KB /记录。\n\n消息验证码(MAC)或HMAC被添加到每个记录。\n\n数据在每个记录是使用协商加密密码。\n\n一旦完成了这些步骤,加密的数据传递到TCP层的传输。在接收端,相同的工作流程,但是反过来说,由同行应用:解密使用密码谈判记录,核实MAC,提取和交付应用程序上面的数据。\n\n好消息是,所有的工作就显示由TLS层本身,对于大多数应用程序是完全透明的。然而,记录协议并介绍几个重要的意义,我们需要注意的:\n\n最大TLS记录大小是16 KB\n\n每条记录包含一个5字节的头,一个MAC(SSLv3 20字节,TLS 1.0,TLS 1.1,TLS 1.2)和32字节,如果使用分组密码和填充。\n\n解密和验证记录,整个记录必须是可用的。\n\n为应用程序选择正确的记录大小,如果你有这样做的能力,可以是一个重要的优化。小记录招致更大的CPU和开销字节由于框架和MAC验证记录,而大的记录必须交付和重组的TCP层之前,他们可以处理的TLS层和提前送到你application-skip优化TLS记录大小全部细节。\n\n# 优化TLS\n部署您的应用程序在TLS需要一些额外的工作,在您的应用程序(如资源迁移到HTTPS以避免混合内容),以及基础设施的配置负责交付应用程序数据在TLS。调整部署可以使一个巨大的不同凡响的观测性能,用户体验,和整体运营成本。就让我们一探究竟吧。\n\n## 降低计算成本\n建立和维护一个加密的通道同行介绍了附加的计算成本。具体来说,首先是不对称的(公钥)加密中使用TLS握手(解释道TLS握手)。然后,一旦建立共享密钥,它被用作一个对称密钥加密所有TLS记录。\n\n正如我们前面提到的,公钥密码术更计算昂贵的相比,对称密钥加密,并在早期的Web通常需要额外的硬件来执行“SSL卸载。“好消息是,这不再是必要的,一旦需要专用硬件在CPU上直接就可以完成。大型组织如Facebook、Twitter和谷歌提供TLS数十亿的用户,在计算软件和硬件执行所有必要的TLS协商。\n\n2010年1月,Gmail将默认为所有使用HTTPS。之前它被引入作为一个选项,但现在我们所有的用户使用HTTPS来保护他们的浏览器和谷歌之间他们的电子邮件,所有的时间。为了做到这一点我们还没有部署额外的机器,没有特殊硬件。在我们的前端生产环境服务器机,SSL / TLS占不到1%的CPU负载、每个连接不到10 KB的内存和不到2%的网络开销。许多人认为,SSL / TLS需要大量的CPU时间,我们希望前面的数字(公共)可以帮助大家打消那个误解。\n\n如果你现在停止阅读你只需要记住一件事:SSL / TLS不再计算昂贵了。\n\n亚当·兰利(谷歌)\n我们在大规模部署TLS使用硬件和软件负载平衡器。我们发现,现代的基于软件的TLS实现产品, 高速cpu来处理大量HTTPS流量负载,而不需要采取专门的加密硬件。我们的服务所有的HTTPS都使用软件来运行.\n\nDoug海狸(Facebook)\n椭圆曲线diffie - hellman(ECDHE)仅仅是一个更昂贵的比RSA同等安全级别…在实际部署中,我们发现,启用和优先ECDHE密码套件是微不足道的CPU使用量的增加引起的。HTTP keepalives和会话恢复意味着大多数请求不需要一个完整的握手,握手操作并不占用我们的CPU使用率。我们发现75%的Twitter客户端使用ECDHE在连接建立请求被发送。剩下的25%主要由老客户还不支持ECDHE密码套件。\n\n雅各Hoffman-Andrews(Twitter)\n在自己的部署过程中得到最好的结果,启动最好的TLS会话恢复,优化其成功率。消除每一个握手需要执行昂贵的公钥密码学操作将明显降低计算成本,同时减少TLS延迟;没有理由把CPU周期浪费在本不需要做的事情上面。\n\n谈到优化CPU周期,请一定要保持你的服务器更新与TLS库的最新版本!除了安全改进,你也会经常看到性能优势。安全性和性能是密不可分的。\n\n## 启用 1-RTT TLS握手\n一个未优化的TLS部署可以轻松添加许多额外的往返和介绍user-e.g明显延迟。multi-RTT握手,缓慢而无效的证书撤销支票、大TLS记录,需要多次往返的\n\n调优的TLS部署应该最多添加一个额外的往返谈判TLS连接,不管它是新的或恢复,并避免其他延迟陷阱:配置会话恢复,并使向前保密支持TLS FALSE Start。\n\n要获得最佳的端到端性能,确保审计自己的和第三方服务和服务器所使用的应用程序,包括你的CDN提供商。快速,与流行的服务器和发布商的概述,请查看istlsfastyet.com.\n\n## 优化连接重用\n最好的方法减少计算开销和延迟设置新的TCP + TLS连接优化连接重用。这样平摊到了设置成本在请求和向用户提供更快的体验。\n\n验证您的服务器和代理配置设置允许keepalive连接,和审计连接超时设置。许多流行的服务器组积极的连接超时(例如Apache版本默认为5 s超时),迫使很多不必要的协议。为达到最佳效果,使用你的日志和分析来确定最优超时值。\n\n## 利用提前终止\n正如我们讨论的Primer on Latency and Bandwidth,我们可能无法使我们的包跑得更快,但我们可以让他们更短的距离。通过将我们的“边缘”服务器接近用户(图4 - 9日),我们可以显著减少往返时间和TCP和TLS握手的总成本。\n\n![图片描述](009.png)\n图4 - 9日。客户端连接的早期终止\n一个简单的方法来做到这一点是利用内容分发网络(CDN)的服务,维护全球的边缘服务器池,或者自己部署。通过允许用户终止与附近的服务器,而不是穿越在海洋和大陆链接你的来源,客户得到的好处与短循环“提前终止”。这种技术同样是有用的和重要的静态和动态内容:静态内容也可以由边缘服务器缓存,而动态请求可以在建立路由连接从边缘到原点。\n\n## CDN获取资源\n\n使用CDN技术或代理服务器来获取资源,这可能需要每个用户定制的或包含其它私人数据,因此不是一个全球缓存资源的优势,通常被称为一个“未取回起源。”\n\n而cdn效果最好,当数据被缓存在geo-distributed服务器在全世界范围内,仍未起源获取提供了一个非常重要的优化:客户端连接终止与附近的服务器,这可以大大减少握手延迟成本。反过来,CDN,或者自己的代理服务器,可以维持一个“温暖的连接池”起源服务器传递数据,允许您返回一个快速响应返回到客户机。\n\n事实上,作为一个额外的一层优化,附近一些CDN提供商使用服务器连接两岸的!客户端连接终止在附近的一个CDN节点,然后将请求到CDN节点接近原点,然后请求被路由到原点。跳在CDN网络允许流量路由优化CDN骨干,这有助于进一步减少客户端和起源服务器之间的延迟。\n\n## 配置会话缓存和无状态恢复\n终止接近用户的连接是一种优化,有助于降低延迟为用户在所有情况下,但再一次,没有一点比一点快sent-send更少的比特。支持TLS会话缓存和无状态恢复允许我们消除整个往返重复访客的延迟和减少计算开销。\n\n会话标识符,TLS会话缓存依赖,介绍了SSL宽2.0,大多数客户端和服务器的支持。然而,如果你是在您的服务器上配置TLS,不要认为会话将在默认情况下支持。事实上,它是更常见的在大多数服务器的默认设置你知道更好!仔细检查并验证您的服务器、代理和CDN配置:\n\n服务器有多个进程或员工应该使用一个共享会话缓存。\n\n共享会话缓存的大小应该调整你的交通水平。\n\n应提供会话超时时间。\n\n在一个多服务器的设置中,客户端IP路由一样,或TLS会话ID相同,相同的服务器是一种提供良好的会话缓存利用率。\n\n“粘性”负载平衡在哪里并不是一个选择,应该使用一个共享缓存不同服务器之间提供良好的会话缓存利用率,并建立安全机制需要分享和更新提供会话密钥来解密票。\n\n检查和监控你的TLS会话缓存统计数据最佳性能。\n\n在实践中,为达到最佳效果,你应配置两个会话缓存机制和会话ticket。这些机制共同努力,为新老客户提供最好的报道。\n\n## 支持TLS False Start\n会话恢复提供了两个重要的好处:它消除了额外的握手往返返回游客和降低计算成本的握手,允许重用之前协商会话参数。然而,它在第一次与服务器通信,或者前一交易日已经过期是无效的。\n\n得到最好的两个全世界一个往返握手为新和重复访客,和计算节省重复visitors-we可以使用TLS FALSE Start,这是一个可选的扩展协议,允许发送方发送应用程序数据(图4到10)握手时只有部分完成。\n\n\n\n![图片描述](010.png)\n图4到10。TLS握手与错误的开始\n FALSE Start不修改TLS握手协议,相反,它只会影响协议的时机当应用程序可以发送数据。直观地说,一旦客户端发送 ClientKeyExchange记录,它已经知道加密密钥,就可以开始发送应用程序数据,剩下的握手是花握手确认没有人篡改记录,并且可以并行完成的。因此,错误的开始让我们保持TLS握手一次往返不管我们是否执行一个完整的或缩写握手。\n\n## 部署TLS False Start\n\n因为错误的开始只是握手协议的修改时间,它不需要任何更新TLS协议本身和可以unilaterally-i.e实现。,客户端可以开始传输加密的应用程序数据。理论上是这样的。\n\n在实践中,尽管TLS False Start应该向后兼容所有现有的TLS客户机和服务器,使其默认为所有TLS连接问题被证明是由于一些糟糕的服务器实现。因此,所有现代浏览器都能够使用TLS FALSE Start,但某些条件得到满足时才会这么做的服务器:\n\nChrome和Firefox需要ALPN协议声明出现在服务器的握手,和选择的密码套件服务器使保密。\n\nSafari要求密码组合要求服务器支持向前保密。\n\nInternet Explorer使用黑名单的网站的结合,打破启用TLS False Start 时,和一个超时重复握手如果TLS FALSE Start握手失败了。\n\n所有浏览器支持TLS FALSE Start服务器应该做广告支持的协议的列表通过ALPN extension-e.g。“h2,http / 1.1”——被配置为支持和更喜欢密码套件,使保密。\n\n## 优化TLS记录大小\n所有应用程序数据通过TLS内运输记录协议(图4 - 8)。每个记录是16 KB的最大大小,取决于所选的密码,每个记录将增加20到40字节的头开销,MAC和可选的填充。如果记录符合一个TCP数据包,然后我们还必须添加TCP / IP开销:IP 20-byte头,20-byte头不为TCP选项。因此,有可能为每一个记录60到100字节的开销。对于一个典型的最大传输单元(MTU)线大小为1500字节,这包结构转化为最小帧开销的6%。\n\n记录越小,帧开销越高。然而,仅仅增加记录其最大尺寸的大小(16 KB)并不一定是一个好主意。如果记录多个TCP数据包,那么TLS层必须等待所有TCP数据包到达才能解密数据(图4 -)。如果这些TCP数据包迷路了,重新排序,或限制由于拥塞控制,然后TLS的各个片段记录必须缓冲之前可以解码,导致额外的延迟。在实践中,这些延迟可以为浏览器创建的重要瓶颈,更愿意消费数据以流的方式。\n![图片描述](011.png)\n图4。WireShark捕获的11211字节的TLS记录分歧8 TCP段\n小记录产生开销,大型记录产生延迟,没有一个“最优”记录的值大小。相反,为web应用程序,使用浏览器,最好的策略是动态调整记录大小基于TCP连接的状态:\n\n当连接是新的和TCP拥塞窗口较低,或当连接闲置一段时间(见缓慢的开始重启),每个TCP包应该携带一个TLS记录,和TLS记录应该占领整个最大段大小由TCP(MSS)分配。\n\n当连接拥塞窗口很大,如果我们将一个大型流(如。流媒体视频),TLS记录的大小可以增加跨多个TCP数据包(16 kb)减少框架和客户端和服务器上的CPU开销。\n\n如果TCP连接一直闲置,即使慢启动重启服务器上禁用,最好的策略是减少数据的记录大小在发送一个新的破裂:条件可能改变了自去年传播,我们的目标是最小化的概率缓冲在应用程序层由于丢包,重新排序,重发。\n\n使用一个动态交互式交通战略提供最佳性能:小记录大小可以消除不必要的缓冲延迟和提高time-to-first - { HTML字节,…,视频帧},和一个更大的记录大小优化吞吐量为长寿流TLS的开销最小化。\n\n确定最优记录大小为每个状态让我们从最初的开始一个新的或闲置的TCP连接,我们希望避免TLS记录跨越多个TCP数据包:\n\nIPv4分配20字节帧开销和40个字节为IPv6。\n\n为TCP框架的开销分配20字节。\n\n分配40字节TCP选项开销(时间戳,袋)。\n\n假设一个常见的1500字节的MTU开始,这使得1420字节的TLS记录交付在IPv4,并为IPv6 1400字节。不会过时的技术,使用IPv6大小,留下1400字节为每个TLS记录,并根据需要调整如果你的MTU低。\n\n接下来,决定当记录大小应该增加和复位如果连接一直闲置,可以设置基于预配置的阈值:记录大小增加到16 KB XKB的数据传输,重置后记录大小 Y空闲时间的毫秒。\n\n通常情况下,配置TLS记录大小不是我们可以控制在应用程序层。相反,通常这是一个设置,有时TLS服务器的编译时常量。检查您的服务器的文档有关如何配置这些值。\n\n# TLS在谷歌优化\n\n2014年初,谷歌的服务器使用小TLS记录,符合一个TCP段第一1 MB的数据,记录大小增加到16 KB之后优化吞吐量,然后重置记录大小回到一段inactivity-lather一秒钟之后,冲洗,重复。\n\n同样,如果您的服务器处理大量的TLS连接,然后最小化优化内存使用每个连接可以是至关重要的。默认情况下,OpenSSL等流行的库将50 KB的内存分配每个连接,但与记录大小,它可能值得检查文件或源代码如何调整这个值。谷歌服务器减少OpenSSL缓冲区下降到5 KB。\n\n## 优化证书链\n验证信任链遍历链要求浏览器,从网站的证书,并递归地验证证书的父母,直到达到一个可信的根。因此,它是至关重要的,提供链包括所有中级证书。如果有遗漏,浏览器将被迫暂停验证过程和获取丢失的证书,添加额外的DNS查找,TCP握手和HTTP请求到流程中。\n\n浏览器如何知道从哪里获取丢失的证书吗?每个孩子父母证书通常包含一个URL。如果省略的URL和所需的证书是不包括的,然后验证将会失败。\n\n相反,不包括不必要的证书,如受信任的根证书中那些添加不必要的字节。回想一下,发送服务器证书链的TLS握手,这是可能发生在一个新的TCP连接,在早期阶段的慢启动算法。如果证书链的大小超过最初TCP的拥塞窗口,然后我们将无意中添加额外的次往返TLS握手:证书长度将溢出拥塞窗口,导致服务器停止,等待客户ACK之前。\n\n在实践中,证书链的大小和深度是一个更大的担忧和问题在旧TCP堆栈初始化其初始4 TCP segments-see拥塞窗口慢启动。对于更新的部署,最初的TCP拥塞窗口已经提高到10段,应该足够大多数证书链。\n\n也就是说,验证您的服务器使用的是最新的TCP协议栈和设置,并优化,减少你的证书链的大小。少发送字节总是良好的和有价值的优化。\n\n## 配置OCSP装订\n每一个新的TLS连接要求,浏览器必须验证发送的签名证书链。然而,还有一个重要的步骤,我们不能忘记:浏览器也需要验证证书没有被撤销。\n\n验证证书的状态浏览器可以使用几种方法之一:证书撤销列表(CRL),在线证书状态协议(OCSP),或OCSP装订。每种方法都有自己的局限性,但OCSP装订提供,到目前为止,最好的安全性和性能guarantees-refer早期部分的细节。确保配置你的服务器包括(主食)提供证书的CA的OCSP反应链。这样做允许浏览器执行撤销检查没有任何额外的网络数据传输次数和提高安全保证。\n\nOCSP响应可以改变从400年到4000字节大小。装订这个响应你的证书链将增加其size-pay密切关注证书链的总大小,这样它不会溢出的初始拥塞窗口新的TCP连接。\n\n当前OCSP装订实现只允许一个单一的OCSP响应包含,这意味着浏览器可能要回退到另一个如果它需要验证其他证书撤销机制的chain-reduce证书链的长度。在未来,OCSP Multi-Stapling应该解决这个问题。\n\n最受欢迎的服务器支持OCSP装订。检查相关文档的支持和配置说明。同样,如果使用或决定一个CDN,检查他们的TLS堆栈支持和配置为使用OCSP装订。\n\n## 启用HTTP严格的传输安全性(hst)\nHTTP严格的交通安全是一个重要的安全策略机制,允许一个起源宣布访问规则通过一个简单的HTTP header-e.g兼容的浏览器。“Strict-Transport-Security:信息= 31536000”。具体地说,它指示用户代理执行以下规定:\n\n所有请求的起源应该发送/ HTTPS。这包括导航和所有其他同源子资源requests-e.g。如果用户类型没有https URL前缀用户代理应该自动将它转换成一个https请求;如果一个页面包含一个引用非http资源,用户代理应该自动转换成请求https版本。\n\n如果不能建立一个安全连接,用户不允许绕过HTTP version-i.e警告和请求。origin的协议是是https。\n\n信息在几秒钟内指定指定hst的生命周期规则集(例如, max-age=31536000等于365天一生的广告策略)。\n\nincludeSubdomains表明当前的政策应该适用于所有子域。\n\nhst origin 转换为一个https目的地和帮助保护应用程序从各种各样的被动和主动网络的攻击。还有一个额外的好处,它还提供了一个不错的性能优化通过消除需要HTTP-to-HTTPS重定向:客户端自动重写所有请求安全起源之前派遣!\n\n确保启用hst之前彻底地测试您的TLS部署。一旦政策是由客户端缓存,未能协商将导致hard-fail-i.e TLS连接。用户将看到浏览器错误页面,不会被允许继续下去。这种行为是明确的和必要的设计选择,以防止网络攻击者骗取客户没有HTTPS访问你的网站。\n\n## hst预加载列表\n\nhst机制留下第一个请求的来源不受保护的积极attacks-e.g。恶意方可以降低客户的请求,并防止它注册hst政策。为了解决这个问题,大多数浏览器提供一个单独的“hst预加载列表”机制,该机制允许一个起源请求包含列表中的HSTS-enabled附带浏览器的网站。\n\n一旦你有信心在你的HTTPS部署,考虑提交你的网站到hst通过预加载列表hstspreload.appspot.com.\n\n## 启用 HTTP Public Key Pinning (HPKP)\n的缺点之一,当前系统中讨论链的信任和证书颁发机构是我们的依赖大量的受信任的证书颁发机构(CA)。一方面,这是方便的,因为它意味着我们可以获得一个有效的证书从一个大池的实体。然而,这也意味着其中任何一个实体也能够发出有效的证书给我们\n\nDigiNotar认证权威的妥协的引人注目的例子之一是一个攻击者能够发行和使用虚假但有效证件与数以百计的高调的网站。\n\nHPKP允许一个站点发送一个HTTP头指示浏览器记住(“pin”)一个或多个证书的证书链。通过这样做,它可以范围证书,或者发行人,应该接受浏览器在随后的访问:\n\norigin可以销毁叶证书。这是最安全的策略,因为,实际上,硬编码一个小的特定证书签名应该接受浏览器。\n\n父的起源可以销一个证书的证书链。例如,原点可以销中级证书的CA,告诉浏览器,这个特殊的起源,它应该只信任证书签署的证书颁发机构。\n\n销哪个证书,选择正确的战略和多少备份提供,时间,和其他标准部署HPKP是重要的,微妙的,超出了我们的讨论范围。咨询你的最喜欢的搜索引擎,或者你当地的安全专家,以获取更多信息。\n\nHPKP还公开一个“报告”模式,不执行提供销但能够检测到故障报告。这是一个伟大的第一步验证您的部署,和作为一种机制来检测违规。\n\n## 更新网站内容,HTTPS\n得到最好的安全性和性能担保实际上是至关重要的,网站使用HTTPS来获取它的所有资源。否则,我们遇到一些问题,最坏的就是网站崩溃\n\n将被浏览器混合的“活跃”内容(如HTTP上的脚本和样式表传递)可能会破坏网站的功能。\n\n混合的“被动”内容(如图片、视频、音频等,交付通过HTTP)将获取,但将允许攻击者观察和推断用户活动,并降低性能要求额外的连接和握手。\n\n审计内容和更新你的资源和链接,包括第三方的内容,使用HTTPS。的内容安全政策(CSP)机制可以很大的帮助,确定违反HTTPS和执行所需的政策。\n\nContent-Security-Policy: upgrade-insecure-requests \nContent-Security-Policy-Report-Only: default-src https:;\n  report-uri https://example.com/reporting/endpoint \n告诉浏览器升级所有(自己的和第三方)请求HTTPS。\n告诉浏览器报告任何违反非http指定端点。\nCSP提供了一个高度可配置的机制来控制哪些资产可以被使用,以及如何,从那里他们可以获取。利用这些功能,可以保护你的网站和你的用户。\n\n# 性能检查表\n作为应用程序开发人员我们免受大多数TLS协议的复杂性客户机和服务器代表我们做最困难的工作。然而,正如我们在本章中看到的,这并不意味着我们可以忽视在TLS交付我们的应用程序的性能方面。优化我们的服务器,使关键TLS优化和配置应用程序启用客户端利用这些特性支付高额股息:更快的握手,减少延迟,更好的安全保障,等等。\n\n考虑到这一点,一个简短的清单放在议事日程:\n\n从TCP获得最佳性能;请参阅优化TCP.\n\nTLS库升级到最新版本,和(重新)构建服务器。\n\n启用和配置会话缓存和无状态的恢复。\n\n监控你的会话缓存命中率,并相应地调整配置。\n\n配置向前保密密码启用TLS FALSE Start。\n\n终止TLS会话更接近用户往返延迟最小化。\n\n使用动态TLS记录分级优化延迟和吞吐量。\n\n审计和优化你的证书链的大小。\n\n配置OCSP装订。\n\n配置hst和HPKP。\n\n配置CSP的政策。\n\n启用HTTP / 2;看到HTTP / 2.\n\n# 测试和验证\n最后,为了验证和测试您的配置,您可以使用一个在线服务,比如Qualys SSL服务器测试扫描你的公共服务器常见配置和安全漏洞。此外,你应该熟悉 openssl命令行界面,这将帮助你检查整个握手并在本地配置你的服务器。\n\n    $ > openssl s_client状态-CAfile startssl.ca。crt连接igvita.com:443\n    \n    连接(00000003)\n    SSL_connect:前/连接初始化\n    SSL_connect:SSLv2的站点时/ v3写客户你好\n    SSL_connect:SSLv3读服务器你好\n    深度= 2 / C = IL / O = StartCom有限公司/ OU =安全数字证书签名\n    / CN = StartCom认证权威\n    验证返回:1\n    深度= 1 / C = IL / O = StartCom有限公司/ OU =安全数字证书签名\n    / CN = StartCom类1主要中间服务器\n    验证返回:1\n    深度= 0 = ABjQuqt3nPv7ebEG /描述/ C =\n    / CN =www.igvita.com/emailAddress=ilya@igvita.com\n    验证返回:1\n    SSL_connect:SSLv3读服务器证书\n    SSL_connect:SSLv3读服务器做了\n      SSL_connect:SSLv3 write client key exchange A\n      SSL_connect:SSLv3 write change cipher spec A\n      SSL_connect:SSLv3 write finished A\n      SSL_connect:SSLv3 flush data\n      SSL_connect:SSLv3 read finished A\n      ---\n      Certificate chain \n       0 s:/description=ABjQuqt3nPv7ebEG/C=US\n           /CN=www.igvita.com/emailAddress=ilya@igvita.com\n         i:/C=IL/O=StartCom Ltd./OU=Secure Digital Certificate Signing\n           /CN=StartCom Class 1 Primary Intermediate Server CA\n       1 s:/C=IL/O=StartCom Ltd./OU=Secure Digital Certificate Signing\n           /CN=StartCom Class 1 Primary Intermediate Server CA\n         i:/C=IL/O=StartCom Ltd./OU=Secure Digital Certificate Signing\n           /CN=StartCom Certification Authority\n      ---\n      Server certificate\n      -----BEGIN CERTIFICATE-----\n      ... snip ...\n      ---\n      No client certificate CA names sent\n      ---\n      SSL handshake has read 3571 bytes and written 444 bytes \n      ---\n      New, TLSv1/SSLv3, Cipher is RC4-SHA\n      Server public key is 2048 bit\n      Secure Renegotiation IS supported\n      Compression: NONE\n      Expansion: NONE\n      SSL-Session:\n          Protocol  : TLSv1\n          Cipher    : RC4-SHA\n          Session-ID: 269349C84A4702EFA7 ... \n          Session-ID-ctx:\n          Master-Key: 1F5F5F33D50BE6228A ...\n          Key-Arg   : None\n          Start Time: 1354037095\n          Timeout   : 300 (sec)\n          Verify return code: 0 (ok)\n      ---\n\n客户端完成验证收到的证书链。\n收到证书链(两个证书)。\n收到了证书链的大小。\n发布了有状态的会话标识符TLS的简历。\n在前面的例子中,我们连接igvita.com在默认的TLS端口(443),并执行TLS握手。因为 s_client没有假设已知的根证书,我们手动指定路径StartSSL证书的根证书Authority-this是很重要的。浏览器已经StartSSL的根证书,因此能够验证链,但是 s_client没有这样的假设。试着删除根证书,你将看到一个验证错误日志中。\n\n检查证书链显示服务器发送两个证书,加起来3571个字节。同时,我们可以看到协商会话variables-chosen TLS协议,密码,钥匙,我们还可以看到服务器发布当前会话的会话标识符。\n\noutshineamaze: 时间匆忙, 如有错误, 多多包涵\n","tags":["TSL"],"categories":["网络协议"]},{"title":"面试","url":"%2F2016%2F04%2F01%2Fdaily_think%2F%E9%9D%A2%E7%BB%8F%2F","content":"\n\n来吧，竟然一天面完了二面和hr面，那就来碎碎念一下吧\n昨天晚上半夜12点多才收到二面的通知短信，导致我一晚都没有睡好，确切的说来武汉的三天我基本就睡了7个小时。毕竟是第一次现场面试，所以特别的紧张。\n二面面试官竟然没有和我握手，不开心，不过还是挺和善的\n1   自我介绍\n2   介绍一下主流的框架吧，angular 和react，原理，实现。 我把angular的watch digest这些讲了个遍，也问了关于react的虚拟dom，为什么要这么做，优势在哪里？ 使用这些前端的框架的优势是什么，劣势又是什么 。 （看我把原理讲的差不多，问我是不是在网上看了很多的这方面的文章，卧槽竟然别发现了，这些东西都是我面试前一天看的，我立马意识到不对），其实呢，框架对于我来说并不是要熟悉多少它的api，而是要研究它的设计思想，这样对自己以后的编码也是有帮助的哈（成功避开话题）\n<!-- more -->\n3.  既然你简历里面提到python，php，java， 说说你的对python php java等语言的理解吧，说完之后， 又问动态语言和静态语言的理解，还设了个坑给我跳（谈谈你对静态语言解释器的理解，这明显是挖坑），静态语言需要啥解释器啊，不过后面我巴拉巴拉一大堆关于jit的东西\n 算法题： 设计一种算法可以求出 某个数字是否 在10亿个数中出现过，  一开始我就是说直接用O(n)复杂度的直接遍历就是，但是不满意，我就说：把这些数字分成N组吗，然后在每组中查找，还是不满意后，算了，跳过，我认输\n又是一个很老题目，浏览器地址栏输入一个qq.com，发生了什么，讲出你所知道的所有的内容。 因为是面的前端，我在tcp层下面就没有详细讲了，主要讲了dns，三次握手，四次挥手，服务器接收请求，路由，逻辑控制代码返回response，浏览器接收到返回，解析，渲染。。。既然是面的前端，面试官叫我着重讲一下浏览器的渲染过程，比如js代码什么时候运行啊，css代码上面时候渲染啊，js代码运行阻塞页面渲染之类的，勉强解释过去。我看了那么久的网络编程竟然不问我不甘心啊，我就在后面补了补关于tcp udp的知识概念，主要讲了区别，优缺点，就是那种百度一下就知道的几个概念。\n因为项目中用过很多redis，难免要去解释一下redis的底层，首先说了说底层的数据结构，然后redis是一个基于epoll的单线程模型，redis的应用举例，在你的项目中如何使用，说到设置expire时间的时候，我给自己挖了个坑，面试官问我如何实现定时器，redis中有没有定时器这个概念（其实是没有的）我入坑了， ，后来发现不对劲，赶紧说自己好久没有研究这个底层了，有些概念可能有些模糊了。后来面试官提醒我是用epoll注册事件的方法来实现expire的。自认为redis应该是自己的加分项，没有想到是减分项。\n介绍一下你的项目，用了哪些技术，遇到什么困难，这个问题我早就知道他会问，所以提前就把简历上面所有的项目全部准备好，基本就是背书似的，当然不能显得多么厉害，只要讲清楚自己的遇到问题是如何解决的，面试官比较在乎你是怎么解决问题的\n\n为什么你决定做前端，因为（省略1000字）\n有啥想问我的\n有，我面试表现的怎么样\n还可以，总的来说还可以，就是算法不怎么样\n算法不怎么样就是因为刚才那个题目没有答好么？\n是的，\n可是我平时都有在刷题啊，刚才是紧张而已\n理解，本科生嘛\n那么面试结果什么时候出来，我是外地的\n我看看能不能帮你联系hr下午面试\n下午两点 hr面\n\nhr面\n短信通知时下午四点，但是貌似我一点就在等了，前台好像不忍心，因为我晚上要赶车回南昌，就把我笔试提前到2点，算是比较早的一批了\n原来以为hr都是那种打扮很精致的女生，没想到是个很年轻秀气的男生和一个很年boss，就这样我参加了一个有两个hr的面试\n问题没有参考意义，但是我还是要说；\n1 ，自我介绍\n2 ，创业经历\n3，失败总结\n4， 有么有女朋友\n5， 业余爱好，喜欢看什么书，除了技术书还喜欢看什么书（我说我以前喜欢看点鸡汤书，因为需要动力，当自己开始写鸡汤的时候就不看了）\n6，技术观，说说你对技术热爱到什么程度\n7， 对腾讯有什么看法（我说了我高中的时候很笔试腾讯，但是后来做技术的时候开始慢慢尊敬仰慕腾讯了）\n8， 假如你以后要创业，但是你这么热爱技术，你怎么办？\n9 你班长叫啥，你班长是哪里人，你班长有没有女朋友，你和你班长一起经历过什么事情或者合作，你和你班长。。。。。。。。。\n10， 你家庭状况\n11 ， 遇到过什么让你很挫败的事情\n12， 腾讯阿里你选哪个？\n面了我40多分钟，最后我 嘴巴都干的说不动了，回去等offer吧\n（小插曲，我晚上坐在高铁上的时候接到武汉的电话，叫我回去面试，吓死我了，我赶紧打电话给我二面的面试官，后来hr又打电话过来，来个电话面试吧，先自我介绍一下吧，我就巴拉巴拉的背了一下自我介绍，后面我说我下午已经hr面试完了啊，两个面试官在9楼，“哦，那不就是我么”， 面试官哈哈一笑，表示自己忘记了已经面过我了。\n\n\n","tags":["daily_think"],"categories":["实习总结"]},{"title":"我的编程之路","url":"%2F2016%2F03%2F01%2Fdaily_think%2F%E6%88%91%E7%9A%84%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%B7%AF-2016-3%2F","content":"\n\n## 简单介绍一下自己和目前的情况\n我是周磊，经常使用outshine和梦很想家这两个id在网络中。现在还是一名大三的物联网专业的学生，目前就读于南昌大学，性别男，爱好女以及编程，做过单片机，画过pcb也焊过电路板，玩过操作系统，写过移动应用，研究过室内定位算法，可是现在还不能随手撸一个快排，写过前端，在做web后台，偶尔也做做网络编程，也会碰一碰计算机的底层组成原理，玩转数字电路中的与或非，熟悉面向对象中的语法糖，手写sql也非常六，实现过四则运算解释器，也用python扒一扒过某些网站。。。。。\n<!-- more -->\n你要问我不会什么，我现在仍然不会“科学上网”，至于为什么，因为我是社会主义的接班人啊（逃\n## 我是如何走上编程的道路\n\n大一的的C语言课程并没有勾起我软件开发的兴趣，而且那时候C语言才考了68分，那时候对Adobe系列的软件很感兴趣，觉得ps和ae，pr什么的很酷有没有啊，office也玩转的很溜。真正开始自主学习编程是因为两年前的现在，学院有个网页设大赛，没错，我报名了，没有任何基础，用了一个礼拜入门了html和css，看懂js代码，然后上各种网站去找“灵感”，拼接出一个很简单粗暴但是又富有情趣的静态页面。结果当然是被刷了，毕竟内容不是很健康。下面来列一列这两年都干了什么（这是我自己的回忆碎碎念，请直接滑到下一节内容）\n\n - 2014.4-6： 开始学习php这编程语言，使用WordPress搭建个人博客，使用免费的国外主机vps部署博客网站，然后也开始学习使用php给自己的博客加功能，修改别人的主题，慢慢滴巩固前端的知识。\n - 2014.6-8：不知道哪天突然对单片机这个听说很久的玩意感兴趣，二话不说，淘宝买个开发板，学，一开始就把各个模块都玩了一遍，把各个程序也都跑了一遍，自己也开始组合各种模块做点小玩具出来玩，那个暑假前一个月时间是在实验室度过的，在这里要感谢一下王老师的细心“栽培”，知道我会ps天天找我p图。呆的不耐烦了，七月底回家十五天，回学校就没有去过实验室了，自己呆在寝室研究ucos（单片机上的实时操作系统），当然回家也没有闲着，开始接触arm单片机，印象最深的是有一天爸爸一点钟回来，看我在调代码，说陪我一起熬夜，然而并没有多久就都睡了。\n - 2014.9-11：这两个月基本是一直在研筹备自己认为可以改变人类生活方式的项目“室内定位项目”，我花了几个礼拜调研，组建团队，国庆都没有回家自个儿呆在图书馆读了30多篇相关的论文， 这是我第一次和别人组队做一个项目，没有经验，后面人都走了，就剩我一个人操心，后来项目搁置。这段时间开始对数据结构算法开始感兴趣，大概是看了那么多论文的关系，觉得特别亲切。网易云课堂听老外bb了十几节课不耐烦了，自己看书去，一来我就上算法导论了，当然是各种看不懂，还好图书馆有丰富的资源。\n - 2014.11-2015.3： 这段一大段时间我在做windowphone app开发，那时候我把自己定义为不离不弃的软粉，自学wp开发，做自己想做的app，顺便用了C#，这个确实比java好用点，期末在图书馆复习的时候顺便把计算机组成原理看了，果然博大精深啊。寒假在家用C#撸了部分算法导论里面的算法，想做成自己的代码库以后直接调用的。期间最伟大的是做了一个创意app，利用手机的磁场感应传感器，实时获取磁铁相对于手机的三维位置，里面也用了牛逼的卡尔曼滤波器做数据处理，然而演示demo就是一堆数字，并没有传统里那种炫酷的演示动画。因为我就是不会啊。\n - 2015.3-4：这个期间去学习后街的一个外包公司学习ios的跨平台开发，好啊，用C#技术，刚好趁热打铁。开始的第一个项目都是计算器，仿ios自带的那种，做了三天做出来个大概，boss就叫我上项目了，参与到项目的开发跟着开会讨论项目，好景不长，一个大学算是接触的第二多的女生突然说请我吃饭，果然，只差一个程序员了，就这样我考虑了一天后就开始创业了。其实这段时间也学习了我现在主要使用的开发语言python，一个礼拜入门，两个礼拜开始用django做网站，至此学什么东西都超级快啦！！！\n - 2015.4-12： 这个期间算是大学难忘的一段时间，因为我创业了啊！ 具体都干些什么了呢? 开会，写web后台，写前端，改后台，改前端，开会，循环。当然这段经历学习到很多，不管是web开发技术上还是团队合作，都给我很多新的见解。技术方面，理解最深的就是mvc的后台框架，后来自己也实现了自己的php组装框架（模仿laravel的）  用熟了git和github，部署服务器也很有一套，不过这应该是技术上我最讨厌的事情了。数据库也看了好几本大头书，可是现在连B+树索引的实现记不住。你要问为什么难忘的事情还写的这么少，因为有一些悲伤的事情不想回忆啊！！！！！！\n - 2015.12-2016.2：又是期末复习的阶段，这真是看书的极佳的时机，linux内核和深入理解计算机系统，影响很大，推荐阅读。期间也做了一个自己一直想做的高性能框架，自己照着其他的优秀框架取其精华去其糟粕，因为涉及到网络编程，所以对tcp ip也有跟深入的理解，然而说的来epoll模型的level trigger和edge trigger，却一下子回忆不起osi七层模型对应的具体功能，还有前天面试的时候连tcp三次握手四次拜拜都讲不清楚（妈的智障）\n - 2016.2-3：寒假 啊！！！！，没有看书，写了两个礼拜的代码，完善了iotshine物联网框架，改版了一个去年6月份做的小音乐留言板网站，具体干嘛用的？ 就是用户搜索音乐，后台全网匹配，抓取歌曲链接，生成留言板，分享出来，好友评论吐槽。\n - 至今2016.3.19：开学呆着家里的各种不愉快来到学校，开始了实习生的求职生活，每天刷题，看面经，投简历，泡论坛和qq群，完善自己在简历上吹的牛，投了十几家，挂了五家，目前在专心准备bat网易等公司的笔试。为什么笔试？ 因为劳资没有拿到内推啊！~~~（对了，提前申请免修单片机课，花了一个礼拜做课程设计答辩通过了，这个学期少一门课了）\n好了，碎碎念完了，下面进入主题。\n## 介绍一些你比较喜欢的软件和硬件\n\n#### 硬件：\n树莓派是首选，为啥？这可是最小的卡片电脑，上面可以跑Windows iot系统，还有linux系列的Ubuntu等，接上显示器还有gui界面，用firefox直接上b站看视频不是很爽？拿来开发自己的智能的路由器也不错，也可以做挂个硬盘做下载神器，gpio口给你充分的接口去接上那些硬件模块，在上面直接跑一个socket客户端做个网关也不错。一句话总结：此乃居家下片，diy装逼的一大神器。你要说还有其他的么？\n\n当然有了，微软的HoloLens黑科技啊，可谁买得起啊。还有各种VR眼镜。。。。。  \nArduino也不错，是一款便捷灵活、方便上手的开源电子原型平台（其实就是小学生都会玩的意思）\n#### 软件：\n git/github，sublime编辑器，vs2016（宇宙最好用的IDE），OneNote(手机电脑同步好用到爆炸啊)，手机app太多没有研究过。当然还有我最良心的网易云音乐啦（借用你的api我真的不是故意的） \n\n 电脑上软件很多，但是用的最多的就是git，sublime，powershell这几个，最后再推荐一下Mobaxterm这个软件，体验完爆putty，很好的远程终端。\n\n## 作为工具控的你们也可以分享自己在工作、学习、生活中用到的神器\n一个好的拓展显示屏，一个手感过得去的机械键盘，一个软一点的椅子，一个安静的环境，要是有个女朋友就更好了！！！！\n\n## 有没有写过一些黑科技（狂拽酷炫屌炸天）型程序\n\n没有，因为在我看来（狂拽酷炫屌炸天）型程序 是 ai，MachineLearning，Deepmind，Datamining，vr，计算机图形引擎，操作系统内核等都对人类有很大影响的程序，而不是学生期间直接做的那些小玩意。物联网加大数据加云计算才是未来（吹的有点过，但是是事实）\n## 推荐一些书籍或者编程大杀器给大家呗，加 1W 个推荐理由\n\n[程序员必读书单][1] 这里有很好的推荐，准没有错。\n当然我还是加两本：《程序员面试宝典》和《颈椎病康复指南》\n\n\n\n## 哪些好的习惯程序员值得拥有？\n代码有 注释，统一的命名风格。同时程序员本身要有 良好的心理承受能力，还有坐姿要端正，健康的身体（不然就真的钱多话少shi的早，留下老婆跟人跑）\n## 能讲一讲在编程路上踩过哪些坑么？\n\n微软在Windows Phone上垃圾的api！！！！\n## 对哪方面技术的发展比较看好（AI, AR, VR, etc.）？\n\n都看好，都是以后的趋势，好吧，还是选AI吧，毕竟alphaGo那么厉害！\n## 请推荐一些程序员专用的追妹子 or 汉子大法。\n\n程序员最好的成长环境是单身，追什么妹子！！！\n## 编程过程中有没有一些小癖好，比如喝酒、句号都改成了分号等？\n\n要穿拖鞋，宽松的裤子（因为要久坐，不能勒到***），手机扔一边（特别重要），qq微博知乎还有各种网站不能上不能上不能上\n\n## 总结：\n其实我本不必做一个程序员，可是谁叫我走上这个不归路，并且还想成为一个full stack \n\n从前一直有很多梦想，但是上了大学遇到喜欢的人之后，开始觉得以后有个温馨的家庭就是最终目标了，所以我的id“梦很想家”就是这么来的：从前有很多梦想，遇见那个人之后，所有的梦想都变成想家了，有个梦，很想家。\n\n至于outshine  ，我翻译成光彩夺目的，高中时就告诉自己要outshine\n\n![换个角度看世界][2]\n\n\n  [1]: http://lucida.me/blog/developer-reading-list/\n  [2]: /img/bVtC0i","tags":["daily_think"]},{"title":"Python实例一个类发生了什么","url":"%2F2015%2F07%2F01%2Fcoding%2FPython%E5%AE%9E%E4%BE%8B%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%2F","content":"\n\n## 写在最前面:\n一些很重要的知识,我的写得有点乱,也可以去看这些文章,\nPython 面向对象（初级篇）\n来自 <http://python.jobbole.com/82023/> \npython 面向对象（进阶篇)\n来自 <http://python.jobbole.com/83747/> \n深刻理解Python中的元类(metaclass)\n来自 <http://python.jobbole.com/21351/> \n\n<!-- more -->\n\n\n首先来看一个例子,正常情况下我们定义并且实例一个类如下\n\n    class Foo(object):\n     \n        def __init__(self):\n            pass\n     \n    obj = Foo()   # obj是通过Foo类实例化的对象\n\n上述代码中，obj 是通过 Foo 类实例化的对象，其实，不仅 obj 是一个对象，Foo类本身也是一个对象，因为在Python中一切事物都是对象。\n\n    print type(obj) # 输出： Foo 表示，obj 对象由Foo类创建\n    print type(Foo) # 输出：type表示，Foo类对象由 type 类创建\n\n如果按照一切事物都是对象的理论：\n#### obj对象是通过执行Foo类的构造方法创建，那么Foo类对象应该也是通过执行某个类的 构造方法 创建。\n\n## 两个基本的类\n这里和有必要提到一下在Python中有两个最基本的对象，<type ‘object’> 和 <type ‘type’>，这两个对象是所有对象的起源。\n1.  <type ‘type’>的类型是<type ‘type’>（它本身），<type ‘type’>的父类是<type ‘object’>\n2.  <type ‘object’>的类型是<type ‘type’>，<type ‘object’>没有父类\n\n在Python对象系统中，<type ‘object’>和<type ‘type’>的关系就像鸡和蛋的关系，不能说谁先于（创建）谁，两者是相互依赖的，共同构成了Python对象系统的基础.有点难理解,不过没有关系,知道有种这么两个东西就好了,比较我们也不是设计Python的人,没有必要搞的那么清楚.\n\n\n## 类的创建\n主要有两种方式,不过本质上都是一样的,都是通过type类来实例一个用户类\n\n    普通方式\n    Python\n    1   class Foo(object):\n    2    \n    3       def func(self):\n    4           print 'hello wupeiqi'\n\n    特殊方式（type类的构造函数）\n    Python\n    1   def func(self):\n    2       print 'hello wupeiqi'\n    3    \n    4   Foo = type('Foo',(object,), {'func': func})\n    5   #type第一个参数：类名\n    6   #type第二个参数：当前类的基类\n    7   #type第三个参数：类的成员\n\n由上面可以看出来  ,     Foo类是由type类实例而来,那么具体的创建的过程是怎么样的呢,接着往下面看:\n\n\n## 来了解几个概念\n__new__ 和 __init()和__metaclass__:\n\n - __new__函数是实例一个类所要调用的函数,每当我们调用obj = Foo()来实例一个类时,都是先调用__new__()\n - 然后再调用__init__()函数初始化实例.   __init__()在__new__()执行后执行,\n - 类中还有一个属性 __metaclass__，其用来表示该类由 谁 来实例化创建，所以，我们可以为 __metaclass__ 设置一个type类的派生类，从而查看 类 创建的过程。\n## 阐述运行过程\n![Python实例一个类背后1](Python实例一个类背后1.png)\n![Python实例一个类背后2](Python实例一个类背后2.png)\n\n\n\n\n\n\n1.  mytype产生一个叫做Foo的实例,主要的原理就是设置了,__metaclass__=MyTypoe,这样就指定mytype类来实例foo类,如果Python没有找到__metaclass__，它会继续在（父类）中寻找        __metaclass__属性，并尝试做和前面同样的操作。如果Python在任何父类中都找不到__metaclass__，它就会在模块层次中去寻找__metaclass__，并尝试做同样的操作。如果还是找不到__metaclass__,Python就会用内置的type来创建这个类对象。\n\n2.  mytype类中的__new__方法返回了一个对象,所有的Python实例都是这句代码创建的type.__new__(cls,name,bases,attrs)\n\n3.  mytype的__init__()函数初始化Foo类,在这里我们可以和在__new__()函数一样设置Foo类的attr属性,比如类中的方法,字段属性等\n\n4.  和Foo类的创建过程一样,studen类继承了Foo类,所以重复123步骤,得到一个studen类\n\n5.  当用户使用Foo()或者studen()来实例类时,会默认调用类中的_new_()方法,要是之类里面没有这个方法就到父类里面寻找__new__(),我们可以充分利用这个new函数,比如来实现Python中的单例模式,或者对类成员进行批量的修改等等.\n\n6.  产生了一个实例后马上执行__init__()函数,进行初始化实例,\n\n7.  由上面的运行结果可以看出,其中Foo和studen类的类型是<class '__main__.MyType'>,这也证明了Foo类和studen类都是由MyType实例而来…而第三个例子,可以看出Foo2类的类型是<type 'type'>,这个并不例外,Foo2继承了object类,(这个,还是跳过吧,前面已经讲过type和object相爱相杀的关系了)\n    \n    \n##总结:\n首先，你知道了类其实是能够创建出类实例的对象。好吧，事实上，类本身也是实例，当然，它们是元类的实例。Python中的一切都是对象，它们要么是类的实例，要么是元类的实例，除了type。type实际上是它自己的元类，在纯Python环境中这可不是你能够做到的，这是通过在实现层面耍一些小手段做到的。其次，元类是很复杂的。对于非常简单的类，你可能不希望通过使用元类来对类做修改。你可以通过其他两种技术来修改类：\n    1. Monkey patching\n    2.   class decora\n","tags":["python"],"categories":["编程语言"]}]